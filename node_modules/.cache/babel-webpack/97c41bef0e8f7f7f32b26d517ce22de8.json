{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar webdriver_logger_1 = require(\"./webdriver_logger\");\n\nvar angularWaits = require('./client_scripts/wait.js');\n/**\n * A barrier that uses Angular's Testability API to block commands until the application is stable.\n */\n\n\nvar AngularWaitBarrier = /*#__PURE__*/function () {\n  function AngularWaitBarrier(client) {\n    _classCallCheck(this, AngularWaitBarrier);\n\n    this.client = client;\n    this.enabled = true;\n    this.rootSelector = '';\n  }\n  /**\n   * A CSS Selector for a DOM element within your Angular application.\n   * BlockingProxy will attempt to automatically find your application, but it is\n   * necessary to set rootElement in certain cases.\n   *\n   * In Angular 1, BlockingProxy will use the element your app bootstrapped to by\n   * default.  If that doesn't work, it will then search for hooks in `body` or\n   * `ng-app` elements (details here: https://git.io/v1b2r).\n   *\n   * In later versions of Angular, BlockingProxy will try to hook into all angular\n   * apps on the page. Use rootElement to limit the scope of which apps\n   * BlockingProxy waits for and searches within.\n   *\n   * @param rootSelector A selector for the root element of the Angular app.\n   */\n\n\n  _createClass(AngularWaitBarrier, [{\n    key: \"setRootSelector\",\n    value: function setRootSelector(selector) {\n      this.rootSelector = selector;\n    }\n  }, {\n    key: \"waitForAngularData\",\n    value: function waitForAngularData() {\n      return JSON.stringify({\n        script: 'return (' + angularWaits.NG_WAIT_FN + ').apply(null, arguments);',\n        args: [this.rootSelector]\n      });\n    }\n    /**\n     * Turn on WebDriver logging.\n     *\n     * @param logDir The directory to create logs in.\n     */\n\n  }, {\n    key: \"enableLogging\",\n    value: function enableLogging(logDir) {\n      if (!this.logger) {\n        this.logger = new webdriver_logger_1.WebDriverLogger();\n      }\n\n      this.logger.setLogDir(logDir);\n    }\n    /**\n     * Override the logger instance. Only used for testing.\n     */\n\n  }, {\n    key: \"setLogger\",\n    value: function setLogger(logger) {\n      this.logger = logger;\n    }\n  }, {\n    key: \"sendRequestToStabilize\",\n    value: function sendRequestToStabilize(command) {\n      return this.client.executeAsync(command.sessionId, this.waitForAngularData()).then(function (value) {\n        // waitForAngular only returns a value if there was an error\n        // in the browser.\n        if (value) {\n          throw new Error('Error from waitForAngular: ' + value);\n        }\n      });\n    }\n  }, {\n    key: \"shouldStabilize\",\n    value: function shouldStabilize(command) {\n      var url = command.url;\n\n      if (!this.enabled) {\n        return false;\n      } // TODO - should this implement some state, and be smart about whether\n      // stabilization is necessary or not? Would that be as simple as GET/POST?\n      // e.g. two gets in a row don't require a wait btwn.\n      //\n      // See https://code.google.com/p/selenium/wiki/JsonWireProtocol for\n      // descriptions of the paths.\n      // We shouldn't stabilize if we haven't loaded the page yet.\n\n\n      var parts = url.split('/');\n\n      if (parts.length < 4) {\n        return false;\n      }\n\n      var commandsToWaitFor = ['executeScript', 'screenshot', 'source', 'title', 'element', 'elements', 'execute', 'keys', 'moveto', 'click', 'buttondown', 'buttonup', 'doubleclick', 'touch', 'get'];\n\n      if (commandsToWaitFor.indexOf(parts[3]) != -1) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onCommand\",\n    value: function onCommand(command) {\n      var _this = this;\n\n      if (this.logger) {\n        command.on('data', function () {\n          _this.logger.logWebDriverCommand(command);\n        });\n      }\n\n      if (this.shouldStabilize(command)) {\n        var started = Date.now();\n        return this.sendRequestToStabilize(command).then(function () {\n          var ended = Date.now();\n\n          if (_this.logger) {\n            _this.logger.logEvent('Waiting for Angular', command.sessionId, ended - started);\n          }\n        });\n      }\n\n      return Promise.resolve(null);\n    }\n  }]);\n\n  return AngularWaitBarrier;\n}();\n\nexports.AngularWaitBarrier = AngularWaitBarrier;","map":{"version":3,"sources":["../../lib/angular_wait_barrier.ts"],"names":[],"mappings":";;;;;;;;;;AAEA,IAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAGA,IAAM,YAAY,GAAG,OAAO,CAAC,0BAAD,CAA5B;AAEA;;AAEG;;;IACH,kB;AAME,8BAAoB,MAApB,EAAiD;AAAA;;AAA7B,SAAA,MAAA,GAAA,MAAA;AAClB,SAAK,OAAL,GAAe,IAAf;AACA,SAAK,YAAL,GAAoB,EAApB;AACD;AAED;;;;;;;;;;;;;;AAcG;;;;;oCACa,Q,EAAgB;AAC9B,WAAK,YAAL,GAAoB,QAApB;AACD;;;yCAEyB;AACxB,aAAO,IAAI,CAAC,SAAL,CAAe;AACpB,QAAA,MAAM,EAAE,aAAa,YAAY,CAAC,UAA1B,GAAuC,2BAD3B;AAEpB,QAAA,IAAI,EAAE,CAAC,KAAK,YAAN;AAFc,OAAf,CAAP;AAID;AAED;;;;AAIG;;;;kCACW,M,EAAc;AAC1B,UAAI,CAAC,KAAK,MAAV,EAAkB;AAChB,aAAK,MAAL,GAAc,IAAI,kBAAA,CAAA,eAAJ,EAAd;AACD;;AACD,WAAK,MAAL,CAAY,SAAZ,CAAsB,MAAtB;AACD;AAED;;AAEG;;;;8BACO,M,EAAuB;AAC/B,WAAK,MAAL,GAAc,MAAd;AACD;;;2CAE8B,O,EAAyB;AACtD,aAAO,KAAK,MAAL,CAAY,YAAZ,CAAyB,OAAO,CAAC,SAAjC,EAA4C,KAAK,kBAAL,EAA5C,EAAuE,IAAvE,CAA4E,UAAC,KAAD,EAAU;AAC3F;AACA;AACA,YAAI,KAAJ,EAAW;AACT,gBAAM,IAAI,KAAJ,CAAU,gCAAgC,KAA1C,CAAN;AACD;AACF,OANM,CAAP;AAOD;;;oCAEuB,O,EAAyB;AAC/C,UAAM,GAAG,GAAG,OAAO,CAAC,GAApB;;AACA,UAAI,CAAC,KAAK,OAAV,EAAmB;AACjB,eAAO,KAAP;AACD,OAJ8C,CAM/C;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAM,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,GAAV,CAAd;;AACA,UAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AACpB,eAAO,KAAP;AACD;;AAED,UAAM,iBAAiB,GAAG,CACxB,eADwB,EACP,YADO,EACO,QADP,EACiB,OADjB,EAC0B,SAD1B,EACqC,UADrC,EACiD,SADjD,EAC4D,MAD5D,EAExB,QAFwB,EAEd,OAFc,EAEL,YAFK,EAES,UAFT,EAEqB,aAFrB,EAEoC,OAFpC,EAE6C,KAF7C,CAA1B;;AAKA,UAAI,iBAAiB,CAAC,OAAlB,CAA0B,KAAK,CAAC,CAAD,CAA/B,KAAuC,CAAC,CAA5C,EAA+C;AAC7C,eAAO,IAAP;AACD;;AACD,aAAO,KAAP;AACD;;;8BAES,O,EAAyB;AAAA;;AACjC,UAAI,KAAK,MAAT,EAAiB;AACf,QAAA,OAAO,CAAC,EAAR,CAAW,MAAX,EAAmB,YAAK;AACtB,UAAA,KAAI,CAAC,MAAL,CAAY,mBAAZ,CAAgC,OAAhC;AACD,SAFD;AAGD;;AAED,UAAI,KAAK,eAAL,CAAqB,OAArB,CAAJ,EAAmC;AACjC,YAAM,OAAO,GAAG,IAAI,CAAC,GAAL,EAAhB;AACA,eAAO,KAAK,sBAAL,CAA4B,OAA5B,EAAqC,IAArC,CAA0C,YAAK;AACpD,cAAM,KAAK,GAAG,IAAI,CAAC,GAAL,EAAd;;AACA,cAAI,KAAI,CAAC,MAAT,EAAiB;AACf,YAAA,KAAI,CAAC,MAAL,CAAY,QAAZ,CAAqB,qBAArB,EAA4C,OAAO,CAAC,SAApD,EAAgE,KAAK,GAAG,OAAxE;AACD;AACF,SALM,CAAP;AAMD;;AACD,aAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;AACD;;;;;;AAhHH,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst webdriver_logger_1 = require(\"./webdriver_logger\");\nconst angularWaits = require('./client_scripts/wait.js');\n/**\n * A barrier that uses Angular's Testability API to block commands until the application is stable.\n */\nclass AngularWaitBarrier {\n    constructor(client) {\n        this.client = client;\n        this.enabled = true;\n        this.rootSelector = '';\n    }\n    /**\n     * A CSS Selector for a DOM element within your Angular application.\n     * BlockingProxy will attempt to automatically find your application, but it is\n     * necessary to set rootElement in certain cases.\n     *\n     * In Angular 1, BlockingProxy will use the element your app bootstrapped to by\n     * default.  If that doesn't work, it will then search for hooks in `body` or\n     * `ng-app` elements (details here: https://git.io/v1b2r).\n     *\n     * In later versions of Angular, BlockingProxy will try to hook into all angular\n     * apps on the page. Use rootElement to limit the scope of which apps\n     * BlockingProxy waits for and searches within.\n     *\n     * @param rootSelector A selector for the root element of the Angular app.\n     */\n    setRootSelector(selector) {\n        this.rootSelector = selector;\n    }\n    waitForAngularData() {\n        return JSON.stringify({\n            script: 'return (' + angularWaits.NG_WAIT_FN + ').apply(null, arguments);',\n            args: [this.rootSelector]\n        });\n    }\n    /**\n     * Turn on WebDriver logging.\n     *\n     * @param logDir The directory to create logs in.\n     */\n    enableLogging(logDir) {\n        if (!this.logger) {\n            this.logger = new webdriver_logger_1.WebDriverLogger();\n        }\n        this.logger.setLogDir(logDir);\n    }\n    /**\n     * Override the logger instance. Only used for testing.\n     */\n    setLogger(logger) {\n        this.logger = logger;\n    }\n    sendRequestToStabilize(command) {\n        return this.client.executeAsync(command.sessionId, this.waitForAngularData()).then((value) => {\n            // waitForAngular only returns a value if there was an error\n            // in the browser.\n            if (value) {\n                throw new Error('Error from waitForAngular: ' + value);\n            }\n        });\n    }\n    shouldStabilize(command) {\n        const url = command.url;\n        if (!this.enabled) {\n            return false;\n        }\n        // TODO - should this implement some state, and be smart about whether\n        // stabilization is necessary or not? Would that be as simple as GET/POST?\n        // e.g. two gets in a row don't require a wait btwn.\n        //\n        // See https://code.google.com/p/selenium/wiki/JsonWireProtocol for\n        // descriptions of the paths.\n        // We shouldn't stabilize if we haven't loaded the page yet.\n        const parts = url.split('/');\n        if (parts.length < 4) {\n            return false;\n        }\n        const commandsToWaitFor = [\n            'executeScript', 'screenshot', 'source', 'title', 'element', 'elements', 'execute', 'keys',\n            'moveto', 'click', 'buttondown', 'buttonup', 'doubleclick', 'touch', 'get'\n        ];\n        if (commandsToWaitFor.indexOf(parts[3]) != -1) {\n            return true;\n        }\n        return false;\n    }\n    onCommand(command) {\n        if (this.logger) {\n            command.on('data', () => {\n                this.logger.logWebDriverCommand(command);\n            });\n        }\n        if (this.shouldStabilize(command)) {\n            const started = Date.now();\n            return this.sendRequestToStabilize(command).then(() => {\n                const ended = Date.now();\n                if (this.logger) {\n                    this.logger.logEvent('Waiting for Angular', command.sessionId, (ended - started));\n                }\n            });\n        }\n        return Promise.resolve(null);\n    }\n}\nexports.AngularWaitBarrier = AngularWaitBarrier;\n//# sourceMappingURL=angular_wait_barrier.js.map"]},"metadata":{},"sourceType":"script"}