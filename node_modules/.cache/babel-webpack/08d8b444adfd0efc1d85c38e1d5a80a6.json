{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\"); // Will use chalk if chalk is available to add color to console logging\n\n\nvar chalk;\nvar printRed;\nvar printYellow;\nvar printGray;\n\ntry {\n  chalk = require('chalk');\n  printRed = chalk.red;\n  printYellow = chalk.yellow;\n  printGray = chalk.gray;\n} catch (e) {\n  printRed = printYellow = printGray = function printGray(msg) {\n    return msg;\n  };\n}\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n  LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n  LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n  LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\nvar WriteTo;\n\n(function (WriteTo) {\n  WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n  WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n  WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n  WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(WriteTo = exports.WriteTo || (exports.WriteTo = {}));\n\nvar logFile = 'webdriver.log'; // the default log file name\n\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\n\nvar Logger = /*#__PURE__*/function () {\n  /**\n   * Creates a logger instance with an ID for the logger.\n   * @constructor\n   */\n  function Logger(id) {\n    _classCallCheck(this, Logger);\n\n    this.id = id;\n  }\n  /**\n   * Set up the write location. If writing to a file, get the file descriptor.\n   * @param writeTo The enum for where to write the logs.\n   * @param opt_logFile An optional parameter to override the log file location.\n   */\n\n\n  _createClass(Logger, [{\n    key: \"info\",\n\n    /**\n     * Log INFO\n     * @param ...msgs multiple arguments to be logged.\n     */\n    value: function info() {\n      for (var _len = arguments.length, msgs = new Array(_len), _key = 0; _key < _len; _key++) {\n        msgs[_key] = arguments[_key];\n      }\n\n      this.log_(LogLevel.INFO, msgs);\n    }\n    /**\n     * Log DEBUG\n     * @param ...msgs multiple arguments to be logged.\n     */\n\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len2 = arguments.length, msgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        msgs[_key2] = arguments[_key2];\n      }\n\n      this.log_(LogLevel.DEBUG, msgs);\n    }\n    /**\n     * Log WARN\n     * @param ...msgs multiple arguments to be logged.\n     */\n\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len3 = arguments.length, msgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        msgs[_key3] = arguments[_key3];\n      }\n\n      this.log_(LogLevel.WARN, msgs);\n    }\n    /**\n     * Log ERROR\n     * @param ...msgs multiple arguments to be logged.\n     */\n\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len4 = arguments.length, msgs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        msgs[_key4] = arguments[_key4];\n      }\n\n      this.log_(LogLevel.ERROR, msgs);\n    }\n    /**\n     * For the log level set, check to see if the messages should be logged.\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged\n     */\n\n  }, {\n    key: \"log_\",\n    value: function log_(logLevel, msgs) {\n      switch (Logger.logLevel) {\n        case LogLevel.ERROR:\n          if (logLevel <= LogLevel.ERROR) {\n            this.print_(logLevel, msgs);\n          }\n\n          break;\n\n        case LogLevel.WARN:\n          if (logLevel <= LogLevel.WARN) {\n            this.print_(logLevel, msgs);\n          }\n\n          break;\n\n        case LogLevel.INFO:\n          if (logLevel <= LogLevel.INFO) {\n            this.print_(logLevel, msgs);\n          }\n\n          break;\n\n        case LogLevel.DEBUG:\n          if (logLevel <= LogLevel.DEBUG) {\n            this.print_(logLevel, msgs);\n          }\n\n          break;\n\n        default:\n          throw new Error('Log level undefined');\n      }\n    }\n    /**\n     * Format with timestamp, log level, identifier, and message and log to\n     * specified medium (console, file, both, none).\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged.\n     */\n\n  }, {\n    key: \"print_\",\n    value: function print_(logLevel, msgs) {\n      var consoleLog = '';\n      var fileLog = '';\n\n      if (Logger.showTimestamp) {\n        consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n        fileLog += Logger.timestamp_(WriteTo.FILE);\n      }\n\n      consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n      fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n\n      if (Logger.showId) {\n        consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n        fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n      }\n\n      consoleLog += ' -';\n      fileLog += ' - ';\n\n      switch (Logger.writeTo) {\n        case WriteTo.CONSOLE:\n          msgs.unshift(consoleLog);\n          console.log.apply(console, msgs);\n          break;\n\n        case WriteTo.FILE:\n          // for the first line written to the file, add a space\n          if (!Logger.firstWrite) {\n            fs.writeSync(Logger.fd, '\\n');\n            Logger.firstWrite = true;\n          }\n\n          fileLog += ' ' + Logger.msgToFile_(msgs);\n          fs.writeSync(Logger.fd, fileLog + '\\n');\n          break;\n\n        case WriteTo.BOTH:\n          // for the first line written to the file, add a space\n          if (!Logger.firstWrite) {\n            fs.writeSync(Logger.fd, '\\n');\n            Logger.firstWrite = true;\n          }\n\n          fileLog += ' ' + Logger.msgToFile_(msgs);\n          fs.writeSync(Logger.fd, fileLog + '\\n');\n          msgs.unshift(consoleLog);\n          console.log.apply(console, msgs);\n          break;\n\n        case WriteTo.NONE:\n          break;\n      }\n    }\n    /**\n     * Get a timestamp formatted with [hh:mm:ss]\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted timestamp\n     */\n\n  }], [{\n    key: \"setWrite\",\n    value: function setWrite(writeTo, opt_logFile) {\n      if (opt_logFile) {\n        logFile = opt_logFile;\n      }\n\n      Logger.writeTo = writeTo;\n\n      if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n        Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n        Logger.firstWrite = false;\n      }\n    }\n  }, {\n    key: \"timestamp_\",\n    value: function timestamp_(writeTo) {\n      var d = new Date();\n      var ts = '[';\n      var hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n      var minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n      var seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n\n      if (writeTo == WriteTo.CONSOLE) {\n        ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n      } else {\n        ts += hours + ':' + minutes + ':' + seconds + ']';\n      }\n\n      ts += ' ';\n      return ts;\n    }\n    /**\n     * Get the identifier of the logger as '/<id>'\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted id\n     */\n\n  }, {\n    key: \"id_\",\n    value: function id_(logLevel, id, writeTo) {\n      var level = LogLevel[logLevel].toString();\n\n      if (writeTo === WriteTo.FILE) {\n        return '/' + id;\n      } else if (logLevel === LogLevel.ERROR) {\n        return printRed('/' + id);\n      } else if (logLevel === LogLevel.WARN) {\n        return printYellow('/' + id);\n      } else {\n        return '/' + id;\n      }\n    }\n    /**\n     * Get the log level formatted with the first letter. For info, it is I.\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted log level\n     */\n\n  }, {\n    key: \"level_\",\n    value: function level_(logLevel, id, writeTo) {\n      var level = LogLevel[logLevel].toString();\n\n      if (writeTo === WriteTo.FILE) {\n        return level[0];\n      } else if (logLevel === LogLevel.ERROR) {\n        return printRed(level[0]);\n      } else if (logLevel === LogLevel.WARN) {\n        return printYellow(level[0]);\n      } else {\n        return level[0];\n      }\n    }\n    /**\n     * Convert the list of messages to a single string message.\n     * @param msgs The list of messages.\n     * @return The string of the formatted messages\n     */\n\n  }, {\n    key: \"msgToFile_\",\n    value: function msgToFile_(msgs) {\n      var log = '';\n\n      for (var pos = 0; pos < msgs.length; pos++) {\n        var msg = msgs[pos];\n        var ret = void 0;\n\n        if (typeof msg === 'object') {\n          ret = JSON.stringify(msg);\n        } else {\n          ret = msg;\n        }\n\n        if (pos !== msgs.length - 1) {\n          ret += ' ';\n        }\n\n        log += ret;\n      }\n\n      return log;\n    }\n  }]);\n\n  return Logger;\n}();\n\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger;","map":{"version":3,"sources":["../../../lib/cli/logger.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n// Will use chalk if chalk is available to add color to console logging\nlet chalk;\nlet printRed;\nlet printYellow;\nlet printGray;\ntry {\n    chalk = require('chalk');\n    printRed = chalk.red;\n    printYellow = chalk.yellow;\n    printGray = chalk.gray;\n}\ncatch (e) {\n    printRed = printYellow = printGray = (msg) => {\n        return msg;\n    };\n}\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\nvar WriteTo;\n(function (WriteTo) {\n    WriteTo[WriteTo[\"CONSOLE\"] = 0] = \"CONSOLE\";\n    WriteTo[WriteTo[\"FILE\"] = 1] = \"FILE\";\n    WriteTo[WriteTo[\"BOTH\"] = 2] = \"BOTH\";\n    WriteTo[WriteTo[\"NONE\"] = 3] = \"NONE\";\n})(WriteTo = exports.WriteTo || (exports.WriteTo = {}));\nlet logFile = 'webdriver.log'; // the default log file name\n/**\n * Logger class adds timestamp output, log levels, and identifiers to help\n * when debugging. Also could write to console, file, both, or none.\n */\nclass Logger {\n    /**\n     * Creates a logger instance with an ID for the logger.\n     * @constructor\n     */\n    constructor(id) {\n        this.id = id;\n    }\n    /**\n     * Set up the write location. If writing to a file, get the file descriptor.\n     * @param writeTo The enum for where to write the logs.\n     * @param opt_logFile An optional parameter to override the log file location.\n     */\n    static setWrite(writeTo, opt_logFile) {\n        if (opt_logFile) {\n            logFile = opt_logFile;\n        }\n        Logger.writeTo = writeTo;\n        if (Logger.writeTo == WriteTo.FILE || Logger.writeTo == WriteTo.BOTH) {\n            Logger.fd = fs.openSync(path.resolve(logFile), 'a');\n            Logger.firstWrite = false;\n        }\n    }\n    /**\n     * Log INFO\n     * @param ...msgs multiple arguments to be logged.\n     */\n    info(...msgs) {\n        this.log_(LogLevel.INFO, msgs);\n    }\n    /**\n     * Log DEBUG\n     * @param ...msgs multiple arguments to be logged.\n     */\n    debug(...msgs) {\n        this.log_(LogLevel.DEBUG, msgs);\n    }\n    /**\n     * Log WARN\n     * @param ...msgs multiple arguments to be logged.\n     */\n    warn(...msgs) {\n        this.log_(LogLevel.WARN, msgs);\n    }\n    /**\n     * Log ERROR\n     * @param ...msgs multiple arguments to be logged.\n     */\n    error(...msgs) {\n        this.log_(LogLevel.ERROR, msgs);\n    }\n    /**\n     * For the log level set, check to see if the messages should be logged.\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged\n     */\n    log_(logLevel, msgs) {\n        switch (Logger.logLevel) {\n            case LogLevel.ERROR:\n                if (logLevel <= LogLevel.ERROR) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.WARN:\n                if (logLevel <= LogLevel.WARN) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.INFO:\n                if (logLevel <= LogLevel.INFO) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            case LogLevel.DEBUG:\n                if (logLevel <= LogLevel.DEBUG) {\n                    this.print_(logLevel, msgs);\n                }\n                break;\n            default:\n                throw new Error('Log level undefined');\n        }\n    }\n    /**\n     * Format with timestamp, log level, identifier, and message and log to\n     * specified medium (console, file, both, none).\n     * @param logLevel The log level of the message.\n     * @param msgs The messages to be logged.\n     */\n    print_(logLevel, msgs) {\n        let consoleLog = '';\n        let fileLog = '';\n        if (Logger.showTimestamp) {\n            consoleLog += Logger.timestamp_(WriteTo.CONSOLE);\n            fileLog += Logger.timestamp_(WriteTo.FILE);\n        }\n        consoleLog += Logger.level_(logLevel, this.id, WriteTo.CONSOLE);\n        fileLog += Logger.level_(logLevel, this.id, WriteTo.FILE);\n        if (Logger.showId) {\n            consoleLog += Logger.id_(logLevel, this.id, WriteTo.CONSOLE);\n            fileLog += Logger.id_(logLevel, this.id, WriteTo.FILE);\n        }\n        consoleLog += ' -';\n        fileLog += ' - ';\n        switch (Logger.writeTo) {\n            case WriteTo.CONSOLE:\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.FILE:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                break;\n            case WriteTo.BOTH:\n                // for the first line written to the file, add a space\n                if (!Logger.firstWrite) {\n                    fs.writeSync(Logger.fd, '\\n');\n                    Logger.firstWrite = true;\n                }\n                fileLog += ' ' + Logger.msgToFile_(msgs);\n                fs.writeSync(Logger.fd, fileLog + '\\n');\n                msgs.unshift(consoleLog);\n                console.log.apply(console, msgs);\n                break;\n            case WriteTo.NONE:\n                break;\n        }\n    }\n    /**\n     * Get a timestamp formatted with [hh:mm:ss]\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted timestamp\n     */\n    static timestamp_(writeTo) {\n        let d = new Date();\n        let ts = '[';\n        let hours = d.getHours() < 10 ? '0' + d.getHours() : d.getHours();\n        let minutes = d.getMinutes() < 10 ? '0' + d.getMinutes() : d.getMinutes();\n        let seconds = d.getSeconds() < 10 ? '0' + d.getSeconds() : d.getSeconds();\n        if (writeTo == WriteTo.CONSOLE) {\n            ts += printGray(hours + ':' + minutes + ':' + seconds) + ']';\n        }\n        else {\n            ts += hours + ':' + minutes + ':' + seconds + ']';\n        }\n        ts += ' ';\n        return ts;\n    }\n    /**\n     * Get the identifier of the logger as '/<id>'\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted id\n     */\n    static id_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return '/' + id;\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed('/' + id);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow('/' + id);\n        }\n        else {\n            return '/' + id;\n        }\n    }\n    /**\n     * Get the log level formatted with the first letter. For info, it is I.\n     * @param logLevel The log level of the message.\n     * @param writeTo The enum for where to write the logs.\n     * @return The string of the formatted log level\n     */\n    static level_(logLevel, id, writeTo) {\n        let level = LogLevel[logLevel].toString();\n        if (writeTo === WriteTo.FILE) {\n            return level[0];\n        }\n        else if (logLevel === LogLevel.ERROR) {\n            return printRed(level[0]);\n        }\n        else if (logLevel === LogLevel.WARN) {\n            return printYellow(level[0]);\n        }\n        else {\n            return level[0];\n        }\n    }\n    /**\n     * Convert the list of messages to a single string message.\n     * @param msgs The list of messages.\n     * @return The string of the formatted messages\n     */\n    static msgToFile_(msgs) {\n        let log = '';\n        for (let pos = 0; pos < msgs.length; pos++) {\n            let msg = msgs[pos];\n            let ret;\n            if (typeof msg === 'object') {\n                ret = JSON.stringify(msg);\n            }\n            else {\n                ret = msg;\n            }\n            if (pos !== msgs.length - 1) {\n                ret += ' ';\n            }\n            log += ret;\n        }\n        return log;\n    }\n}\nLogger.logLevel = LogLevel.INFO;\nLogger.showTimestamp = true;\nLogger.showId = true;\nLogger.writeTo = WriteTo.CONSOLE;\nLogger.firstWrite = false;\nexports.Logger = Logger;\n//# sourceMappingURL=logger.js.map"]},"metadata":{},"sourceType":"script"}