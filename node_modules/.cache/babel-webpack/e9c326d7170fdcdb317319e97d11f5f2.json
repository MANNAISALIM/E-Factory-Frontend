{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Various HTTP utilities.\n */\n'use strict';\n\nvar Executor = require('./index').Executor,\n    HttpClient = require('./index').HttpClient,\n    HttpRequest = require('./index').Request,\n    Command = require('../lib/command').Command,\n    CommandName = require('../lib/command').Name,\n    error = require('../lib/error'),\n    promise = require('../lib/promise');\n/**\n * Queries a WebDriver server for its current status.\n * @param {string} url Base URL of the server to query.\n * @return {!Promise<!Object>} A promise that resolves with\n *     a hash of the server status.\n */\n\n\nfunction getStatus(url) {\n  var client = new HttpClient(url);\n  var executor = new Executor(client);\n  var command = new Command(CommandName.GET_SERVER_STATUS);\n  return executor.execute(command);\n} // PUBLIC API\n\n/**\n * Queries a WebDriver server for its current status.\n * @param {string} url Base URL of the server to query.\n * @return {!Promise<!Object>} A promise that resolves with\n *     a hash of the server status.\n */\n\n\nexports.getStatus = getStatus;\n/**\n * Waits for a WebDriver server to be healthy and accepting requests.\n * @param {string} url Base URL of the server to query.\n * @param {number} timeout How long to wait for the server.\n * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:\n *     if resolved before the server is ready, the wait will be terminated\n *     early with a {@link promise.CancellationError}.\n * @return {!Promise} A promise that will resolve when the server is ready, or\n *     if the wait is cancelled.\n */\n\nexports.waitForServer = function (url, timeout, opt_cancelToken) {\n  return new Promise(function (onResolve, onReject) {\n    var start = Date.now();\n    var done = false;\n\n    var resolve = function resolve(status) {\n      done = true;\n      onResolve(status);\n    };\n\n    var reject = function reject(err) {\n      done = true;\n      onReject(err);\n    };\n\n    if (opt_cancelToken) {\n      opt_cancelToken.then(function (_) {\n        return reject(new promise.CancellationError());\n      });\n    }\n\n    checkServerStatus();\n\n    function checkServerStatus() {\n      return getStatus(url).then(function (status) {\n        return resolve(status);\n      }, onError);\n    }\n\n    function onError(e) {\n      // Some servers don't support the status command. If they are able to\n      // response with an error, then can consider the server ready.\n      if (e instanceof error.UnsupportedOperationError) {\n        resolve({});\n        return;\n      }\n\n      if (Date.now() - start > timeout) {\n        reject(Error('Timed out waiting for the WebDriver server at ' + url));\n      } else {\n        setTimeout(function () {\n          if (!done) {\n            checkServerStatus();\n          }\n        }, 50);\n      }\n    }\n  });\n};\n/**\n * Polls a URL with GET requests until it returns a 2xx response or the\n * timeout expires.\n * @param {string} url The URL to poll.\n * @param {number} timeout How long to wait, in milliseconds.\n * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:\n *     if resolved before the a 2xx response is received, the wait will be\n *     terminated early with a {@link promise.CancellationError}.\n * @return {!Promise} A promise that will resolve when a 2xx is received from\n *     the given URL, or if the wait is cancelled.\n */\n\n\nexports.waitForUrl = function (url, timeout, opt_cancelToken) {\n  return new Promise(function (onResolve, onReject) {\n    var client = new HttpClient(url);\n    var request = new HttpRequest('GET', '');\n    var start = Date.now();\n    var done = false;\n\n    var resolve = function resolve() {\n      done = true;\n      onResolve();\n    };\n\n    var reject = function reject(err) {\n      done = true;\n      onReject(err);\n    };\n\n    if (opt_cancelToken) {\n      opt_cancelToken.then(function (_) {\n        return reject(new promise.CancellationError());\n      });\n    }\n\n    testUrl();\n\n    function testUrl() {\n      client.send(request).then(onResponse, onError);\n    }\n\n    function onError() {\n      if (Date.now() - start > timeout) {\n        reject(Error('Timed out waiting for the URL to return 2xx: ' + url));\n      } else {\n        setTimeout(function () {\n          if (!done) {\n            testUrl();\n          }\n        }, 50);\n      }\n    }\n\n    function onResponse(response) {\n      if (done) {\n        return;\n      }\n\n      if (response.status > 199 && response.status < 300) {\n        resolve();\n        return;\n      }\n\n      onError();\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/selenium-webdriver/http/util.js"],"names":["Executor","require","HttpClient","HttpRequest","Request","Command","CommandName","Name","error","promise","getStatus","url","client","executor","command","GET_SERVER_STATUS","execute","exports","waitForServer","timeout","opt_cancelToken","Promise","onResolve","onReject","start","Date","now","done","resolve","status","reject","err","then","_","CancellationError","checkServerStatus","onError","e","UnsupportedOperationError","Error","setTimeout","waitForUrl","request","testUrl","send","onResponse","response"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Various HTTP utilities.\n */\n\n'use strict';\n\nconst Executor = require('./index').Executor,\n    HttpClient = require('./index').HttpClient,\n    HttpRequest = require('./index').Request,\n    Command = require('../lib/command').Command,\n    CommandName = require('../lib/command').Name,\n    error = require('../lib/error'),\n    promise = require('../lib/promise');\n\n\n\n/**\n * Queries a WebDriver server for its current status.\n * @param {string} url Base URL of the server to query.\n * @return {!Promise<!Object>} A promise that resolves with\n *     a hash of the server status.\n */\nfunction getStatus(url) {\n  var client = new HttpClient(url);\n  var executor = new Executor(client);\n  var command = new Command(CommandName.GET_SERVER_STATUS);\n  return executor.execute(command);\n}\n\n\n// PUBLIC API\n\n\n/**\n * Queries a WebDriver server for its current status.\n * @param {string} url Base URL of the server to query.\n * @return {!Promise<!Object>} A promise that resolves with\n *     a hash of the server status.\n */\nexports.getStatus = getStatus;\n\n\n/**\n * Waits for a WebDriver server to be healthy and accepting requests.\n * @param {string} url Base URL of the server to query.\n * @param {number} timeout How long to wait for the server.\n * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:\n *     if resolved before the server is ready, the wait will be terminated\n *     early with a {@link promise.CancellationError}.\n * @return {!Promise} A promise that will resolve when the server is ready, or\n *     if the wait is cancelled.\n */\nexports.waitForServer = function(url, timeout, opt_cancelToken) {\n  return new Promise((onResolve, onReject) => {\n    let start = Date.now();\n\n    let done = false;\n    let resolve = (status) => {\n      done = true;\n      onResolve(status);\n    };\n    let reject = (err) => {\n      done = true;\n      onReject(err);\n    };\n\n    if (opt_cancelToken) {\n      opt_cancelToken.then(_ => reject(new promise.CancellationError));\n    }\n\n    checkServerStatus();\n    function checkServerStatus() {\n      return getStatus(url).then(status => resolve(status), onError);\n    }\n\n    function onError(e) {\n      // Some servers don't support the status command. If they are able to\n      // response with an error, then can consider the server ready.\n      if (e instanceof error.UnsupportedOperationError) {\n        resolve({});\n        return;\n      }\n\n      if (Date.now() - start > timeout) {\n        reject(Error('Timed out waiting for the WebDriver server at ' + url));\n      } else {\n        setTimeout(function() {\n          if (!done) {\n            checkServerStatus();\n          }\n        }, 50);\n      }\n    }\n  });\n};\n\n\n/**\n * Polls a URL with GET requests until it returns a 2xx response or the\n * timeout expires.\n * @param {string} url The URL to poll.\n * @param {number} timeout How long to wait, in milliseconds.\n * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:\n *     if resolved before the a 2xx response is received, the wait will be\n *     terminated early with a {@link promise.CancellationError}.\n * @return {!Promise} A promise that will resolve when a 2xx is received from\n *     the given URL, or if the wait is cancelled.\n */\nexports.waitForUrl = function(url, timeout, opt_cancelToken) {\n  return new Promise((onResolve, onReject) => {\n    let client = new HttpClient(url);\n    let request = new HttpRequest('GET', '');\n    let start = Date.now();\n\n    let done = false;\n    let resolve = () => {\n      done = true;\n      onResolve();\n    };\n    let reject = (err) => {\n      done = true;\n      onReject(err);\n    };\n\n    if (opt_cancelToken) {\n      opt_cancelToken.then(_ => reject(new promise.CancellationError));\n    }\n\n    testUrl();\n\n    function testUrl() {\n      client.send(request).then(onResponse, onError);\n    }\n\n    function onError() {\n      if (Date.now() - start > timeout) {\n        reject(Error('Timed out waiting for the URL to return 2xx: ' + url));\n      } else {\n        setTimeout(function() {\n          if (!done) {\n            testUrl();\n          }\n        }, 50);\n      }\n    }\n\n    function onResponse(response) {\n      if (done) {\n        return;\n      }\n      if (response.status > 199 && response.status < 300) {\n        resolve();\n        return;\n      }\n      onError();\n    }\n  });\n};\n"]},"metadata":{},"sourceType":"script"}