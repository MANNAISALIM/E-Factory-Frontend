{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar http = require(\"http\");\n\nvar url = require(\"url\");\n\nvar blockingproxy_1 = require(\"./blockingproxy\");\n\nvar BPClient = /*#__PURE__*/function () {\n  function BPClient(bpUrlValue) {\n    _classCallCheck(this, BPClient);\n\n    var bpUrl = url.parse(bpUrlValue);\n    this.hostname = bpUrl.hostname;\n    this.port = parseInt(bpUrl.port);\n  }\n  /**\n   * Toggle whether waiting for Angular is enabled.\n   *\n   * @param enabled Whether or not to enable waiting for angular.\n   * @returns {Promise<T>}\n   */\n\n\n  _createClass(BPClient, [{\n    key: \"setWaitEnabled\",\n    value: function setWaitEnabled(enabled) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var options = {\n          host: _this.hostname,\n          port: _this.port,\n          method: 'POST',\n          path: \"/\".concat(blockingproxy_1.BP_PREFIX, \"/waitEnabled\")\n        };\n        var request = http.request(options, function (response) {\n          response.on('data', function () {});\n          response.on('error', function (err) {\n            return reject(err);\n          });\n          response.on('end', function () {\n            resolve();\n          });\n        });\n        request.write(JSON.stringify({\n          value: enabled\n        }));\n        request.end();\n      });\n    }\n    /**\n     * Set the selector used to find the root element of the Angular application to wait for. See\n     * AngularWaitBarrier for more details.\n     *\n     * @param selector A selector, or empty string to wait for all Angular apps.\n     */\n\n  }, {\n    key: \"setWaitParams\",\n    value: function setWaitParams(rootSelector) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        var options = {\n          host: _this2.hostname,\n          port: _this2.port,\n          method: 'POST',\n          path: \"/\".concat(blockingproxy_1.BP_PREFIX, \"/waitParams\")\n        };\n        var request = http.request(options, function (response) {\n          response.on('data', function () {});\n          response.on('error', function (err) {\n            return reject(err);\n          });\n          response.on('end', function () {\n            resolve();\n          });\n        });\n        request.write(JSON.stringify({\n          rootSelector: rootSelector\n        }));\n        request.end();\n      });\n    }\n  }, {\n    key: \"isWaitEnabled\",\n    value: function isWaitEnabled() {\n      var _this3 = this;\n\n      return new Promise(function (res) {\n        var options = {\n          host: _this3.hostname,\n          port: _this3.port,\n          path: \"/\".concat(blockingproxy_1.BP_PREFIX, \"/waitEnabled\")\n        };\n        http.get(options, function (response) {\n          var body = '';\n          response.on('data', function (data) {\n            body += data;\n          });\n          response.on('end', function () {\n            res(JSON.parse(body).value);\n          });\n        });\n      });\n    }\n  }]);\n\n  return BPClient;\n}();\n\nexports.BPClient = BPClient;","map":{"version":3,"sources":["../../lib/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst blockingproxy_1 = require(\"./blockingproxy\");\nclass BPClient {\n    constructor(bpUrlValue) {\n        let bpUrl = url.parse(bpUrlValue);\n        this.hostname = bpUrl.hostname;\n        this.port = parseInt(bpUrl.port);\n    }\n    /**\n     * Toggle whether waiting for Angular is enabled.\n     *\n     * @param enabled Whether or not to enable waiting for angular.\n     * @returns {Promise<T>}\n     */\n    setWaitEnabled(enabled) {\n        return new Promise((resolve, reject) => {\n            let options = { host: this.hostname, port: this.port, method: 'POST', path: `/${blockingproxy_1.BP_PREFIX}/waitEnabled` };\n            let request = http.request(options, (response) => {\n                response.on('data', () => { });\n                response.on('error', (err) => reject(err));\n                response.on('end', () => {\n                    resolve();\n                });\n            });\n            request.write(JSON.stringify({ value: enabled }));\n            request.end();\n        });\n    }\n    /**\n     * Set the selector used to find the root element of the Angular application to wait for. See\n     * AngularWaitBarrier for more details.\n     *\n     * @param selector A selector, or empty string to wait for all Angular apps.\n     */\n    setWaitParams(rootSelector) {\n        return new Promise((resolve, reject) => {\n            let options = { host: this.hostname, port: this.port, method: 'POST', path: `/${blockingproxy_1.BP_PREFIX}/waitParams` };\n            let request = http.request(options, (response) => {\n                response.on('data', () => { });\n                response.on('error', (err) => reject(err));\n                response.on('end', () => {\n                    resolve();\n                });\n            });\n            request.write(JSON.stringify({ rootSelector: rootSelector }));\n            request.end();\n        });\n    }\n    isWaitEnabled() {\n        return new Promise((res) => {\n            let options = { host: this.hostname, port: this.port, path: `/${blockingproxy_1.BP_PREFIX}/waitEnabled` };\n            http.get(options, (response) => {\n                let body = '';\n                response.on('data', (data) => {\n                    body += data;\n                });\n                response.on('end', () => {\n                    res(JSON.parse(body).value);\n                });\n            });\n        });\n    }\n}\nexports.BPClient = BPClient;\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}