{"ast":null,"code":"/**\n * Copied from Protractor 5.2.0\n *\n * Wait until Angular has finished rendering and has\n * no outstanding $http calls before continuing. The specific Angular app\n * is determined by the rootSelector.\n *\n * Asynchronous.\n *\n * @param {string} rootSelector The selector housing an ng-app\n * @param {function(string)} callback callback. If a failure occurs, it will\n *     be passed as a parameter.\n */\nfunction waitForAngular(rootSelector, callback) {\n  try {\n    // Wait for both angular1 testability and angular2 testability.\n    var testCallback = callback; // Wait for angular1 testability first and run waitForAngular2 as a callback\n\n    var waitForAngular1 = function waitForAngular1(callback) {\n      if (window.angular) {\n        var hooks = getNg1Hooks(rootSelector);\n\n        if (!hooks) {\n          callback(); // not an angular1 app\n        } else {\n          if (hooks.$$testability) {\n            hooks.$$testability.whenStable(callback);\n          } else if (hooks.$injector) {\n            hooks.$injector.get('$browser').notifyWhenNoOutstandingRequests(callback);\n          } else if (!!rootSelector) {\n            throw new Error('Could not automatically find injector on page: \"' + window.location.toString() + '\".  Consider using config.rootEl');\n          } else {\n            throw new Error('root element (' + rootSelector + ') has no injector.' + ' this may mean it is not inside ng-app.');\n          }\n        }\n      } else {\n        callback();\n      } // not an angular1 app\n\n    }; // Wait for Angular2 testability and then run test callback\n\n\n    var waitForAngular2 = function waitForAngular2() {\n      if (window.getAngularTestability) {\n        if (rootSelector) {\n          var testability = null;\n          var el = document.querySelector(rootSelector);\n\n          try {\n            testability = window.getAngularTestability(el);\n          } catch (e) {}\n\n          if (testability) {\n            return testability.whenStable(testCallback);\n          }\n        } // Didn't specify root element or testability could not be found\n        // by rootSelector. This may happen in a hybrid app, which could have\n        // more than one root.\n\n\n        var testabilities = window.getAllAngularTestabilities();\n        var count = testabilities.length; // No angular2 testability, this happens when\n        // going to a hybrid page and going back to a pure angular1 page\n\n        if (count === 0) {\n          return testCallback();\n        }\n\n        var decrement = function decrement() {\n          count--;\n\n          if (count === 0) {\n            testCallback();\n          }\n        };\n\n        testabilities.forEach(function (testability) {\n          testability.whenStable(decrement);\n        });\n      } else {\n        testCallback();\n      } // not an angular2 app\n\n    };\n\n    if (!window.angular && !window.getAngularTestability) {\n      // no testability hook\n      throw new Error('both angularJS testability and angular testability are undefined.' + '  This could be either ' + 'because this is a non-angular page or because your test involves ' + 'client-side navigation, which can interfere with Protractor\\'s ' + 'bootstrapping.  See http://git.io/v4gXM for details');\n    } else {\n      waitForAngular1(waitForAngular2);\n    } // Wait for angular1 and angular2\n    // Testability hooks sequentially\n\n  } catch (err) {\n    callback(err.message);\n  }\n}\n\n;\n/* Tries to find $$testability and possibly $injector for an ng1 app\n *\n * By default, doesn't care about $injector if it finds $$testability.  However,\n * these priorities can be reversed.\n *\n * @param {string=} selector The selector for the element with the injector.  If\n *   falsy, tries a variety of methods to find an injector\n * @param {boolean=} injectorPlease Prioritize finding an injector\n * @return {$$testability?: Testability, $injector?: Injector} Returns whatever\n *   ng1 app hooks it finds\n */\n\nfunction getNg1Hooks(selector, injectorPlease) {\n  function tryEl(el) {\n    try {\n      if (!injectorPlease && angular.getTestability) {\n        var $$testability = angular.getTestability(el);\n\n        if ($$testability) {\n          return {\n            $$testability: $$testability\n          };\n        }\n      } else {\n        var $injector = angular.element(el).injector();\n\n        if ($injector) {\n          return {\n            $injector: $injector\n          };\n        }\n      }\n    } catch (err) {}\n  }\n\n  function trySelector(selector) {\n    var els = document.querySelectorAll(selector);\n\n    for (var i = 0; i < els.length; i++) {\n      var elHooks = tryEl(els[i]);\n\n      if (elHooks) {\n        return elHooks;\n      }\n    }\n  }\n\n  if (selector) {\n    return trySelector(selector);\n  } else if (window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__) {\n    var $injector = window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__;\n    var $$testability = null;\n\n    try {\n      $$testability = $injector.get('$$testability');\n    } catch (e) {}\n\n    return {\n      $injector: $injector,\n      $$testability: $$testability\n    };\n  } else {\n    return tryEl(document.body) || trySelector('[ng-app]') || trySelector('[ng\\\\:app]') || trySelector('[ng-controller]') || trySelector('[ng\\\\:controller]');\n  }\n}\n/* Wraps a function up into a string with its helper functions so that it can\n * call those helper functions client side\n *\n * @param {function} fun The function to wrap up with its helpers\n * @param {...function} The helper functions.  Each function must be named\n *\n * @return {string} The string which, when executed, will invoke fun in such a\n *   way that it has access to its helper functions\n */\n\n\nfunction wrapWithHelpers(fun) {\n  var helpers = Array.prototype.slice.call(arguments, 1);\n\n  if (!helpers.length) {\n    return fun;\n  }\n\n  var FunClass = Function; // Get the linter to allow this eval\n\n  return new FunClass(helpers.join(';') + String.fromCharCode(59) + '  return (' + fun.toString() + ').apply(this, arguments);');\n}\n\nexports.NG_WAIT_FN = wrapWithHelpers(waitForAngular, getNg1Hooks);","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/blocking-proxy/built/lib/client_scripts/wait.js"],"names":["waitForAngular","rootSelector","callback","testCallback","waitForAngular1","window","angular","hooks","getNg1Hooks","$$testability","whenStable","$injector","get","notifyWhenNoOutstandingRequests","Error","location","toString","waitForAngular2","getAngularTestability","testability","el","document","querySelector","e","testabilities","getAllAngularTestabilities","count","length","decrement","forEach","err","message","selector","injectorPlease","tryEl","getTestability","element","injector","trySelector","els","querySelectorAll","i","elHooks","__TESTABILITY__NG1_APP_ROOT_INJECTOR__","body","wrapWithHelpers","fun","helpers","Array","prototype","slice","call","arguments","FunClass","Function","join","String","fromCharCode","exports","NG_WAIT_FN"],"mappings":"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","sourcesContent":["/**\n * Copied from Protractor 5.2.0\n *\n * Wait until Angular has finished rendering and has\n * no outstanding $http calls before continuing. The specific Angular app\n * is determined by the rootSelector.\n *\n * Asynchronous.\n *\n * @param {string} rootSelector The selector housing an ng-app\n * @param {function(string)} callback callback. If a failure occurs, it will\n *     be passed as a parameter.\n */\nfunction waitForAngular(rootSelector, callback) {\n\n    try {\n      // Wait for both angular1 testability and angular2 testability.\n\n      var testCallback = callback;\n\n      // Wait for angular1 testability first and run waitForAngular2 as a callback\n      var waitForAngular1 = function(callback) {\n\n        if (window.angular) {\n          var hooks = getNg1Hooks(rootSelector);\n          if (!hooks){\n            callback();  // not an angular1 app\n          }\n          else{\n            if (hooks.$$testability) {\n              hooks.$$testability.whenStable(callback);\n            } else if (hooks.$injector) {\n              hooks.$injector.get('$browser')\n                  .notifyWhenNoOutstandingRequests(callback);\n            } else if (!!rootSelector) {\n              throw new Error(\n                  'Could not automatically find injector on page: \"' +\n                  window.location.toString() + '\".  Consider using config.rootEl');\n            } else {\n              throw new Error(\n                  'root element (' + rootSelector + ') has no injector.' +\n                  ' this may mean it is not inside ng-app.');\n            }\n          }\n        }\n        else {callback();}  // not an angular1 app\n      };\n\n      // Wait for Angular2 testability and then run test callback\n      var waitForAngular2 = function() {\n        if (window.getAngularTestability) {\n          if (rootSelector) {\n            var testability = null;\n            var el = document.querySelector(rootSelector);\n            try{\n              testability = window.getAngularTestability(el);\n            }\n            catch(e){}\n            if (testability) {\n              return testability.whenStable(testCallback);\n            }\n          }\n\n          // Didn't specify root element or testability could not be found\n          // by rootSelector. This may happen in a hybrid app, which could have\n          // more than one root.\n          var testabilities = window.getAllAngularTestabilities();\n          var count = testabilities.length;\n\n          // No angular2 testability, this happens when\n          // going to a hybrid page and going back to a pure angular1 page\n          if (count === 0) {\n            return testCallback();\n          }\n\n          var decrement = function() {\n            count--;\n            if (count === 0) {\n              testCallback();\n            }\n          };\n          testabilities.forEach(function(testability) {\n            testability.whenStable(decrement);\n          });\n\n        }\n        else {testCallback();}  // not an angular2 app\n      };\n\n      if (!(window.angular) && !(window.getAngularTestability)) {\n        // no testability hook\n        throw new Error(\n            'both angularJS testability and angular testability are undefined.' +\n            '  This could be either ' +\n            'because this is a non-angular page or because your test involves ' +\n            'client-side navigation, which can interfere with Protractor\\'s ' +\n            'bootstrapping.  See http://git.io/v4gXM for details');\n      } else {waitForAngular1(waitForAngular2);}  // Wait for angular1 and angular2\n                                                  // Testability hooks sequentially\n\n    } catch (err) {\n      callback(err.message);\n    }\n\n  };\n\n/* Tries to find $$testability and possibly $injector for an ng1 app\n *\n * By default, doesn't care about $injector if it finds $$testability.  However,\n * these priorities can be reversed.\n *\n * @param {string=} selector The selector for the element with the injector.  If\n *   falsy, tries a variety of methods to find an injector\n * @param {boolean=} injectorPlease Prioritize finding an injector\n * @return {$$testability?: Testability, $injector?: Injector} Returns whatever\n *   ng1 app hooks it finds\n */\nfunction getNg1Hooks(selector, injectorPlease) {\n  function tryEl(el) {\n    try {\n      if (!injectorPlease && angular.getTestability) {\n        var $$testability = angular.getTestability(el);\n        if ($$testability) {\n          return {$$testability: $$testability};\n        }\n      } else {\n        var $injector = angular.element(el).injector();\n        if ($injector) {\n          return {$injector: $injector};\n        }\n      }\n    } catch(err) {}\n  }\n  function trySelector(selector) {\n    var els = document.querySelectorAll(selector);\n    for (var i = 0; i < els.length; i++) {\n      var elHooks = tryEl(els[i]);\n      if (elHooks) {\n        return elHooks;\n      }\n    }\n  }\n\n  if (selector) {\n    return trySelector(selector);\n  } else if (window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__) {\n    var $injector = window.__TESTABILITY__NG1_APP_ROOT_INJECTOR__;\n    var $$testability = null;\n    try {\n      $$testability = $injector.get('$$testability');\n    } catch (e) {}\n    return {$injector: $injector, $$testability: $$testability};\n  } else {\n    return tryEl(document.body) ||\n        trySelector('[ng-app]') || trySelector('[ng\\\\:app]') ||\n        trySelector('[ng-controller]') || trySelector('[ng\\\\:controller]');\n  }\n}\n\n/* Wraps a function up into a string with its helper functions so that it can\n * call those helper functions client side\n *\n * @param {function} fun The function to wrap up with its helpers\n * @param {...function} The helper functions.  Each function must be named\n *\n * @return {string} The string which, when executed, will invoke fun in such a\n *   way that it has access to its helper functions\n */\nfunction wrapWithHelpers(fun) {\n  var helpers = Array.prototype.slice.call(arguments, 1);\n  if (!helpers.length) {\n    return fun;\n  }\n  var FunClass = Function; // Get the linter to allow this eval\n  return new FunClass(\n      helpers.join(';') + String.fromCharCode(59) +\n      '  return (' + fun.toString() + ').apply(this, arguments);');\n}\n\nexports.NG_WAIT_FN = wrapWithHelpers(waitForAngular, getNg1Hooks);\n"]},"metadata":{},"sourceType":"script"}