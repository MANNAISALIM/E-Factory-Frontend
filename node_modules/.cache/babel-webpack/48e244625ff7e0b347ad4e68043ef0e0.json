{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nvar os = require('os');\n\nfunction getLoInterface() {\n  var name;\n\n  if (process.platform === 'darwin') {\n    name = 'lo0';\n  } else if (process.platform === 'linux') {\n    name = 'lo';\n  }\n\n  return name ? os.networkInterfaces()[name] : null;\n}\n/**\n * Queries the system network interfaces for an IP address.\n * @param {boolean} loopback Whether to find a loopback address.\n * @param {string=} opt_family The IP family (IPv4 or IPv6). Defaults to IPv4.\n * @return {string} The located IP address or undefined.\n */\n\n\nfunction getAddress(loopback, opt_family) {\n  var family = opt_family || 'IPv4';\n  var addresses = [];\n  var interfaces;\n\n  if (loopback) {\n    var lo = getLoInterface();\n    interfaces = lo ? [lo] : null;\n  }\n\n  interfaces = interfaces || os.networkInterfaces();\n\n  for (var key in interfaces) {\n    if (!interfaces.hasOwnProperty(key)) {\n      continue;\n    }\n\n    interfaces[key].forEach(function (ipAddress) {\n      if (ipAddress.family === family && ipAddress.internal === loopback) {\n        addresses.push(ipAddress.address);\n      }\n    });\n  }\n\n  return addresses[0];\n} // PUBLIC API\n\n/**\n * Retrieves the external IP address for this host.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\n\n\nexports.getAddress = function (opt_family) {\n  return getAddress(false, opt_family);\n};\n/**\n * Retrieves a loopback address for this machine.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\n\n\nexports.getLoopbackAddress = function (opt_family) {\n  return getAddress(true, opt_family);\n};\n/**\n * Splits a hostport string, e.g. \"www.example.com:80\", into its component\n * parts.\n *\n * @param {string} hostport The string to split.\n * @return {{host: string, port: ?number}} A host and port. If no port is\n *     present in the argument `hostport`, port is null.\n */\n\n\nexports.splitHostAndPort = function (hostport) {\n  var lastIndex = hostport.lastIndexOf(':');\n\n  if (lastIndex < 0) {\n    return {\n      host: hostport,\n      port: null\n    };\n  }\n\n  var firstIndex = hostport.indexOf(':');\n\n  if (firstIndex != lastIndex && !hostport.includes('[')) {\n    // Multiple colons but no brackets, so assume the string is an IPv6 address\n    // with no port (e.g. \"1234:5678:9:0:1234:5678:9:0\").\n    return {\n      host: hostport,\n      port: null\n    };\n  }\n\n  var host = hostport.slice(0, lastIndex);\n\n  if (host.startsWith('[') && host.endsWith(']')) {\n    host = host.slice(1, -1);\n  }\n\n  var port = parseInt(hostport.slice(lastIndex + 1), 10);\n  return {\n    host: host,\n    port: port\n  };\n};","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/selenium-webdriver/net/index.js"],"names":["os","require","getLoInterface","name","process","platform","networkInterfaces","getAddress","loopback","opt_family","family","addresses","interfaces","lo","key","hasOwnProperty","forEach","ipAddress","internal","push","address","exports","getLoopbackAddress","splitHostAndPort","hostport","lastIndex","lastIndexOf","host","port","firstIndex","indexOf","includes","slice","startsWith","endsWith","parseInt"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\nvar os = require('os');\n\n\nfunction getLoInterface() {\n  var name;\n  if (process.platform === 'darwin') {\n    name = 'lo0';\n  } else if (process.platform === 'linux') {\n    name = 'lo';\n  }\n  return name ? os.networkInterfaces()[name] : null;\n}\n\n\n/**\n * Queries the system network interfaces for an IP address.\n * @param {boolean} loopback Whether to find a loopback address.\n * @param {string=} opt_family The IP family (IPv4 or IPv6). Defaults to IPv4.\n * @return {string} The located IP address or undefined.\n */\nfunction getAddress(loopback, opt_family) {\n  var family = opt_family || 'IPv4';\n  var addresses = [];\n\n  var interfaces;\n  if (loopback) {\n    var lo = getLoInterface();\n    interfaces = lo ? [lo] : null;\n  }\n  interfaces = interfaces || os.networkInterfaces();\n  for (var key in interfaces) {\n    if (!interfaces.hasOwnProperty(key)) {\n      continue;\n    }\n\n    interfaces[key].forEach(function(ipAddress) {\n      if (ipAddress.family === family &&\n          ipAddress.internal === loopback) {\n        addresses.push(ipAddress.address);\n      }\n    });\n  }\n  return addresses[0];\n}\n\n\n// PUBLIC API\n\n\n/**\n * Retrieves the external IP address for this host.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\nexports.getAddress = function(opt_family) {\n  return getAddress(false, opt_family);\n};\n\n\n/**\n * Retrieves a loopback address for this machine.\n * @param {string=} opt_family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {string} The IP address or undefined if not available.\n */\nexports.getLoopbackAddress = function(opt_family) {\n  return getAddress(true, opt_family);\n};\n\n\n/**\n * Splits a hostport string, e.g. \"www.example.com:80\", into its component\n * parts.\n *\n * @param {string} hostport The string to split.\n * @return {{host: string, port: ?number}} A host and port. If no port is\n *     present in the argument `hostport`, port is null.\n */\nexports.splitHostAndPort = function(hostport) {\n  let lastIndex = hostport.lastIndexOf(':');\n  if (lastIndex < 0) {\n    return {host: hostport, port: null};\n  }\n\n  let firstIndex = hostport.indexOf(':');\n  if (firstIndex != lastIndex && !hostport.includes('[')) {\n    // Multiple colons but no brackets, so assume the string is an IPv6 address\n    // with no port (e.g. \"1234:5678:9:0:1234:5678:9:0\").\n    return {host: hostport, port: null};\n  }\n\n  let host = hostport.slice(0, lastIndex);\n  if (host.startsWith('[') && host.endsWith(']')) {\n    host = host.slice(1, -1);\n  }\n\n  let port = parseInt(hostport.slice(lastIndex + 1), 10);\n  return {host, port};\n};\n"]},"metadata":{},"sourceType":"script"}