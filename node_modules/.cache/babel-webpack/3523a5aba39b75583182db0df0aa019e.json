{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar jszip = require('jszip');\n\nvar path = require('path');\n\nvar io = require('./index');\n\nvar _require = require('../lib/error'),\n    InvalidArgumentError = _require.InvalidArgumentError;\n/**\n * Manages a zip archive.\n */\n\n\nvar Zip = /*#__PURE__*/function () {\n  function Zip() {\n    _classCallCheck(this, Zip);\n\n    /** @private @const */\n    this.z_ = new jszip();\n    /** @private @const {!Set<!Promise<?>>} */\n\n    this.pendingAdds_ = new Set();\n  }\n  /**\n   * Adds a file to this zip.\n   *\n   * @param {string} filePath path to the file to add.\n   * @param {string=} zipPath path to the file in the zip archive, defaults\n   *     to the basename of `filePath`.\n   * @return {!Promise<?>} a promise that will resolve when added.\n   */\n\n\n  _createClass(Zip, [{\n    key: \"addFile\",\n    value: function addFile(filePath) {\n      var _this = this;\n\n      var zipPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : path.basename(filePath);\n      var add = io.read(filePath).then(function (buffer) {\n        return _this.z_.file(\n        /** @type {string} */\n        zipPath, buffer);\n      });\n      this.pendingAdds_.add(add);\n      return add.then(function () {\n        return _this.pendingAdds_.delete(add);\n      }, function (e) {\n        _this.pendingAdds_.delete(add);\n\n        throw e;\n      });\n    }\n    /**\n     * Recursively adds a directory and all of its contents to this archive.\n     *\n     * @param {string} dirPath path to the directory to add.\n     * @param {string=} zipPath path to the folder in the archive to add the\n     *     directory contents to. Defaults to the root folder.\n     * @return {!Promise<?>} returns a promise that will resolve when the\n     *     the operation is complete.\n     */\n\n  }, {\n    key: \"addDir\",\n    value: function addDir(dirPath) {\n      var _this2 = this;\n\n      var zipPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      return io.walkDir(dirPath).then(function (entries) {\n        var archive = _this2.z_;\n\n        if (zipPath) {\n          archive = archive.folder(zipPath);\n        }\n\n        var files = [];\n        entries.forEach(function (spec) {\n          if (spec.dir) {\n            archive.folder(spec.path);\n          } else {\n            files.push(_this2.addFile(path.join(dirPath, spec.path), path.join(zipPath, spec.path)));\n          }\n        });\n        return Promise.all(files);\n      });\n    }\n    /**\n     * @param {string} path File path to test for within the archive.\n     * @return {boolean} Whether this zip archive contains an entry with the given\n     *     path.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(path) {\n      return this.z_.file(path) !== null;\n    }\n    /**\n     * Returns the contents of the file in this zip archive with the given `path`.\n     * The returned promise will be rejected with an {@link InvalidArgumentError}\n     * if either `path` does not exist within the archive, or if `path` refers\n     * to a directory.\n     *\n     * @param {string} path the path to the file whose contents to return.\n     * @return {!Promise<!Buffer>} a promise that will be resolved with the file's\n     *     contents as a buffer.\n     */\n\n  }, {\n    key: \"getFile\",\n    value: function getFile(path) {\n      var file = this.z_.file(path);\n\n      if (!file) {\n        return Promise.reject(new InvalidArgumentError(\"No such file in zip archive: \".concat(path)));\n      }\n\n      if (file.dir) {\n        return Promise.reject(new InvalidArgumentError(\"The requested file is a directory: \".concat(path)));\n      }\n\n      return Promise.resolve(file.async('nodebuffer'));\n    }\n    /**\n     * Returns the compressed data for this archive in a buffer. _This method will\n     * not wait for any outstanding {@link #addFile add}\n     * {@link #addDir operations} before encoding the archive._\n     *\n     * @param {string} compression The desired compression.\n     *     Must be `STORE` (the default) or `DEFLATE`.\n     * @return {!Promise<!Buffer>} a promise that will resolve with this archive\n     *     as a buffer.\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      var compression = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'STORE';\n\n      if (compression !== 'STORE' && compression !== 'DEFLATE') {\n        return Promise.reject(new InvalidArgumentError(\"compression must be one of {STORE, DEFLATE}, got \".concat(compression)));\n      }\n\n      return Promise.resolve(this.z_.generateAsync({\n        compression: compression,\n        type: 'nodebuffer'\n      }));\n    }\n  }]);\n\n  return Zip;\n}();\n/**\n * Asynchronously opens a zip archive.\n *\n * @param {string} path to the zip archive to load.\n * @return {!Promise<!Zip>} a promise that will resolve with the opened\n *     archive.\n */\n\n\nfunction load(path) {\n  return io.read(path).then(function (data) {\n    var zip = new Zip();\n    return zip.z_.loadAsync(data).then(function () {\n      return zip;\n    });\n  });\n}\n/**\n * Asynchronously unzips an archive file.\n *\n * @param {string} src path to the source file to unzip.\n * @param {string} dst path to the destination directory.\n * @return {!Promise<string>} a promise that will resolve with `dst` once the\n *     archive has been unzipped.\n */\n\n\nfunction unzip(src, dst) {\n  return load(src).then(function (zip) {\n    var promisedDirs = new Map();\n    var promises = [];\n    zip.z_.forEach(function (relPath, file) {\n      var p;\n\n      if (file.dir) {\n        p = createDir(relPath);\n      } else {\n        var dirname = path.dirname(relPath);\n\n        if (dirname === '.') {\n          p = writeFile(relPath, file);\n        } else {\n          p = createDir(dirname).then(function () {\n            return writeFile(relPath, file);\n          });\n        }\n      }\n\n      promises.push(p);\n    });\n    return Promise.all(promises).then(function () {\n      return dst;\n    });\n\n    function createDir(dir) {\n      var p = promisedDirs.get(dir);\n\n      if (!p) {\n        p = io.mkdirp(path.join(dst, dir));\n        promisedDirs.set(dir, p);\n      }\n\n      return p;\n    }\n\n    function writeFile(relPath, file) {\n      return file.async('nodebuffer').then(function (buffer) {\n        return io.write(path.join(dst, relPath), buffer);\n      });\n    }\n  });\n} // PUBLIC API\n\n\nexports.Zip = Zip;\nexports.load = load;\nexports.unzip = unzip;","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/selenium-webdriver/io/zip.js"],"names":["jszip","require","path","io","InvalidArgumentError","Zip","z_","pendingAdds_","Set","filePath","zipPath","basename","add","read","then","buffer","file","delete","e","dirPath","walkDir","entries","archive","folder","files","forEach","spec","dir","push","addFile","join","Promise","all","reject","resolve","async","compression","generateAsync","type","load","data","zip","loadAsync","unzip","src","dst","promisedDirs","Map","promises","relPath","p","createDir","dirname","writeFile","get","mkdirp","set","write","exports"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\nconst jszip = require('jszip');\nconst path = require('path');\n\nconst io = require('./index');\nconst {InvalidArgumentError} = require('../lib/error');\n\n/**\n * Manages a zip archive.\n */\nclass Zip {\n  constructor() {\n    /** @private @const */\n    this.z_ = new jszip;\n\n    /** @private @const {!Set<!Promise<?>>} */\n    this.pendingAdds_ = new Set;\n  }\n\n  /**\n   * Adds a file to this zip.\n   *\n   * @param {string} filePath path to the file to add.\n   * @param {string=} zipPath path to the file in the zip archive, defaults\n   *     to the basename of `filePath`.\n   * @return {!Promise<?>} a promise that will resolve when added.\n   */\n  addFile(filePath, zipPath = path.basename(filePath)) {\n    let add = io.read(filePath)\n        .then(buffer => this.z_.file(/** @type {string} */(zipPath), buffer));\n    this.pendingAdds_.add(add);\n    return add.then(\n        () => this.pendingAdds_.delete(add),\n        (e) => {\n          this.pendingAdds_.delete(add);\n          throw e;\n        });\n  }\n\n  /**\n   * Recursively adds a directory and all of its contents to this archive.\n   *\n   * @param {string} dirPath path to the directory to add.\n   * @param {string=} zipPath path to the folder in the archive to add the\n   *     directory contents to. Defaults to the root folder.\n   * @return {!Promise<?>} returns a promise that will resolve when the\n   *     the operation is complete.\n   */\n  addDir(dirPath, zipPath = '') {\n    return io.walkDir(dirPath).then(entries => {\n      let archive = this.z_;\n      if (zipPath) {\n        archive = archive.folder(zipPath);\n      }\n\n      let files = [];\n      entries.forEach(spec => {\n        if (spec.dir) {\n          archive.folder(spec.path);\n        } else {\n          files.push(\n              this.addFile(\n                  path.join(dirPath, spec.path),\n                  path.join(zipPath, spec.path)));\n        }\n      });\n\n      return Promise.all(files);\n    });\n  }\n\n  /**\n   * @param {string} path File path to test for within the archive.\n   * @return {boolean} Whether this zip archive contains an entry with the given\n   *     path.\n   */\n  has(path) {\n    return this.z_.file(path) !== null;\n  }\n\n  /**\n   * Returns the contents of the file in this zip archive with the given `path`.\n   * The returned promise will be rejected with an {@link InvalidArgumentError}\n   * if either `path` does not exist within the archive, or if `path` refers\n   * to a directory.\n   *\n   * @param {string} path the path to the file whose contents to return.\n   * @return {!Promise<!Buffer>} a promise that will be resolved with the file's\n   *     contents as a buffer.\n   */\n  getFile(path) {\n    let file = this.z_.file(path);\n    if (!file) {\n      return Promise.reject(\n          new InvalidArgumentError(`No such file in zip archive: ${path}`));\n    }\n\n    if (file.dir) {\n      return Promise.reject(\n          new InvalidArgumentError(\n              `The requested file is a directory: ${path}`));\n    }\n\n    return Promise.resolve(file.async('nodebuffer'));\n  }\n\n  /**\n   * Returns the compressed data for this archive in a buffer. _This method will\n   * not wait for any outstanding {@link #addFile add}\n   * {@link #addDir operations} before encoding the archive._\n   *\n   * @param {string} compression The desired compression.\n   *     Must be `STORE` (the default) or `DEFLATE`.\n   * @return {!Promise<!Buffer>} a promise that will resolve with this archive\n   *     as a buffer.\n   */\n  toBuffer(compression = 'STORE') {\n    if (compression !== 'STORE' && compression !== 'DEFLATE') {\n      return Promise.reject(\n          new InvalidArgumentError(\n              `compression must be one of {STORE, DEFLATE}, got ${compression}`));\n    }\n    return Promise.resolve(\n        this.z_.generateAsync({compression, type: 'nodebuffer'}));\n  }\n}\n\n\n/**\n * Asynchronously opens a zip archive.\n *\n * @param {string} path to the zip archive to load.\n * @return {!Promise<!Zip>} a promise that will resolve with the opened\n *     archive.\n */\nfunction load(path) {\n  return io.read(path).then(data => {\n    let zip = new Zip;\n    return zip.z_.loadAsync(data).then(() => zip);\n  });\n}\n\n\n/**\n * Asynchronously unzips an archive file.\n *\n * @param {string} src path to the source file to unzip.\n * @param {string} dst path to the destination directory.\n * @return {!Promise<string>} a promise that will resolve with `dst` once the\n *     archive has been unzipped.\n */\nfunction unzip(src, dst) {\n  return load(src).then(zip => {\n    let promisedDirs = new Map;\n    let promises = [];\n\n    zip.z_.forEach((relPath, file) => {\n      let p;\n      if (file.dir) {\n        p = createDir(relPath);\n      } else {\n        let dirname = path.dirname(relPath);\n        if (dirname === '.') {\n          p = writeFile(relPath, file);\n        } else {\n          p = createDir(dirname).then(() => writeFile(relPath, file));\n        }\n      }\n      promises.push(p);\n    });\n\n    return Promise.all(promises).then(() => dst);\n\n    function createDir(dir) {\n      let p = promisedDirs.get(dir);\n      if (!p) {\n        p = io.mkdirp(path.join(dst, dir));\n        promisedDirs.set(dir, p);\n      }\n      return p;\n    }\n\n    function writeFile(relPath, file) {\n      return file.async('nodebuffer')\n          .then(buffer => io.write(path.join(dst, relPath), buffer));\n    }\n  });\n}\n\n\n// PUBLIC API\n\n\nexports.Zip = Zip;\nexports.load = load;\nexports.unzip = unzip;\n"]},"metadata":{},"sourceType":"script"}