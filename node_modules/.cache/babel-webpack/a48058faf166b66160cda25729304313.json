{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar glob = require(\"glob\");\n\nvar path = require(\"path\");\n\nvar exitCodes_1 = require(\"./exitCodes\");\n\nvar logger_1 = require(\"./logger\");\n\nvar logger = new logger_1.Logger('configParser'); // Coffee is required here to enable config files written in coffee-script.\n\ntry {\n  require('coffee-script').register();\n} catch (e) {// Intentionally blank - ignore if coffee-script is not available.\n} // CoffeeScript lost the hyphen in the module name a long time ago, all new version are named this:\n\n\ntry {\n  require('coffeescript').register();\n} catch (e) {// Intentionally blank - ignore if coffeescript is not available.\n} // LiveScript is required here to enable config files written in LiveScript.\n\n\ntry {\n  require('LiveScript');\n} catch (e) {// Intentionally blank - ignore if LiveScript is not available.\n}\n\nvar ConfigParser = /*#__PURE__*/function () {\n  function ConfigParser() {\n    _classCallCheck(this, ConfigParser);\n\n    // Default configuration.\n    this.config_ = {\n      specs: [],\n      multiCapabilities: [],\n      verboseMultiSessions: false,\n      rootElement: '',\n      allScriptsTimeout: 11000,\n      getPageTimeout: 10000,\n      params: {},\n      framework: 'jasmine',\n      jasmineNodeOpts: {\n        showColors: true,\n        defaultTimeoutInterval: 30 * 1000\n      },\n      seleniumArgs: [],\n      mochaOpts: {\n        ui: 'bdd',\n        reporter: 'list'\n      },\n      configDir: './',\n      noGlobals: false,\n      plugins: [],\n      skipSourceMapSupport: false,\n      ng12Hybrid: false\n    };\n  }\n  /**\n   * Resolve a list of file patterns into a list of individual file paths.\n   *\n   * @param {Array.<string> | string} patterns\n   * @param {=boolean} opt_omitWarnings Whether to omit did not match warnings\n   * @param {=string} opt_relativeTo Path to resolve patterns against\n   *\n   * @return {Array} The resolved file paths.\n   */\n\n\n  _createClass(ConfigParser, [{\n    key: \"addConfig_\",\n\n    /**\n     * Add the options in the parameter config to this runner instance.\n     *\n     * @private\n     * @param {Object} additionalConfig\n     * @param {string} relativeTo the file path to resolve paths against\n     */\n    value: function addConfig_(additionalConfig, relativeTo) {\n      // All filepaths should be kept relative to the current config location.\n      // This will not affect absolute paths.\n      ['seleniumServerJar', 'chromeDriver', 'firefoxPath', 'frameworkPath', 'geckoDriver', 'onPrepare'].forEach(function (name) {\n        if (additionalConfig[name] && typeof additionalConfig[name] === 'string') {\n          additionalConfig[name] = path.resolve(relativeTo, additionalConfig[name]);\n        }\n      });\n      merge_(this.config_, additionalConfig);\n    }\n    /**\n     * Public function specialized towards merging in a file's config\n     *\n     * @public\n     * @param {String} filename\n     */\n\n  }, {\n    key: \"addFileConfig\",\n    value: function addFileConfig(filename) {\n      if (!filename) {\n        return this;\n      }\n\n      var filePath = path.resolve(process.cwd(), filename);\n      var fileConfig;\n\n      try {\n        fileConfig = require(filePath).config;\n      } catch (e) {\n        throw new exitCodes_1.ConfigError(logger, 'failed loading configuration file ' + filename, e);\n      }\n\n      if (!fileConfig) {\n        throw new exitCodes_1.ConfigError(logger, 'configuration file ' + filename + ' did not export a config object');\n      }\n\n      fileConfig.configDir = path.dirname(filePath);\n      this.addConfig_(fileConfig, fileConfig.configDir);\n      return this;\n    }\n    /**\n     * Public function specialized towards merging in config from argv\n     *\n     * @public\n     * @param {Object} argv\n     */\n\n  }, {\n    key: \"addConfig\",\n    value: function addConfig(argv) {\n      this.addConfig_(argv, process.cwd());\n      return this;\n    }\n    /**\n     * Public getter for the final, computed config object\n     *\n     * @public\n     * @return {Object} config\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.config_;\n    }\n  }], [{\n    key: \"resolveFilePatterns\",\n    value: function resolveFilePatterns(patterns, opt_omitWarnings, opt_relativeTo) {\n      var resolvedFiles = [];\n      var cwd = opt_relativeTo || process.cwd();\n      patterns = typeof patterns === 'string' ? [patterns] : patterns;\n\n      if (patterns) {\n        var _iterator = _createForOfIteratorHelper(patterns),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var fileName = _step.value;\n            var matches = glob.hasMagic(fileName) ? glob.sync(fileName, {\n              cwd: cwd\n            }) : [fileName];\n\n            if (!matches.length && !opt_omitWarnings) {\n              logger.warn('pattern ' + fileName + ' did not match any files.');\n            }\n\n            var _iterator2 = _createForOfIteratorHelper(matches),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var match = _step2.value;\n                var resolvedPath = path.resolve(cwd, match);\n                resolvedFiles.push(resolvedPath);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return resolvedFiles;\n    }\n    /**\n     * Returns only the specs that should run currently based on `config.suite`\n     *\n     * @return {Array} An array of globs locating the spec files\n     */\n\n  }, {\n    key: \"getSpecs\",\n    value: function getSpecs(config) {\n      var specs = [];\n\n      if (config.suite) {\n        config.suite.split(',').forEach(function (suite) {\n          var suiteList = config.suites ? config.suites[suite] : null;\n\n          if (suiteList == null) {\n            throw new exitCodes_1.ConfigError(logger, 'Unknown test suite: ' + suite);\n          }\n\n          union(specs, makeArray(suiteList));\n        });\n        return specs;\n      }\n\n      if (config.specs.length > 0) {\n        return config.specs;\n      }\n\n      Object.keys(config.suites || {}).forEach(function (suite) {\n        union(specs, makeArray(config.suites[suite]));\n      });\n      return specs;\n    }\n  }]);\n\n  return ConfigParser;\n}();\n\nexports.ConfigParser = ConfigParser;\n/**\n * Merge config objects together.\n *\n * @private\n * @param {Object} into\n * @param {Object} from\n *\n * @return {Object} The 'into' config.\n */\n\nvar merge_ = function merge_(into, from) {\n  for (var key in from) {\n    if (into[key] instanceof Object && !(into[key] instanceof Array) && !(into[key] instanceof Function)) {\n      merge_(into[key], from[key]);\n    } else {\n      into[key] = from[key];\n    }\n  }\n\n  return into;\n};\n/**\n * Returns the item if it's an array or puts the item in an array\n * if it was not one already.\n */\n\n\nvar makeArray = function makeArray(item) {\n  return Array.isArray(item) ? item : [item];\n};\n/**\n * Adds to an array all the elements in another array without adding any\n * duplicates\n *\n * @param {string[]} dest The array to add to\n * @param {string[]} src The array to copy from\n */\n\n\nvar union = function union(dest, src) {\n  var elems = {};\n\n  for (var key in dest) {\n    elems[dest[key]] = true;\n  }\n\n  for (var _key in src) {\n    if (!elems[src[_key]]) {\n      dest.push(src[_key]);\n      elems[src[_key]] = true;\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/protractor/built/configParser.js"],"names":["Object","defineProperty","exports","value","glob","require","path","exitCodes_1","logger_1","logger","Logger","register","e","ConfigParser","config_","specs","multiCapabilities","verboseMultiSessions","rootElement","allScriptsTimeout","getPageTimeout","params","framework","jasmineNodeOpts","showColors","defaultTimeoutInterval","seleniumArgs","mochaOpts","ui","reporter","configDir","noGlobals","plugins","skipSourceMapSupport","ng12Hybrid","additionalConfig","relativeTo","forEach","name","resolve","merge_","filename","filePath","process","cwd","fileConfig","config","ConfigError","dirname","addConfig_","argv","patterns","opt_omitWarnings","opt_relativeTo","resolvedFiles","fileName","matches","hasMagic","sync","length","warn","match","resolvedPath","push","suite","split","suiteList","suites","union","makeArray","keys","into","from","key","Array","Function","item","isArray","dest","src","elems"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst glob = require(\"glob\");\nconst path = require(\"path\");\nconst exitCodes_1 = require(\"./exitCodes\");\nconst logger_1 = require(\"./logger\");\nlet logger = new logger_1.Logger('configParser');\n// Coffee is required here to enable config files written in coffee-script.\ntry {\n    require('coffee-script').register();\n}\ncatch (e) {\n    // Intentionally blank - ignore if coffee-script is not available.\n}\n// CoffeeScript lost the hyphen in the module name a long time ago, all new version are named this:\ntry {\n    require('coffeescript').register();\n}\ncatch (e) {\n    // Intentionally blank - ignore if coffeescript is not available.\n}\n// LiveScript is required here to enable config files written in LiveScript.\ntry {\n    require('LiveScript');\n}\ncatch (e) {\n    // Intentionally blank - ignore if LiveScript is not available.\n}\nclass ConfigParser {\n    constructor() {\n        // Default configuration.\n        this.config_ = {\n            specs: [],\n            multiCapabilities: [],\n            verboseMultiSessions: false,\n            rootElement: '',\n            allScriptsTimeout: 11000,\n            getPageTimeout: 10000,\n            params: {},\n            framework: 'jasmine',\n            jasmineNodeOpts: { showColors: true, defaultTimeoutInterval: (30 * 1000) },\n            seleniumArgs: [],\n            mochaOpts: { ui: 'bdd', reporter: 'list' },\n            configDir: './',\n            noGlobals: false,\n            plugins: [],\n            skipSourceMapSupport: false,\n            ng12Hybrid: false\n        };\n    }\n    /**\n     * Resolve a list of file patterns into a list of individual file paths.\n     *\n     * @param {Array.<string> | string} patterns\n     * @param {=boolean} opt_omitWarnings Whether to omit did not match warnings\n     * @param {=string} opt_relativeTo Path to resolve patterns against\n     *\n     * @return {Array} The resolved file paths.\n     */\n    static resolveFilePatterns(patterns, opt_omitWarnings, opt_relativeTo) {\n        let resolvedFiles = [];\n        let cwd = opt_relativeTo || process.cwd();\n        patterns = (typeof patterns === 'string') ? [patterns] : patterns;\n        if (patterns) {\n            for (let fileName of patterns) {\n                let matches = glob.hasMagic(fileName) ? glob.sync(fileName, { cwd }) : [fileName];\n                if (!matches.length && !opt_omitWarnings) {\n                    logger.warn('pattern ' + fileName + ' did not match any files.');\n                }\n                for (let match of matches) {\n                    let resolvedPath = path.resolve(cwd, match);\n                    resolvedFiles.push(resolvedPath);\n                }\n            }\n        }\n        return resolvedFiles;\n    }\n    /**\n     * Returns only the specs that should run currently based on `config.suite`\n     *\n     * @return {Array} An array of globs locating the spec files\n     */\n    static getSpecs(config) {\n        let specs = [];\n        if (config.suite) {\n            config.suite.split(',').forEach((suite) => {\n                let suiteList = config.suites ? config.suites[suite] : null;\n                if (suiteList == null) {\n                    throw new exitCodes_1.ConfigError(logger, 'Unknown test suite: ' + suite);\n                }\n                union(specs, makeArray(suiteList));\n            });\n            return specs;\n        }\n        if (config.specs.length > 0) {\n            return config.specs;\n        }\n        Object.keys(config.suites || {}).forEach((suite) => {\n            union(specs, makeArray(config.suites[suite]));\n        });\n        return specs;\n    }\n    /**\n     * Add the options in the parameter config to this runner instance.\n     *\n     * @private\n     * @param {Object} additionalConfig\n     * @param {string} relativeTo the file path to resolve paths against\n     */\n    addConfig_(additionalConfig, relativeTo) {\n        // All filepaths should be kept relative to the current config location.\n        // This will not affect absolute paths.\n        ['seleniumServerJar', 'chromeDriver', 'firefoxPath', 'frameworkPath', 'geckoDriver',\n            'onPrepare']\n            .forEach((name) => {\n            if (additionalConfig[name] && typeof additionalConfig[name] === 'string') {\n                additionalConfig[name] = path.resolve(relativeTo, additionalConfig[name]);\n            }\n        });\n        merge_(this.config_, additionalConfig);\n    }\n    /**\n     * Public function specialized towards merging in a file's config\n     *\n     * @public\n     * @param {String} filename\n     */\n    addFileConfig(filename) {\n        if (!filename) {\n            return this;\n        }\n        let filePath = path.resolve(process.cwd(), filename);\n        let fileConfig;\n        try {\n            fileConfig = require(filePath).config;\n        }\n        catch (e) {\n            throw new exitCodes_1.ConfigError(logger, 'failed loading configuration file ' + filename, e);\n        }\n        if (!fileConfig) {\n            throw new exitCodes_1.ConfigError(logger, 'configuration file ' + filename + ' did not export a config object');\n        }\n        fileConfig.configDir = path.dirname(filePath);\n        this.addConfig_(fileConfig, fileConfig.configDir);\n        return this;\n    }\n    /**\n     * Public function specialized towards merging in config from argv\n     *\n     * @public\n     * @param {Object} argv\n     */\n    addConfig(argv) {\n        this.addConfig_(argv, process.cwd());\n        return this;\n    }\n    /**\n     * Public getter for the final, computed config object\n     *\n     * @public\n     * @return {Object} config\n     */\n    getConfig() {\n        return this.config_;\n    }\n}\nexports.ConfigParser = ConfigParser;\n/**\n * Merge config objects together.\n *\n * @private\n * @param {Object} into\n * @param {Object} from\n *\n * @return {Object} The 'into' config.\n */\nlet merge_ = function (into, from) {\n    for (let key in from) {\n        if (into[key] instanceof Object && !(into[key] instanceof Array) &&\n            !(into[key] instanceof Function)) {\n            merge_(into[key], from[key]);\n        }\n        else {\n            into[key] = from[key];\n        }\n    }\n    return into;\n};\n/**\n * Returns the item if it's an array or puts the item in an array\n * if it was not one already.\n */\nlet makeArray = function (item) {\n    return Array.isArray(item) ? item : [item];\n};\n/**\n * Adds to an array all the elements in another array without adding any\n * duplicates\n *\n * @param {string[]} dest The array to add to\n * @param {string[]} src The array to copy from\n */\nlet union = function (dest, src) {\n    let elems = {};\n    for (let key in dest) {\n        elems[dest[key]] = true;\n    }\n    for (let key in src) {\n        if (!elems[src[key]]) {\n            dest.push(src[key]);\n            elems[src[key]] = true;\n        }\n    }\n};\n//# sourceMappingURL=configParser.js.map"]},"metadata":{},"sourceType":"script"}