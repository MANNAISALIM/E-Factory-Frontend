{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for the\n * Opera web browser (v26+). Before using this module, you must download the\n * latest OperaDriver\n * [release](https://github.com/operasoftware/operachromiumdriver/releases) and\n * ensure it can be found on your system\n * [PATH](http://en.wikipedia.org/wiki/PATH_%28variable%29).\n *\n * There are three primary classes exported by this module:\n *\n * 1. {@linkplain ServiceBuilder}: configures the\n *     {@link selenium-webdriver/remote.DriverService remote.DriverService}\n *     that manages the\n *     [OperaDriver](https://github.com/operasoftware/operachromiumdriver)\n *     child process.\n *\n * 2. {@linkplain Options}: defines configuration options for each new Opera\n *     session, such as which {@linkplain Options#setProxy proxy} to use,\n *     what {@linkplain Options#addExtensions extensions} to install, or\n *     what {@linkplain Options#addArguments command-line switches} to use when\n *     starting the browser.\n *\n * 3. {@linkplain Driver}: the WebDriver client; each new instance will control\n *     a unique browser session with a clean user profile (unless otherwise\n *     configured through the {@link Options} class).\n *\n * By default, every Opera session will use a single driver service, which is\n * started the first time a {@link Driver} instance is created and terminated\n * when this process exits. The default service will inherit its environment\n * from the current process and direct all output to /dev/null. You may obtain\n * a handle to this default service using\n * {@link #getDefaultService getDefaultService()} and change its configuration\n * with {@link #setDefaultService setDefaultService()}.\n *\n * You may also create a {@link Driver} with its own driver service. This is\n * useful if you need to capture the server's log output for a specific session:\n *\n *     var opera = require('selenium-webdriver/opera');\n *\n *     var service = new opera.ServiceBuilder()\n *         .loggingTo('/my/log/file.txt')\n *         .enableVerboseLogging()\n *         .build();\n *\n *     var options = new opera.Options();\n *     // configure browser options ...\n *\n *     var driver = opera.Driver.createSession(options, service);\n *\n * Users should only instantiate the {@link Driver} class directly when they\n * need a custom driver service configuration (as shown above). For normal\n * operation, users should start Opera using the\n * {@link selenium-webdriver.Builder}.\n */\n'use strict';\n\nvar _get = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar fs = require('fs');\n\nvar http = require('./http'),\n    io = require('./io'),\n    capabilities = require('./lib/capabilities'),\n    promise = require('./lib/promise'),\n    Symbols = require('./lib/symbols'),\n    webdriver = require('./lib/webdriver'),\n    portprober = require('./net/portprober'),\n    remote = require('./remote');\n/**\n * Name of the OperaDriver executable.\n * @type {string}\n * @const\n */\n\n\nvar OPERADRIVER_EXE = process.platform === 'win32' ? 'operadriver.exe' : 'operadriver';\n/**\n * Creates {@link remote.DriverService} instances that manages an\n * [OperaDriver](https://github.com/operasoftware/operachromiumdriver)\n * server in a child process.\n */\n\nvar ServiceBuilder = /*#__PURE__*/function (_remote$DriverService) {\n  _inherits(ServiceBuilder, _remote$DriverService);\n\n  var _super = _createSuper(ServiceBuilder);\n\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the operadriver on the current\n   *     PATH.\n   * @throws {Error} If provided executable does not exist, or the operadriver\n   *     cannot be found on the PATH.\n   */\n  function ServiceBuilder(opt_exe) {\n    var _this;\n\n    _classCallCheck(this, ServiceBuilder);\n\n    var exe = opt_exe || io.findInPath(OPERADRIVER_EXE, true);\n\n    if (!exe) {\n      throw Error('The OperaDriver could not be found on the current PATH. Please ' + 'download the latest version of the OperaDriver from ' + 'https://github.com/operasoftware/operachromiumdriver/releases and ' + 'ensure it can be found on your PATH.');\n    }\n\n    _this = _super.call(this, exe);\n\n    _this.setLoopback(true);\n\n    return _this;\n  }\n  /**\n   * Sets the path of the log file the driver should log to. If a log file is\n   * not specified, the driver will log to stderr.\n   * @param {string} path Path of the log file to use.\n   * @return {!ServiceBuilder} A self reference.\n   */\n\n\n  _createClass(ServiceBuilder, [{\n    key: \"loggingTo\",\n    value: function loggingTo(path) {\n      return this.addArguments('--log-path=' + path);\n    }\n    /**\n     * Enables verbose logging.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"enableVerboseLogging\",\n    value: function enableVerboseLogging() {\n      return this.addArguments('--verbose');\n    }\n    /**\n     * Silence sthe drivers output.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"silent\",\n    value: function silent() {\n      return this.addArguments('--silent');\n    }\n  }]);\n\n  return ServiceBuilder;\n}(remote.DriverService.Builder);\n/** @type {remote.DriverService} */\n\n\nvar defaultService = null;\n/**\n * Sets the default service to use for new OperaDriver instances.\n * @param {!remote.DriverService} service The service to use.\n * @throws {Error} If the default service is currently running.\n */\n\nfunction setDefaultService(service) {\n  if (defaultService && defaultService.isRunning()) {\n    throw Error('The previously configured OperaDriver service is still running. ' + 'You must shut it down before you may adjust its configuration.');\n  }\n\n  defaultService = service;\n}\n/**\n * Returns the default OperaDriver service. If such a service has not been\n * configured, one will be constructed using the default configuration for\n * a OperaDriver executable found on the system PATH.\n * @return {!remote.DriverService} The default OperaDriver service.\n */\n\n\nfunction getDefaultService() {\n  if (!defaultService) {\n    defaultService = new ServiceBuilder().build();\n  }\n\n  return defaultService;\n}\n/**\n * @type {string}\n * @const\n */\n\n\nvar OPTIONS_CAPABILITY_KEY = 'chromeOptions';\n/**\n * Class for managing {@linkplain Driver OperaDriver} specific options.\n */\n\nvar Options = /*#__PURE__*/function () {\n  function Options() {\n    _classCallCheck(this, Options);\n\n    /** @private {!Array.<string>} */\n    this.args_ = [];\n    /** @private {?string} */\n\n    this.binary_ = null;\n    /** @private {!Array.<(string|!Buffer)>} */\n\n    this.extensions_ = [];\n    /** @private {./lib/logging.Preferences} */\n\n    this.logPrefs_ = null;\n    /** @private {?capabilities.ProxyConfig} */\n\n    this.proxy_ = null;\n  }\n  /**\n   * Extracts the OperaDriver specific options from the given capabilities\n   * object.\n   * @param {!capabilities.Capabilities} caps The capabilities object.\n   * @return {!Options} The OperaDriver options.\n   */\n\n\n  _createClass(Options, [{\n    key: \"addArguments\",\n\n    /**\n     * Add additional command line arguments to use when launching the Opera\n     * browser.  Each argument may be specified with or without the \"--\" prefix\n     * (e.g. \"--foo\" and \"foo\"). Arguments with an associated value should be\n     * delimited by an \"=\": \"foo=bar\".\n     * @param {...(string|!Array.<string>)} var_args The arguments to add.\n     * @return {!Options} A self reference.\n     */\n    value: function addArguments(var_args) {\n      this.args_ = this.args_.concat.apply(this.args_, arguments);\n      return this;\n    }\n    /**\n     * Add additional extensions to install when launching Opera. Each extension\n     * should be specified as the path to the packed CRX file, or a Buffer for an\n     * extension.\n     * @param {...(string|!Buffer|!Array.<(string|!Buffer)>)} var_args The\n     *     extensions to add.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"addExtensions\",\n    value: function addExtensions(var_args) {\n      this.extensions_ = this.extensions_.concat.apply(this.extensions_, arguments);\n      return this;\n    }\n    /**\n     * Sets the path to the Opera binary to use. On Mac OS X, this path should\n     * reference the actual Opera executable, not just the application binary. The\n     * binary path be absolute or relative to the operadriver server executable, but\n     * it must exist on the machine that will launch Opera.\n     *\n     * @param {string} path The path to the Opera binary to use.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setOperaBinaryPath\",\n    value: function setOperaBinaryPath(path) {\n      this.binary_ = path;\n      return this;\n    }\n    /**\n     * Sets the logging preferences for the new session.\n     * @param {!./lib/logging.Preferences} prefs The logging preferences.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setLoggingPrefs\",\n    value: function setLoggingPrefs(prefs) {\n      this.logPrefs_ = prefs;\n      return this;\n    }\n    /**\n     * Sets the proxy settings for the new session.\n     * @param {capabilities.ProxyConfig} proxy The proxy configuration to use.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setProxy\",\n    value: function setProxy(proxy) {\n      this.proxy_ = proxy;\n      return this;\n    }\n    /**\n     * Converts this options instance to a {@link capabilities.Capabilities}\n     *     object.\n     * @param {capabilities.Capabilities=} opt_capabilities The capabilities to\n     *     merge these options into, if any.\n     * @return {!capabilities.Capabilities} The capabilities.\n     */\n\n  }, {\n    key: \"toCapabilities\",\n    value: function toCapabilities(opt_capabilities) {\n      var caps = opt_capabilities || capabilities.Capabilities.opera();\n      caps.set(capabilities.Capability.PROXY, this.proxy_).set(capabilities.Capability.LOGGING_PREFS, this.logPrefs_).set(OPTIONS_CAPABILITY_KEY, this);\n      return caps;\n    }\n    /**\n     * Converts this instance to its JSON wire protocol representation. Note this\n     * function is an implementation not intended for general use.\n     * @return {!Object} The JSON wire protocol representation of this instance.\n     */\n\n  }, {\n    key: Symbols.serialize,\n    value: function value() {\n      var json = {\n        args: this.args_,\n        extensions: this.extensions_.map(function (extension) {\n          if (Buffer.isBuffer(extension)) {\n            return extension.toString('base64');\n          }\n\n          return io.read(\n          /** @type {string} */\n          extension).then(function (buffer) {\n            return buffer.toString('base64');\n          });\n        })\n      };\n\n      if (this.binary_) {\n        json.binary = this.binary_;\n      }\n\n      return json;\n    }\n  }], [{\n    key: \"fromCapabilities\",\n    value: function fromCapabilities(caps) {\n      var options;\n      var o = caps.get(OPTIONS_CAPABILITY_KEY);\n\n      if (o instanceof Options) {\n        options = o;\n      } else if (o) {\n        options = new Options().addArguments(o.args || []).addExtensions(o.extensions || []).setOperaBinaryPath(o.binary);\n      } else {\n        options = new Options();\n      }\n\n      if (caps.has(capabilities.Capability.PROXY)) {\n        options.setProxy(caps.get(capabilities.Capability.PROXY));\n      }\n\n      if (caps.has(capabilities.Capability.LOGGING_PREFS)) {\n        options.setLoggingPrefs(caps.get(capabilities.Capability.LOGGING_PREFS));\n      }\n\n      return options;\n    }\n  }]);\n\n  return Options;\n}();\n/**\n * Creates a new WebDriver client for Opera.\n */\n\n\nvar Driver = /*#__PURE__*/function (_webdriver$WebDriver) {\n  _inherits(Driver, _webdriver$WebDriver);\n\n  var _super2 = _createSuper(Driver);\n\n  function Driver() {\n    _classCallCheck(this, Driver);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(Driver, [{\n    key: \"setFileDetector\",\n\n    /**\n     * This function is a no-op as file detectors are not supported by this\n     * implementation.\n     * @override\n     */\n    value: function setFileDetector() {}\n  }], [{\n    key: \"createSession\",\n\n    /**\n     * Creates a new session for Opera.\n     *\n     * @param {(capabilities.Capabilities|Options)=} opt_config The configuration\n     *     options.\n     * @param {remote.DriverService=} opt_service The session to use; will use\n     *     the {@link getDefaultService default service} by default.\n     * @param {promise.ControlFlow=} opt_flow The control flow to use,\n     *     or {@code null} to use the currently active flow.\n     * @return {!Driver} A new driver instance.\n     */\n    value: function createSession(opt_config, opt_service, opt_flow) {\n      var service = opt_service || getDefaultService();\n      var client = service.start().then(function (url) {\n        return new http.HttpClient(url);\n      });\n      var executor = new http.Executor(client);\n      var caps = opt_config instanceof Options ? opt_config.toCapabilities() : opt_config || capabilities.Capabilities.opera(); // On Linux, the OperaDriver does not look for Opera on the PATH, so we\n      // must explicitly find it. See: operachromiumdriver #9.\n\n      if (process.platform === 'linux') {\n        var options = Options.fromCapabilities(caps);\n\n        if (!options.binary_) {\n          var exe = io.findInPath('opera', true);\n\n          if (!exe) {\n            throw Error('The opera executable could not be found on the current PATH');\n          }\n\n          options.setOperaBinaryPath(exe);\n        }\n\n        caps = options.toCapabilities(caps);\n      }\n\n      return (\n        /** @type {!Driver} */\n        _get(_getPrototypeOf(Driver), \"createSession\", this).call(this, executor, caps, opt_flow)\n      );\n    }\n  }]);\n\n  return Driver;\n}(webdriver.WebDriver); // PUBLIC API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.getDefaultService = getDefaultService;\nexports.setDefaultService = setDefaultService;","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/selenium-webdriver/opera.js"],"names":["fs","require","http","io","capabilities","promise","Symbols","webdriver","portprober","remote","OPERADRIVER_EXE","process","platform","ServiceBuilder","opt_exe","exe","findInPath","Error","setLoopback","path","addArguments","DriverService","Builder","defaultService","setDefaultService","service","isRunning","getDefaultService","build","OPTIONS_CAPABILITY_KEY","Options","args_","binary_","extensions_","logPrefs_","proxy_","var_args","concat","apply","arguments","prefs","proxy","opt_capabilities","caps","Capabilities","opera","set","Capability","PROXY","LOGGING_PREFS","serialize","json","args","extensions","map","extension","Buffer","isBuffer","toString","read","then","buffer","binary","options","o","get","addExtensions","setOperaBinaryPath","has","setProxy","setLoggingPrefs","Driver","opt_config","opt_service","opt_flow","client","start","url","HttpClient","executor","Executor","toCapabilities","fromCapabilities","WebDriver","exports"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for the\n * Opera web browser (v26+). Before using this module, you must download the\n * latest OperaDriver\n * [release](https://github.com/operasoftware/operachromiumdriver/releases) and\n * ensure it can be found on your system\n * [PATH](http://en.wikipedia.org/wiki/PATH_%28variable%29).\n *\n * There are three primary classes exported by this module:\n *\n * 1. {@linkplain ServiceBuilder}: configures the\n *     {@link selenium-webdriver/remote.DriverService remote.DriverService}\n *     that manages the\n *     [OperaDriver](https://github.com/operasoftware/operachromiumdriver)\n *     child process.\n *\n * 2. {@linkplain Options}: defines configuration options for each new Opera\n *     session, such as which {@linkplain Options#setProxy proxy} to use,\n *     what {@linkplain Options#addExtensions extensions} to install, or\n *     what {@linkplain Options#addArguments command-line switches} to use when\n *     starting the browser.\n *\n * 3. {@linkplain Driver}: the WebDriver client; each new instance will control\n *     a unique browser session with a clean user profile (unless otherwise\n *     configured through the {@link Options} class).\n *\n * By default, every Opera session will use a single driver service, which is\n * started the first time a {@link Driver} instance is created and terminated\n * when this process exits. The default service will inherit its environment\n * from the current process and direct all output to /dev/null. You may obtain\n * a handle to this default service using\n * {@link #getDefaultService getDefaultService()} and change its configuration\n * with {@link #setDefaultService setDefaultService()}.\n *\n * You may also create a {@link Driver} with its own driver service. This is\n * useful if you need to capture the server's log output for a specific session:\n *\n *     var opera = require('selenium-webdriver/opera');\n *\n *     var service = new opera.ServiceBuilder()\n *         .loggingTo('/my/log/file.txt')\n *         .enableVerboseLogging()\n *         .build();\n *\n *     var options = new opera.Options();\n *     // configure browser options ...\n *\n *     var driver = opera.Driver.createSession(options, service);\n *\n * Users should only instantiate the {@link Driver} class directly when they\n * need a custom driver service configuration (as shown above). For normal\n * operation, users should start Opera using the\n * {@link selenium-webdriver.Builder}.\n */\n\n'use strict';\n\nconst fs = require('fs');\n\nconst http = require('./http'),\n    io = require('./io'),\n    capabilities = require('./lib/capabilities'),\n    promise = require('./lib/promise'),\n    Symbols = require('./lib/symbols'),\n    webdriver = require('./lib/webdriver'),\n    portprober = require('./net/portprober'),\n    remote = require('./remote');\n\n\n/**\n * Name of the OperaDriver executable.\n * @type {string}\n * @const\n */\nconst OPERADRIVER_EXE =\n    process.platform === 'win32' ? 'operadriver.exe' : 'operadriver';\n\n\n/**\n * Creates {@link remote.DriverService} instances that manages an\n * [OperaDriver](https://github.com/operasoftware/operachromiumdriver)\n * server in a child process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the operadriver on the current\n   *     PATH.\n   * @throws {Error} If provided executable does not exist, or the operadriver\n   *     cannot be found on the PATH.\n   */\n  constructor(opt_exe) {\n    let exe = opt_exe || io.findInPath(OPERADRIVER_EXE, true);\n    if (!exe) {\n      throw Error(\n          'The OperaDriver could not be found on the current PATH. Please ' +\n          'download the latest version of the OperaDriver from ' +\n          'https://github.com/operasoftware/operachromiumdriver/releases and ' +\n          'ensure it can be found on your PATH.');\n    }\n\n    super(exe);\n    this.setLoopback(true);\n  }\n\n  /**\n   * Sets the path of the log file the driver should log to. If a log file is\n   * not specified, the driver will log to stderr.\n   * @param {string} path Path of the log file to use.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  loggingTo(path) {\n    return this.addArguments('--log-path=' + path);\n  }\n\n  /**\n   * Enables verbose logging.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging() {\n    return this.addArguments('--verbose');\n  }\n\n  /**\n   * Silence sthe drivers output.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  silent() {\n    return this.addArguments('--silent');\n  }\n}\n\n\n\n/** @type {remote.DriverService} */\nvar defaultService = null;\n\n\n/**\n * Sets the default service to use for new OperaDriver instances.\n * @param {!remote.DriverService} service The service to use.\n * @throws {Error} If the default service is currently running.\n */\nfunction setDefaultService(service) {\n  if (defaultService && defaultService.isRunning()) {\n    throw Error(\n        'The previously configured OperaDriver service is still running. ' +\n        'You must shut it down before you may adjust its configuration.');\n  }\n  defaultService = service;\n}\n\n\n/**\n * Returns the default OperaDriver service. If such a service has not been\n * configured, one will be constructed using the default configuration for\n * a OperaDriver executable found on the system PATH.\n * @return {!remote.DriverService} The default OperaDriver service.\n */\nfunction getDefaultService() {\n  if (!defaultService) {\n    defaultService = new ServiceBuilder().build();\n  }\n  return defaultService;\n}\n\n\n/**\n * @type {string}\n * @const\n */\nvar OPTIONS_CAPABILITY_KEY = 'chromeOptions';\n\n\n/**\n * Class for managing {@linkplain Driver OperaDriver} specific options.\n */\nclass Options {\n  constructor() {\n    /** @private {!Array.<string>} */\n    this.args_ = [];\n\n    /** @private {?string} */\n    this.binary_ = null;\n\n    /** @private {!Array.<(string|!Buffer)>} */\n    this.extensions_ = [];\n\n    /** @private {./lib/logging.Preferences} */\n    this.logPrefs_ = null;\n\n    /** @private {?capabilities.ProxyConfig} */\n    this.proxy_ = null;\n  }\n\n  /**\n   * Extracts the OperaDriver specific options from the given capabilities\n   * object.\n   * @param {!capabilities.Capabilities} caps The capabilities object.\n   * @return {!Options} The OperaDriver options.\n   */\n  static fromCapabilities(caps) {\n    var options;\n    var o = caps.get(OPTIONS_CAPABILITY_KEY);\n    if (o instanceof Options) {\n      options = o;\n    } else if (o) {\n      options = new Options()\n          .addArguments(o.args || [])\n          .addExtensions(o.extensions || [])\n          .setOperaBinaryPath(o.binary);\n    } else {\n      options = new Options;\n    }\n\n    if (caps.has(capabilities.Capability.PROXY)) {\n      options.setProxy(caps.get(capabilities.Capability.PROXY));\n    }\n\n    if (caps.has(capabilities.Capability.LOGGING_PREFS)) {\n      options.setLoggingPrefs(\n          caps.get(capabilities.Capability.LOGGING_PREFS));\n    }\n\n    return options;\n  }\n\n  /**\n   * Add additional command line arguments to use when launching the Opera\n   * browser.  Each argument may be specified with or without the \"--\" prefix\n   * (e.g. \"--foo\" and \"foo\"). Arguments with an associated value should be\n   * delimited by an \"=\": \"foo=bar\".\n   * @param {...(string|!Array.<string>)} var_args The arguments to add.\n   * @return {!Options} A self reference.\n   */\n  addArguments(var_args) {\n    this.args_ = this.args_.concat.apply(this.args_, arguments);\n    return this;\n  }\n\n  /**\n   * Add additional extensions to install when launching Opera. Each extension\n   * should be specified as the path to the packed CRX file, or a Buffer for an\n   * extension.\n   * @param {...(string|!Buffer|!Array.<(string|!Buffer)>)} var_args The\n   *     extensions to add.\n   * @return {!Options} A self reference.\n   */\n  addExtensions(var_args) {\n    this.extensions_ = this.extensions_.concat.apply(\n        this.extensions_, arguments);\n    return this;\n  }\n\n  /**\n   * Sets the path to the Opera binary to use. On Mac OS X, this path should\n   * reference the actual Opera executable, not just the application binary. The\n   * binary path be absolute or relative to the operadriver server executable, but\n   * it must exist on the machine that will launch Opera.\n   *\n   * @param {string} path The path to the Opera binary to use.\n   * @return {!Options} A self reference.\n   */\n  setOperaBinaryPath(path) {\n    this.binary_ = path;\n    return this;\n  }\n\n  /**\n   * Sets the logging preferences for the new session.\n   * @param {!./lib/logging.Preferences} prefs The logging preferences.\n   * @return {!Options} A self reference.\n   */\n  setLoggingPrefs(prefs) {\n    this.logPrefs_ = prefs;\n    return this;\n  }\n\n  /**\n   * Sets the proxy settings for the new session.\n   * @param {capabilities.ProxyConfig} proxy The proxy configuration to use.\n   * @return {!Options} A self reference.\n   */\n  setProxy(proxy) {\n    this.proxy_ = proxy;\n    return this;\n  }\n\n  /**\n   * Converts this options instance to a {@link capabilities.Capabilities}\n   *     object.\n   * @param {capabilities.Capabilities=} opt_capabilities The capabilities to\n   *     merge these options into, if any.\n   * @return {!capabilities.Capabilities} The capabilities.\n   */\n  toCapabilities(opt_capabilities) {\n    var caps = opt_capabilities || capabilities.Capabilities.opera();\n    caps.\n        set(capabilities.Capability.PROXY, this.proxy_).\n        set(capabilities.Capability.LOGGING_PREFS, this.logPrefs_).\n        set(OPTIONS_CAPABILITY_KEY, this);\n    return caps;\n  }\n\n  /**\n   * Converts this instance to its JSON wire protocol representation. Note this\n   * function is an implementation not intended for general use.\n   * @return {!Object} The JSON wire protocol representation of this instance.\n   */\n  [Symbols.serialize]() {\n    var json = {\n      args: this.args_,\n      extensions: this.extensions_.map(function(extension) {\n        if (Buffer.isBuffer(extension)) {\n          return extension.toString('base64');\n        }\n        return io.read(/** @type {string} */(extension))\n            .then(buffer => buffer.toString('base64'));\n      })\n    };\n    if (this.binary_) {\n      json.binary = this.binary_;\n    }\n    return json;\n  }\n}\n\n\n/**\n * Creates a new WebDriver client for Opera.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new session for Opera.\n   *\n   * @param {(capabilities.Capabilities|Options)=} opt_config The configuration\n   *     options.\n   * @param {remote.DriverService=} opt_service The session to use; will use\n   *     the {@link getDefaultService default service} by default.\n   * @param {promise.ControlFlow=} opt_flow The control flow to use,\n   *     or {@code null} to use the currently active flow.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(opt_config, opt_service, opt_flow) {\n    var service = opt_service || getDefaultService();\n    var client = service.start().then(url => new http.HttpClient(url));\n    var executor = new http.Executor(client);\n\n    var caps =\n        opt_config instanceof Options ? opt_config.toCapabilities() :\n        (opt_config || capabilities.Capabilities.opera());\n\n    // On Linux, the OperaDriver does not look for Opera on the PATH, so we\n    // must explicitly find it. See: operachromiumdriver #9.\n    if (process.platform === 'linux') {\n      var options = Options.fromCapabilities(caps);\n      if (!options.binary_) {\n        let exe = io.findInPath('opera', true);\n        if (!exe) {\n          throw Error(\n              'The opera executable could not be found on the current PATH');\n        }\n        options.setOperaBinaryPath(exe);\n      }\n      caps = options.toCapabilities(caps);\n    }\n\n    return /** @type {!Driver} */(\n        super.createSession(executor, caps, opt_flow));\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n}\n\n\n// PUBLIC API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.getDefaultService = getDefaultService;\nexports.setDefaultService = setDefaultService;\n"]},"metadata":{},"sourceType":"script"}