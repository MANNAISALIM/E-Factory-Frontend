{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar webdriver_commands_1 = require(\"./webdriver_commands\");\n\nvar HIGHLIGHT_COMMAND = [webdriver_commands_1.CommandName.ElementClick, webdriver_commands_1.CommandName.ElementSendKeys, webdriver_commands_1.CommandName.ElementClear];\n\nvar clientScripts = require('./client_scripts/highlight.js');\n/**\n * A barrier that delays forwarding WebDriver commands that can affect the app (ie, clicks or\n * sending text) for a fixed amount of time. During the delay, the element that's the target\n * of the command will be highlighted by drawing a transparent div on top of it.\n */\n\n\nvar HighlightDelayBarrier = /*#__PURE__*/function () {\n  function HighlightDelayBarrier(client, delay) {\n    _classCallCheck(this, HighlightDelayBarrier);\n\n    this.client = client;\n    this.delay = delay;\n  }\n\n  _createClass(HighlightDelayBarrier, [{\n    key: \"isHighlightCommand\",\n    value: function isHighlightCommand(command) {\n      return HIGHLIGHT_COMMAND.indexOf(command.commandName) !== -1;\n    }\n  }, {\n    key: \"highlightData\",\n    value: function highlightData(top, left, width, height) {\n      return JSON.stringify({\n        script: 'return (' + clientScripts.HIGHLIGHT_FN + ').apply(null, arguments);',\n        args: [top, left, width, height]\n      });\n    }\n  }, {\n    key: \"removeHighlightData\",\n    value: function removeHighlightData() {\n      return JSON.stringify({\n        script: 'return (' + clientScripts.REMOVE_HIGHLIGHT_FN + ').apply(null, arguments);',\n        args: []\n      });\n    } // Simple promise-based sleep so we can use async/await\n\n  }, {\n    key: \"sleep\",\n    value: function sleep(delay) {\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          resolve();\n        }, delay);\n      });\n    }\n  }, {\n    key: \"onCommand\",\n    value: function onCommand(command) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var sessId, el, loc, size;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!this.isHighlightCommand(command) || !this.delay)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                sessId = command.sessionId;\n                el = command.getParam('elementId'); // The W3C spec does have a 'getRect', but the standalone server doesn't support it yet.\n\n                _context.next = 6;\n                return this.client.getLocation(sessId, el);\n\n              case 6:\n                loc = _context.sent;\n                _context.next = 9;\n                return this.client.getSize(sessId, el);\n\n              case 9:\n                size = _context.sent;\n                _context.next = 12;\n                return this.client.execute(sessId, this.highlightData(loc['y'], loc['x'], size['width'], size['height']));\n\n              case 12:\n                _context.next = 14;\n                return this.sleep(this.delay);\n\n              case 14:\n                _context.next = 16;\n                return this.client.execute(sessId, this.removeHighlightData());\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }]);\n\n  return HighlightDelayBarrier;\n}();\n\nexports.HighlightDelayBarrier = HighlightDelayBarrier;","map":{"version":3,"sources":["../../lib/highlight_delay_barrier.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAA,oBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AAGA,IAAM,iBAAiB,GACnB,CAAC,oBAAA,CAAA,WAAA,CAAY,YAAb,EAA2B,oBAAA,CAAA,WAAA,CAAY,eAAvC,EAAwD,oBAAA,CAAA,WAAA,CAAY,YAApE,CADJ;;AAGA,IAAI,aAAa,GAAG,OAAO,CAAC,+BAAD,CAA3B;AAGA;;;;AAIG;;;IACH,qB;AACE,iCAAoB,MAApB,EAA0D,KAA1D,EAAuE;AAAA;;AAAnD,SAAA,MAAA,GAAA,MAAA;AAAsC,SAAA,KAAA,GAAA,KAAA;AAAiB;;;;uCAEhD,O,EAAyB;AAClD,aAAO,iBAAiB,CAAC,OAAlB,CAA0B,OAAO,CAAC,WAAlC,MAAmD,CAAC,CAA3D;AACD;;;kCAEqB,G,EAAK,I,EAAM,K,EAAO,M,EAAM;AAC5C,aAAO,IAAI,CAAC,SAAL,CAAe;AACpB,QAAA,MAAM,EAAE,aAAa,aAAa,CAAC,YAA3B,GAA0C,2BAD9B;AAEpB,QAAA,IAAI,EAAE,CAAC,GAAD,EAAM,IAAN,EAAY,KAAZ,EAAmB,MAAnB;AAFc,OAAf,CAAP;AAID;;;0CAE0B;AACzB,aAAO,IAAI,CAAC,SAAL,CAAe;AACpB,QAAA,MAAM,EAAE,aAAa,aAAa,CAAC,mBAA3B,GAAiD,2BADrC;AAEpB,QAAA,IAAI,EAAE;AAFc,OAAf,CAAP;AAID,K,CAED;;;;0BACc,K,EAAa;AACzB,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAY;AAC7B,QAAA,UAAU,CAAC,YAAK;AACd,UAAA,OAAO;AACR,SAFS,EAEP,KAFO,CAAV;AAGD,OAJM,CAAP;AAKD;;;8BAEe,O,EAAyB;;;;;;;sBACnC,CAAC,KAAK,kBAAL,CAAwB,OAAxB,CAAD,IAAqC,CAAC,KAAK,K;;;;;;;;AAGzC,gBAAA,M,GAAS,OAAO,CAAC,S;AACjB,gBAAA,E,GAAK,OAAO,CAAC,QAAR,CAAiB,WAAjB,C,EAEX;;;AACY,uBAAM,KAAK,MAAL,CAAY,WAAZ,CAAwB,MAAxB,EAAgC,EAAhC,CAAN;;;AAAN,gBAAA,G;;AACO,uBAAM,KAAK,MAAL,CAAY,OAAZ,CAAoB,MAApB,EAA4B,EAA5B,CAAN;;;AAAP,gBAAA,I;;AAGN,uBAAM,KAAK,MAAL,CAAY,OAAZ,CACF,MADE,EACM,KAAK,aAAL,CAAmB,GAAG,CAAC,GAAD,CAAtB,EAA6B,GAAG,CAAC,GAAD,CAAhC,EAAuC,IAAI,CAAC,OAAD,CAA3C,EAAsD,IAAI,CAAC,QAAD,CAA1D,CADN,CAAN;;;;AAIA,uBAAM,KAAK,KAAL,CAAW,KAAK,KAAhB,CAAN;;;;AAGA,uBAAM,KAAK,MAAL,CAAY,OAAZ,CAAoB,MAApB,EAA4B,KAAK,mBAAL,EAA5B,CAAN;;;;;;;;;AACD;;;;;;AAlDH,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst webdriver_commands_1 = require(\"./webdriver_commands\");\nconst HIGHLIGHT_COMMAND = [webdriver_commands_1.CommandName.ElementClick, webdriver_commands_1.CommandName.ElementSendKeys, webdriver_commands_1.CommandName.ElementClear];\nlet clientScripts = require('./client_scripts/highlight.js');\n/**\n * A barrier that delays forwarding WebDriver commands that can affect the app (ie, clicks or\n * sending text) for a fixed amount of time. During the delay, the element that's the target\n * of the command will be highlighted by drawing a transparent div on top of it.\n */\nclass HighlightDelayBarrier {\n    constructor(client, delay) {\n        this.client = client;\n        this.delay = delay;\n    }\n    isHighlightCommand(command) {\n        return HIGHLIGHT_COMMAND.indexOf(command.commandName) !== -1;\n    }\n    highlightData(top, left, width, height) {\n        return JSON.stringify({\n            script: 'return (' + clientScripts.HIGHLIGHT_FN + ').apply(null, arguments);',\n            args: [top, left, width, height]\n        });\n    }\n    removeHighlightData() {\n        return JSON.stringify({\n            script: 'return (' + clientScripts.REMOVE_HIGHLIGHT_FN + ').apply(null, arguments);',\n            args: []\n        });\n    }\n    // Simple promise-based sleep so we can use async/await\n    sleep(delay) {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                resolve();\n            }, delay);\n        });\n    }\n    onCommand(command) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isHighlightCommand(command) || !this.delay) {\n                return;\n            }\n            const sessId = command.sessionId;\n            const el = command.getParam('elementId');\n            // The W3C spec does have a 'getRect', but the standalone server doesn't support it yet.\n            const loc = yield this.client.getLocation(sessId, el);\n            const size = yield this.client.getSize(sessId, el);\n            // Set the highlight\n            yield this.client.execute(sessId, this.highlightData(loc['y'], loc['x'], size['width'], size['height']));\n            // Wait\n            yield this.sleep(this.delay);\n            // Clear the highlight\n            yield this.client.execute(sessId, this.removeHighlightData());\n        });\n    }\n}\nexports.HighlightDelayBarrier = HighlightDelayBarrier;\n//# sourceMappingURL=highlight_delay_barrier.js.map"]},"metadata":{},"sourceType":"script"}