{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview\n *\n * > ### IMPORTANT NOTICE\n * >\n * > The promise manager contained in this module is in the process of being\n * > phased out in favor of native JavaScript promises. This will be a long\n * > process and will not be completed until there have been two major LTS Node\n * > releases (approx. Node v10.0) that support\n * > [async functions](https://tc39.github.io/ecmascript-asyncawait/).\n * >\n * > At this time, the promise manager can be disabled by setting an environment\n * > variable, `SELENIUM_PROMISE_MANAGER=0`. In the absence of async functions,\n * > users may use generators with the\n * > {@link ./promise.consume promise.consume()} function to write \"synchronous\"\n * > style tests:\n * >\n * > ```js\n * > const {Builder, By, Key, promise, until} = require('selenium-webdriver');\n * >\n * > let result = promise.consume(function* doGoogleSearch() {\n * >   let driver = new Builder().forBrowser('firefox').build();\n * >   yield driver.get('http://www.google.com/ncr');\n * >   yield driver.findElement(By.name('q')).sendKeys('webdriver', Key.RETURN);\n * >   yield driver.wait(until.titleIs('webdriver - Google Search'), 1000);\n * >   yield driver.quit();\n * > });\n * >\n * > result.then(_ => console.log('SUCCESS!'),\n * >             e => console.error('FAILURE: ' + e));\n * > ```\n * >\n * > The motivation behind this change and full deprecation plan are documented\n * > in [issue 2969](https://github.com/SeleniumHQ/selenium/issues/2969).\n * >\n * >\n *\n * The promise module is centered around the {@linkplain ControlFlow}, a class\n * that coordinates the execution of asynchronous tasks. The ControlFlow allows\n * users to focus on the imperative commands for their script without worrying\n * about chaining together every single asynchronous action, which can be\n * tedious and verbose. APIs may be layered on top of the control flow to read\n * as if they were synchronous. For instance, the core\n * {@linkplain ./webdriver.WebDriver WebDriver} API is built on top of the\n * control flow, allowing users to write\n *\n *     driver.get('http://www.google.com/ncr');\n *     driver.findElement({name: 'q'}).sendKeys('webdriver', Key.RETURN);\n *\n * instead of\n *\n *     driver.get('http://www.google.com/ncr')\n *     .then(function() {\n *       return driver.findElement({name: 'q'});\n *     })\n *     .then(function(q) {\n *       return q.sendKeys('webdriver', Key.RETURN);\n *     });\n *\n * ## Tasks and Task Queues\n *\n * The control flow is based on the concept of tasks and task queues. Tasks are\n * functions that define the basic unit of work for the control flow to execute.\n * Each task is scheduled via {@link ControlFlow#execute()}, which will return\n * a {@link ManagedPromise} that will be resolved with the task's result.\n *\n * A task queue contains all of the tasks scheduled within a single turn of the\n * [JavaScript event loop][JSEL]. The control flow will create a new task queue\n * the first time a task is scheduled within an event loop.\n *\n *     var flow = promise.controlFlow();\n *     flow.execute(foo);       // Creates a new task queue and inserts foo.\n *     flow.execute(bar);       // Inserts bar into the same queue as foo.\n *     setTimeout(function() {\n *       flow.execute(baz);     // Creates a new task queue and inserts baz.\n *     }, 0);\n *\n * Whenever the control flow creates a new task queue, it will automatically\n * begin executing tasks in the next available turn of the event loop. This\n * execution is [scheduled as a microtask][MicrotasksArticle] like e.g. a\n * (native) `Promise.then()` callback.\n *\n *     setTimeout(() => console.log('a'));\n *     Promise.resolve().then(() => console.log('b'));  // A native promise.\n *     flow.execute(() => console.log('c'));\n *     Promise.resolve().then(() => console.log('d'));\n *     setTimeout(() => console.log('fin'));\n *     // b\n *     // c\n *     // d\n *     // a\n *     // fin\n *\n * In the example above, b/c/d is logged before a/fin because native promises\n * and this module use \"microtask\" timers, which have a higher priority than\n * \"macrotasks\" like `setTimeout`.\n *\n * ## Task Execution\n *\n * Upon creating a task queue, and whenever an existing queue completes a task,\n * the control flow will schedule a microtask timer to process any scheduled\n * tasks. This ensures no task is ever started within the same turn of the\n * JavaScript event loop in which it was scheduled, nor is a task ever started\n * within the same turn that another finishes.\n *\n * When the execution timer fires, a single task will be dequeued and executed.\n * There are several important events that may occur while executing a task\n * function:\n *\n * 1. A new task queue is created by a call to {@link ControlFlow#execute()}.\n *    Any tasks scheduled within this task queue are considered subtasks of the\n *    current task.\n * 2. The task function throws an error. Any scheduled tasks are immediately\n *    discarded and the task's promised result (previously returned by\n *    {@link ControlFlow#execute()}) is immediately rejected with the thrown\n *    error.\n * 3. The task function returns successfully.\n *\n * If a task function created a new task queue, the control flow will wait for\n * that queue to complete before processing the task result. If the queue\n * completes without error, the flow will settle the task's promise with the\n * value originally returned by the task function. On the other hand, if the task\n * queue terminates with an error, the task's promise will be rejected with that\n * error.\n *\n *     flow.execute(function() {\n *       flow.execute(() => console.log('a'));\n *       flow.execute(() => console.log('b'));\n *     });\n *     flow.execute(() => console.log('c'));\n *     // a\n *     // b\n *     // c\n *\n * ## ManagedPromise Integration\n *\n * In addition to the {@link ControlFlow} class, the promise module also exports\n * a [Promises/A+] {@linkplain ManagedPromise implementation} that is deeply\n * integrated with the ControlFlow. First and foremost, each promise\n * {@linkplain ManagedPromise#then() callback} is scheduled with the\n * control flow as a task. As a result, each callback is invoked in its own turn\n * of the JavaScript event loop with its own task queue. If any tasks are\n * scheduled within a callback, the callback's promised result will not be\n * settled until the task queue has completed.\n *\n *     promise.fulfilled().then(function() {\n *       flow.execute(function() {\n *         console.log('b');\n *       });\n *     }).then(() => console.log('a'));\n *     // b\n *     // a\n *\n * ### Scheduling ManagedPromise Callbacks <a id=\"scheduling_callbacks\"></a>\n *\n * How callbacks are scheduled in the control flow depends on when they are\n * attached to the promise. Callbacks attached to a _previously_ resolved\n * promise are immediately enqueued as subtasks of the currently running task.\n *\n *     var p = promise.fulfilled();\n *     flow.execute(function() {\n *       flow.execute(() => console.log('A'));\n *       p.then(      () => console.log('B'));\n *       flow.execute(() => console.log('C'));\n *       p.then(      () => console.log('D'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * When a promise is resolved while a task function is on the call stack, any\n * callbacks also registered in that stack frame are scheduled as if the promise\n * were already resolved:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * Callbacks attached to an _unresolved_ promise within a task function are\n * only weakly scheduled as subtasks and will be dropped if they reach the\n * front of the queue before the promise is resolved. In the example below, the\n * callbacks for `B` & `D` are dropped as sub-tasks since they are attached to\n * an unresolved promise when they reach the front of the task queue.\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       setTimeout(d.fulfill, 20);\n *     }).then(function() {\n *       console.log('fin')\n *     });\n *     // A\n *     // C\n *     // fin\n *     // B\n *     // D\n *\n * If a promise is resolved while a task function is on the call stack, any\n * previously registered and unqueued callbacks (i.e. either attached while no\n * task was on the call stack, or previously dropped as described above) act as\n * _interrupts_ and are inserted at the front of the task queue. If multiple\n * promises are fulfilled, their interrupts are enqueued in the order the\n * promises are resolved.\n *\n *     var d1 = promise.defer();\n *     d1.promise.then(() => console.log('A'));\n *\n *     var d2 = promise.defer();\n *     d2.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       d1.promise.then(() => console.log('C'));\n *       flow.execute(() => console.log('D'));\n *     });\n *     flow.execute(function() {\n *       flow.execute(() => console.log('E'));\n *       flow.execute(() => console.log('F'));\n *       d1.fulfill();\n *       d2.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // D\n *     // A\n *     // C\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Within a task function (or callback), each step of a promise chain acts as\n * an interrupt on the task queue:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       d.promise.\n *           then(() => console.log('A')).\n *           then(() => console.log('B')).\n *           then(() => console.log('C')).\n *           then(() => console.log('D'));\n *\n *       flow.execute(() => console.log('E'));\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // fin\n *\n * If there are multiple promise chains derived from a single promise, they are\n * processed in the order created:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       var chain = d.promise.then(() => console.log('A'));\n *\n *       chain.then(() => console.log('B')).\n *           then(() => console.log('C'));\n *\n *       chain.then(() => console.log('D')).\n *           then(() => console.log('E'));\n *\n *       flow.execute(() => console.log('F'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // fin\n *\n * Even though a subtask's promised result will never resolve while the task\n * function is on the stack, it will be treated as a promise resolved within the\n * task. In all other scenarios, a task's promise behaves just like a normal\n * promise. In the sample below, `C/D` is logged before `B` because the\n * resolution of `subtask1` interrupts the flow of the enclosing task. Within\n * the final subtask, `E/F` is logged in order because `subtask1` is a resolved\n * promise when that task runs.\n *\n *     flow.execute(function() {\n *       var subtask1 = flow.execute(() => console.log('A'));\n *       var subtask2 = flow.execute(() => console.log('B'));\n *\n *       subtask1.then(() => console.log('C'));\n *       subtask1.then(() => console.log('D'));\n *\n *       flow.execute(function() {\n *         flow.execute(() => console.log('E'));\n *         subtask1.then(() => console.log('F'));\n *       });\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // C\n *     // D\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Finally, consider the following:\n *\n *     var d = promise.defer();\n *     d.promise.then(() => console.log('A'));\n *     d.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       flow.execute(  () => console.log('E'));\n *       d.promise.then(() => console.log('F'));\n *\n *       d.fulfill();\n *\n *       flow.execute(  () => console.log('G'));\n *       d.promise.then(() => console.log('H'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // G\n *     // H\n *     // fin\n *\n * In this example, callbacks are registered on `d.promise` both before and\n * during the invocation of the task function. When `d.fulfill()` is called,\n * the callbacks registered before the task (`A` & `B`) are registered as\n * interrupts. The remaining callbacks were all attached within the task and\n * are scheduled in the flow as standard tasks.\n *\n * ## Generator Support\n *\n * [Generators][GF] may be scheduled as tasks within a control flow or attached\n * as callbacks to a promise. Each time the generator yields a promise, the\n * control flow will wait for that promise to settle before executing the next\n * iteration of the generator. The yielded promise's fulfilled value will be\n * passed back into the generator:\n *\n *     flow.execute(function* () {\n *       var d = promise.defer();\n *\n *       setTimeout(() => console.log('...waiting...'), 25);\n *       setTimeout(() => d.fulfill(123), 50);\n *\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield d.promise;\n *       console.log('mid: %d; value = %d', Date.now(), value);\n *\n *       yield promise.delayed(10);\n *       console.log('end: ' + Date.now());\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // ...waiting...\n *     // mid: 50; value = 123\n *     // end: 60\n *     // fin\n *\n * Yielding the result of a promise chain will wait for the entire chain to\n * complete:\n *\n *     promise.fulfilled().then(function* () {\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield flow.\n *           execute(() => console.log('A')).\n *           then(   () => console.log('B')).\n *           then(   () => 123);\n *\n *       console.log('mid: %s; value = %d', Date.now(), value);\n *\n *       yield flow.execute(() => console.log('C'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // A\n *     // B\n *     // mid: 2; value = 123\n *     // C\n *     // fin\n *\n * Yielding a _rejected_ promise will cause the rejected value to be thrown\n * within the generator function:\n *\n *     flow.execute(function* () {\n *       console.log('start: ' + Date.now());\n *       try {\n *         yield promise.delayed(10).then(function() {\n *           throw Error('boom');\n *         });\n *       } catch (ex) {\n *         console.log('caught time: ' + Date.now());\n *         console.log(ex.message);\n *       }\n *     });\n *     // start: 0\n *     // caught time: 10\n *     // boom\n *\n * # Error Handling\n *\n * ES6 promises do not require users to handle a promise rejections. This can\n * result in subtle bugs as the rejections are silently \"swallowed\" by the\n * Promise class.\n *\n *     Promise.reject(Error('boom'));\n *     // ... *crickets* ...\n *\n * Selenium's promise module, on the other hand, requires that every rejection\n * be explicitly handled. When a {@linkplain ManagedPromise ManagedPromise} is\n * rejected and no callbacks are defined on that promise, it is considered an\n * _unhandled rejection_ and reported to the active task queue. If the rejection\n * remains unhandled after a single turn of the [event loop][JSEL] (scheduled\n * with a microtask), it will propagate up the stack.\n *\n * ## Error Propagation\n *\n * If an unhandled rejection occurs within a task function, that task's promised\n * result is rejected and all remaining subtasks are discarded:\n *\n *     flow.execute(function() {\n *       // No callbacks registered on promise -> unhandled rejection\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('this will never run'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * The promised results for discarded tasks are silently rejected with a\n * cancellation error and existing callback chains will never fire.\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('a'); }).\n *           then(function() { console.log('b'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * An unhandled rejection takes precedence over a task function's returned\n * result, even if that value is another promise:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       return flow.execute(someOtherTask);\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * If there are multiple unhandled rejections within a task, they are packaged\n * in a {@link MultipleUnhandledRejectionError}, which has an `errors` property\n * that is a `Set` of the recorded unhandled rejections:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom1'));\n *       promise.rejected(Error('boom2'));\n *     }).catch(function(ex) {\n *       console.log(ex instanceof MultipleUnhandledRejectionError);\n *       for (var e of ex.errors) {\n *         console.log(e.message);\n *       }\n *     });\n *     // boom1\n *     // boom2\n *\n * When a subtask is discarded due to an unreported rejection in its parent\n * frame, the existing callbacks on that task will never settle and the\n * callbacks will not be invoked. If a new callback is attached to the subtask\n * _after_ it has been discarded, it is handled the same as adding a callback\n * to a cancelled promise: the error-callback path is invoked. This behavior is\n * intended to handle cases where the user saves a reference to a task promise,\n * as illustrated below.\n *\n *     var subTask;\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       subTask = flow.execute(function() {});\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     }).then(function() {\n *       return subTask.then(\n *           () => console.log('subtask success!'),\n *           (e) => console.log('subtask failed:\\n' + e));\n *     });\n *     // boom\n *     // subtask failed:\n *     // DiscardedTaskError: Task was discarded due to a previous failure: boom\n *\n * When a subtask fails, its promised result is treated the same as any other\n * promise: it must be handled within one turn of the rejection or the unhandled\n * rejection is propagated to the parent task. This means users can catch errors\n * from complex flows from the top level task:\n *\n *     flow.execute(function() {\n *       flow.execute(function() {\n *         flow.execute(function() {\n *           throw Error('fail!');\n *         });\n *       });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // fail!\n *\n * ## Unhandled Rejection Events\n *\n * When an unhandled rejection propagates to the root of the control flow, the\n * flow will emit an __uncaughtException__ event. If no listeners are registered\n * on the flow, the error will be rethrown to the global error handler: an\n * __uncaughtException__ event from the\n * [`process`](https://nodejs.org/api/process.html) object in node, or\n * `window.onerror` when running in a browser.\n *\n * Bottom line: you __*must*__ handle rejected promises.\n *\n * # Promises/A+ Compatibility\n *\n * This `promise` module is compliant with the [Promises/A+] specification\n * except for sections `2.2.6.1` and `2.2.6.2`:\n *\n * >\n * > - `then` may be called multiple times on the same promise.\n * >    - If/when `promise` is fulfilled, all respective `onFulfilled` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >    - If/when `promise` is rejected, all respective `onRejected` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >\n *\n * Specifically, the conformance tests contain the following scenario (for\n * brevity, only the fulfillment version is shown):\n *\n *     var p1 = Promise.resolve();\n *     p1.then(function() {\n *       console.log('A');\n *       p1.then(() => console.log('B'));\n *     });\n *     p1.then(() => console.log('C'));\n *     // A\n *     // C\n *     // B\n *\n * Since the [ControlFlow](#scheduling_callbacks) executes promise callbacks as\n * tasks, with this module, the result would be:\n *\n *     var p2 = promise.fulfilled();\n *     p2.then(function() {\n *       console.log('A');\n *       p2.then(() => console.log('B');\n *     });\n *     p2.then(() => console.log('C'));\n *     // A\n *     // B\n *     // C\n *\n * [JSEL]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\n * [GF]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n * [Promises/A+]: https://promisesaplus.com/\n * [MicrotasksArticle]: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n */\n'use strict';\n\nvar _assertThisInitialized = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _possibleConstructorReturn = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar error = require('./error');\n\nvar events = require('./events');\n\nvar logging = require('./logging');\n/**\n * Alias to help with readability and differentiate types.\n * @const\n */\n\n\nvar NativePromise = Promise;\n/**\n * Whether to append traces of `then` to rejection errors.\n * @type {boolean}\n */\n\nvar LONG_STACK_TRACES = false; // TODO: this should not be CONSTANT_CASE\n\n/** @const */\n\nvar LOG = logging.getLogger('promise');\nvar UNIQUE_IDS = new WeakMap();\nvar nextId = 1;\n\nfunction getUid(obj) {\n  var id = UNIQUE_IDS.get(obj);\n\n  if (!id) {\n    id = nextId;\n    nextId += 1;\n    UNIQUE_IDS.set(obj, id);\n  }\n\n  return id;\n}\n/**\n * Runs the given function after a microtask yield.\n * @param {function()} fn The function to run.\n */\n\n\nfunction asyncRun(fn) {\n  NativePromise.resolve().then(function () {\n    try {\n      fn();\n    } catch (ignored) {// Do nothing.\n    }\n  });\n}\n/**\n * @param {number} level What level of verbosity to log with.\n * @param {(string|function(this: T): string)} loggable The message to log.\n * @param {T=} opt_self The object in whose context to run the loggable\n *     function.\n * @template T\n */\n\n\nfunction vlog(level, loggable, opt_self) {\n  var logLevel = logging.Level.FINE;\n\n  if (level > 1) {\n    logLevel = logging.Level.FINEST;\n  } else if (level > 0) {\n    logLevel = logging.Level.FINER;\n  }\n\n  if (typeof loggable === 'function') {\n    loggable = loggable.bind(opt_self);\n  }\n\n  LOG.log(logLevel, loggable);\n}\n/**\n * Generates an error to capture the current stack trace.\n * @param {string} name Error name for this stack trace.\n * @param {string} msg Message to record.\n * @param {Function=} opt_topFn The function that should appear at the top of\n *     the stack; only applicable in V8.\n * @return {!Error} The generated error.\n */\n\n\nfunction captureStackTrace(name, msg, opt_topFn) {\n  var e = Error(msg);\n  e.name = name;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, opt_topFn);\n  } else {\n    var stack = Error().stack;\n\n    if (stack) {\n      e.stack = e.toString();\n      e.stack += '\\n' + stack;\n    }\n  }\n\n  return e;\n}\n/**\n * Error used when the computation of a promise is cancelled.\n */\n\n\nvar CancellationError = /*#__PURE__*/function (_Error) {\n  _inherits(CancellationError, _Error);\n\n  var _super = _createSuper(CancellationError);\n\n  /**\n   * @param {string=} opt_msg The cancellation message.\n   */\n  function CancellationError(opt_msg) {\n    var _this;\n\n    _classCallCheck(this, CancellationError);\n\n    _this = _super.call(this, opt_msg);\n    /** @override */\n\n    _this.name = _this.constructor.name;\n    /** @private {boolean} */\n\n    _this.silent_ = false;\n    return _this;\n  }\n  /**\n   * Wraps the given error in a CancellationError.\n   *\n   * @param {*} error The error to wrap.\n   * @param {string=} opt_msg The prefix message to use.\n   * @return {!CancellationError} A cancellation error.\n   */\n\n\n  _createClass(CancellationError, null, [{\n    key: \"wrap\",\n    value: function wrap(error, opt_msg) {\n      var message;\n\n      if (error instanceof CancellationError) {\n        return new CancellationError(opt_msg ? opt_msg + ': ' + error.message : error.message);\n      } else if (opt_msg) {\n        message = opt_msg;\n\n        if (error) {\n          message += ': ' + error;\n        }\n\n        return new CancellationError(message);\n      }\n\n      if (error) {\n        message = error + '';\n      }\n\n      return new CancellationError(message);\n    }\n  }]);\n\n  return CancellationError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Error used to cancel tasks when a control flow is reset.\n * @final\n */\n\n\nvar FlowResetError = /*#__PURE__*/function (_CancellationError) {\n  _inherits(FlowResetError, _CancellationError);\n\n  var _super2 = _createSuper(FlowResetError);\n\n  function FlowResetError() {\n    var _this2;\n\n    _classCallCheck(this, FlowResetError);\n\n    _this2 = _super2.call(this, 'ControlFlow was reset');\n    _this2.silent_ = true;\n    return _this2;\n  }\n\n  return FlowResetError;\n}(CancellationError);\n/**\n * Error used to cancel tasks that have been discarded due to an uncaught error\n * reported earlier in the control flow.\n * @final\n */\n\n\nvar DiscardedTaskError = /*#__PURE__*/function (_CancellationError2) {\n  _inherits(DiscardedTaskError, _CancellationError2);\n\n  var _super3 = _createSuper(DiscardedTaskError);\n\n  /** @param {*} error The original error. */\n  function DiscardedTaskError(error) {\n    var _this3;\n\n    _classCallCheck(this, DiscardedTaskError);\n\n    if (error instanceof DiscardedTaskError) {\n      return (\n        /** @type {!DiscardedTaskError} */\n        _possibleConstructorReturn(_this3, error)\n      );\n    }\n\n    var msg = '';\n\n    if (error) {\n      msg = ': ' + (typeof error.message === 'string' ? error.message : error);\n    }\n\n    _this3 = _super3.call(this, 'Task was discarded due to a previous failure' + msg);\n    _this3.silent_ = true;\n    return _this3;\n  }\n\n  return DiscardedTaskError;\n}(CancellationError);\n/**\n * Error used when there are multiple unhandled promise rejections detected\n * within a task or callback.\n *\n * @final\n */\n\n\nvar MultipleUnhandledRejectionError = /*#__PURE__*/function (_Error2) {\n  _inherits(MultipleUnhandledRejectionError, _Error2);\n\n  var _super4 = _createSuper(MultipleUnhandledRejectionError);\n\n  /**\n   * @param {!(Set<*>)} errors The errors to report.\n   */\n  function MultipleUnhandledRejectionError(errors) {\n    var _this4;\n\n    _classCallCheck(this, MultipleUnhandledRejectionError);\n\n    _this4 = _super4.call(this, 'Multiple unhandled promise rejections reported');\n    /** @override */\n\n    _this4.name = _this4.constructor.name;\n    /** @type {!Set<*>} */\n\n    _this4.errors = errors;\n    return _this4;\n  }\n\n  return MultipleUnhandledRejectionError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Property used to flag constructor's as implementing the Thenable interface\n * for runtime type checking.\n * @const\n */\n\n\nvar IMPLEMENTED_BY_SYMBOL = Symbol('promise.Thenable');\nvar CANCELLABLE_SYMBOL = Symbol('promise.CancellableThenable');\n/**\n * @param {function(new: ?)} ctor\n * @param {!Object} symbol\n */\n\nfunction addMarkerSymbol(ctor, symbol) {\n  try {\n    ctor.prototype[symbol] = true;\n  } catch (ignored) {// Property access denied?\n  }\n}\n/**\n * @param {*} object\n * @param {!Object} symbol\n * @return {boolean}\n */\n\n\nfunction hasMarkerSymbol(object, symbol) {\n  if (!object) {\n    return false;\n  }\n\n  try {\n    return !!object[symbol];\n  } catch (e) {\n    return false; // Property access seems to be forbidden.\n  }\n}\n/**\n * Thenable is a promise-like object with a {@code then} method which may be\n * used to schedule callbacks on a promised value.\n *\n * @record\n * @extends {IThenable<T>}\n * @template T\n */\n\n\nvar Thenable = /*#__PURE__*/function () {\n  function Thenable() {\n    _classCallCheck(this, Thenable);\n  }\n\n  _createClass(Thenable, [{\n    key: \"then\",\n\n    /**\n     * Registers listeners for when this instance is resolved.\n     *\n     * @param {?(function(T): (R|IThenable<R>))=} opt_callback The\n     *     function to call if this promise is successfully resolved. The function\n     *     should expect a single argument: the promise's resolved value.\n     * @param {?(function(*): (R|IThenable<R>))=} opt_errback\n     *     The function to call if this promise is rejected. The function should\n     *     expect a single argument: the rejection reason.\n     * @return {!Thenable<R>} A new promise which will be resolved with the result\n     *     of the invoked callback.\n     * @template R\n     */\n    value: function then(opt_callback, opt_errback) {}\n    /**\n     * Registers a listener for when this promise is rejected. This is synonymous\n     * with the {@code catch} clause in a synchronous API:\n     *\n     *     // Synchronous API:\n     *     try {\n     *       doSynchronousWork();\n     *     } catch (ex) {\n     *       console.error(ex);\n     *     }\n     *\n     *     // Asynchronous promise API:\n     *     doAsynchronousWork().catch(function(ex) {\n     *       console.error(ex);\n     *     });\n     *\n     * @param {function(*): (R|IThenable<R>)} errback The\n     *     function to call if this promise is rejected. The function should\n     *     expect a single argument: the rejection reason.\n     * @return {!Thenable<R>} A new promise which will be resolved with the result\n     *     of the invoked callback.\n     * @template R\n     */\n\n  }, {\n    key: \"catch\",\n    value: function _catch(errback) {}\n  }], [{\n    key: \"addImplementation\",\n\n    /**\n     * Adds a property to a class prototype to allow runtime checks of whether\n     * instances of that class implement the Thenable interface.\n     * @param {function(new: Thenable, ...?)} ctor The\n     *     constructor whose prototype to modify.\n     */\n    value: function addImplementation(ctor) {\n      addMarkerSymbol(ctor, IMPLEMENTED_BY_SYMBOL);\n    }\n    /**\n     * Checks if an object has been tagged for implementing the Thenable\n     * interface as defined by {@link Thenable.addImplementation}.\n     * @param {*} object The object to test.\n     * @return {boolean} Whether the object is an implementation of the Thenable\n     *     interface.\n     */\n\n  }, {\n    key: \"isImplementation\",\n    value: function isImplementation(object) {\n      return hasMarkerSymbol(object, IMPLEMENTED_BY_SYMBOL);\n    }\n  }]);\n\n  return Thenable;\n}();\n/**\n * Marker interface for objects that allow consumers to request the cancellation\n * of a promise-based operation. A cancelled promise will be rejected with a\n * {@link CancellationError}.\n *\n * This interface is considered package-private and should not be used outside\n * of selenium-webdriver.\n *\n * @interface\n * @extends {Thenable<T>}\n * @template T\n * @package\n */\n\n\nvar CancellableThenable = /*#__PURE__*/function () {\n  function CancellableThenable() {\n    _classCallCheck(this, CancellableThenable);\n  }\n\n  _createClass(CancellableThenable, [{\n    key: \"cancel\",\n\n    /**\n     * Requests the cancellation of the computation of this promise's value,\n     * rejecting the promise in the process. This method is a no-op if the promise\n     * has already been resolved.\n     *\n     * @param {(string|Error)=} opt_reason The reason this promise is being\n     *     cancelled. This value will be wrapped in a {@link CancellationError}.\n     */\n    value: function cancel(opt_reason) {}\n  }], [{\n    key: \"addImplementation\",\n\n    /**\n     * @param {function(new: CancellableThenable, ...?)} ctor\n     */\n    value: function addImplementation(ctor) {\n      Thenable.addImplementation(ctor);\n      addMarkerSymbol(ctor, CANCELLABLE_SYMBOL);\n    }\n    /**\n     * @param {*} object\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isImplementation\",\n    value: function isImplementation(object) {\n      return hasMarkerSymbol(object, CANCELLABLE_SYMBOL);\n    }\n  }]);\n\n  return CancellableThenable;\n}();\n/**\n * @enum {string}\n */\n\n\nvar PromiseState = {\n  PENDING: 'pending',\n  BLOCKED: 'blocked',\n  REJECTED: 'rejected',\n  FULFILLED: 'fulfilled'\n};\n/**\n * Internal map used to store cancellation handlers for {@link ManagedPromise}\n * objects. This is an internal implementation detail used by the\n * {@link TaskQueue} class to monitor for when a promise is cancelled without\n * generating an extra promise via then().\n *\n * @const {!WeakMap<!ManagedPromise, function(!CancellationError)>}\n */\n\nvar ON_CANCEL_HANDLER = new WeakMap();\nvar SKIP_LOG = Symbol('skip-log');\nvar FLOW_LOG = logging.getLogger('promise.ControlFlow');\n/**\n * Represents the eventual value of a completed operation. Each promise may be\n * in one of three states: pending, fulfilled, or rejected. Each promise starts\n * in the pending state and may make a single transition to either a\n * fulfilled or rejected state, at which point the promise is considered\n * resolved.\n *\n * @implements {CancellableThenable<T>}\n * @template T\n * @see http://promises-aplus.github.io/promises-spec/\n */\n\nvar ManagedPromise = /*#__PURE__*/function () {\n  /**\n   * @param {function(\n   *           function((T|IThenable<T>|Thenable)=),\n   *           function(*=))} resolver\n   *     Function that is invoked immediately to begin computation of this\n   *     promise's value. The function should accept a pair of callback\n   *     functions, one for fulfilling the promise and another for rejecting it.\n   * @param {ControlFlow=} opt_flow The control flow\n   *     this instance was created under. Defaults to the currently active flow.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  function ManagedPromise(resolver, opt_flow, opt_skipLog) {\n    _classCallCheck(this, ManagedPromise);\n\n    if (!usePromiseManager()) {\n      throw TypeError('Unable to create a managed promise instance: the promise manager has' + ' been disabled by the SELENIUM_PROMISE_MANAGER environment' + ' variable: ' + process.env['SELENIUM_PROMISE_MANAGER']);\n    } else if (opt_skipLog !== SKIP_LOG) {\n      FLOW_LOG.warning(function () {\n        var e = captureStackTrace('ManagedPromiseError', 'Creating a new managed Promise. This call will fail when the' + ' promise manager is disabled', ManagedPromise);\n        return e.stack;\n      });\n    }\n\n    getUid(this);\n    /** @private {!ControlFlow} */\n\n    this.flow_ = opt_flow || controlFlow();\n    /** @private {Error} */\n\n    this.stack_ = null;\n\n    if (LONG_STACK_TRACES) {\n      this.stack_ = captureStackTrace('ManagedPromise', 'new', this.constructor);\n    }\n    /** @private {Thenable<?>} */\n\n\n    this.parent_ = null;\n    /** @private {Array<!Task>} */\n\n    this.callbacks_ = null;\n    /** @private {PromiseState} */\n\n    this.state_ = PromiseState.PENDING;\n    /** @private {boolean} */\n\n    this.handled_ = false;\n    /** @private {*} */\n\n    this.value_ = undefined;\n    /** @private {TaskQueue} */\n\n    this.queue_ = null;\n\n    try {\n      var self = this;\n      resolver(function (value) {\n        self.resolve_(PromiseState.FULFILLED, value);\n      }, function (reason) {\n        self.resolve_(PromiseState.REJECTED, reason);\n      });\n    } catch (ex) {\n      this.resolve_(PromiseState.REJECTED, ex);\n    }\n  }\n  /**\n   * Creates a promise that is immediately resolved with the given value.\n   *\n   * @param {T=} opt_value The value to resolve.\n   * @return {!ManagedPromise<T>} A promise resolved with the given value.\n   * @template T\n   */\n\n\n  _createClass(ManagedPromise, [{\n    key: \"toString\",\n\n    /** @override */\n    value: function toString() {\n      return 'ManagedPromise::' + getUid(this) + ' {[[PromiseStatus]]: \"' + this.state_ + '\"}';\n    }\n    /**\n     * Resolves this promise. If the new value is itself a promise, this function\n     * will wait for it to be resolved before notifying the registered listeners.\n     * @param {PromiseState} newState The promise's new state.\n     * @param {*} newValue The promise's new value.\n     * @throws {TypeError} If {@code newValue === this}.\n     * @private\n     */\n\n  }, {\n    key: \"resolve_\",\n    value: function resolve_(newState, newValue) {\n      if (PromiseState.PENDING !== this.state_) {\n        return;\n      }\n\n      if (newValue === this) {\n        // See promise a+, 2.3.1\n        // http://promises-aplus.github.io/promises-spec/#point-48\n        newValue = new TypeError('A promise may not resolve to itself');\n        newState = PromiseState.REJECTED;\n      }\n\n      this.parent_ = null;\n      this.state_ = PromiseState.BLOCKED;\n\n      if (newState !== PromiseState.REJECTED) {\n        if (Thenable.isImplementation(newValue)) {\n          // 2.3.2\n          newValue =\n          /** @type {!Thenable} */\n          newValue;\n          this.parent_ = newValue;\n          newValue.then(this.unblockAndResolve_.bind(this, PromiseState.FULFILLED), this.unblockAndResolve_.bind(this, PromiseState.REJECTED));\n          return;\n        } else if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n          // 2.3.3\n          try {\n            // 2.3.3.1\n            var then = newValue['then'];\n          } catch (e) {\n            // 2.3.3.2\n            this.state_ = PromiseState.REJECTED;\n            this.value_ = e;\n            this.scheduleNotifications_();\n            return;\n          }\n\n          if (typeof then === 'function') {\n            // 2.3.3.3\n            this.invokeThen_(\n            /** @type {!Object} */\n            newValue, then);\n            return;\n          }\n        }\n      }\n\n      if (newState === PromiseState.REJECTED && isError(newValue) && newValue.stack && this.stack_) {\n        newValue.stack += '\\nFrom: ' + (this.stack_.stack || this.stack_);\n      } // 2.3.3.4 and 2.3.4\n\n\n      this.state_ = newState;\n      this.value_ = newValue;\n      this.scheduleNotifications_();\n    }\n    /**\n     * Invokes a thenable's \"then\" method according to 2.3.3.3 of the promise\n     * A+ spec.\n     * @param {!Object} x The thenable object.\n     * @param {!Function} then The \"then\" function to invoke.\n     * @private\n     */\n\n  }, {\n    key: \"invokeThen_\",\n    value: function invokeThen_(x, then) {\n      var called = false;\n      var self = this;\n\n      var resolvePromise = function resolvePromise(value) {\n        if (!called) {\n          // 2.3.3.3.3\n          called = true; // 2.3.3.3.1\n\n          self.unblockAndResolve_(PromiseState.FULFILLED, value);\n        }\n      };\n\n      var rejectPromise = function rejectPromise(reason) {\n        if (!called) {\n          // 2.3.3.3.3\n          called = true; // 2.3.3.3.2\n\n          self.unblockAndResolve_(PromiseState.REJECTED, reason);\n        }\n      };\n\n      try {\n        // 2.3.3.3\n        then.call(x, resolvePromise, rejectPromise);\n      } catch (e) {\n        // 2.3.3.3.4.2\n        rejectPromise(e);\n      }\n    }\n    /**\n     * @param {PromiseState} newState The promise's new state.\n     * @param {*} newValue The promise's new value.\n     * @private\n     */\n\n  }, {\n    key: \"unblockAndResolve_\",\n    value: function unblockAndResolve_(newState, newValue) {\n      if (this.state_ === PromiseState.BLOCKED) {\n        this.state_ = PromiseState.PENDING;\n        this.resolve_(newState, newValue);\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"scheduleNotifications_\",\n    value: function scheduleNotifications_() {\n      var _this5 = this;\n\n      vlog(2, function () {\n        return _this5 + ' scheduling notifications';\n      }, this);\n      ON_CANCEL_HANDLER.delete(this);\n\n      if (this.value_ instanceof CancellationError && this.value_.silent_) {\n        this.callbacks_ = null;\n      }\n\n      if (!this.queue_) {\n        this.queue_ = this.flow_.getActiveQueue_();\n      }\n\n      if (!this.handled_ && this.state_ === PromiseState.REJECTED && !(this.value_ instanceof CancellationError)) {\n        this.queue_.addUnhandledRejection(this);\n      }\n\n      this.queue_.scheduleCallbacks(this);\n    }\n    /** @override */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(opt_reason) {\n      if (!canCancel(this)) {\n        return;\n      }\n\n      if (this.parent_ && canCancel(this.parent_)) {\n        /** @type {!CancellableThenable} */\n        this.parent_.cancel(opt_reason);\n      } else {\n        var reason = CancellationError.wrap(opt_reason);\n        var onCancel = ON_CANCEL_HANDLER.get(this);\n\n        if (onCancel) {\n          onCancel(reason);\n          ON_CANCEL_HANDLER.delete(this);\n        }\n\n        if (this.state_ === PromiseState.BLOCKED) {\n          this.unblockAndResolve_(PromiseState.REJECTED, reason);\n        } else {\n          this.resolve_(PromiseState.REJECTED, reason);\n        }\n      }\n\n      function canCancel(promise) {\n        if (!(promise instanceof ManagedPromise)) {\n          return CancellableThenable.isImplementation(promise);\n        }\n\n        return promise.state_ === PromiseState.PENDING || promise.state_ === PromiseState.BLOCKED;\n      }\n    }\n    /** @override */\n\n  }, {\n    key: \"then\",\n    value: function then(opt_callback, opt_errback) {\n      return this.addCallback_(opt_callback, opt_errback, 'then', ManagedPromise.prototype.then);\n    }\n    /** @override */\n\n  }, {\n    key: \"catch\",\n    value: function _catch(errback) {\n      return this.addCallback_(null, errback, 'catch', ManagedPromise.prototype.catch);\n    }\n    /**\n     * @param {function(): (R|IThenable<R>)} callback\n     * @return {!ManagedPromise<R>}\n     * @template R\n     * @see ./promise.finally()\n     */\n\n  }, {\n    key: \"finally\",\n    value: function _finally(callback) {\n      var result = thenFinally(this, callback);\n      return (\n        /** @type {!ManagedPromise} */\n        result\n      );\n    }\n    /**\n     * Registers a new callback with this promise\n     * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n     *    fulfillment callback.\n     * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n     *    rejection callback.\n     * @param {string} name The callback name.\n     * @param {!Function} fn The function to use as the top of the stack when\n     *     recording the callback's creation point.\n     * @return {!ManagedPromise<R>} A new promise which will be resolved with the\n     *     result of the invoked callback.\n     * @template R\n     * @private\n     */\n\n  }, {\n    key: \"addCallback_\",\n    value: function addCallback_(callback, errback, name, fn) {\n      if (typeof callback !== 'function' && typeof errback !== 'function') {\n        return this;\n      }\n\n      this.handled_ = true;\n\n      if (this.queue_) {\n        this.queue_.clearUnhandledRejection(this);\n      }\n\n      var cb = new Task(this.flow_, this.invokeCallback_.bind(this, callback, errback), name, LONG_STACK_TRACES ? {\n        name: 'Promise',\n        top: fn\n      } : undefined);\n      cb.promise.parent_ = this;\n\n      if (this.state_ !== PromiseState.PENDING && this.state_ !== PromiseState.BLOCKED) {\n        this.flow_.getActiveQueue_().enqueue(cb);\n      } else {\n        if (!this.callbacks_) {\n          this.callbacks_ = [];\n        }\n\n        this.callbacks_.push(cb);\n        cb.blocked = true;\n        this.flow_.getActiveQueue_().enqueue(cb);\n      }\n\n      return cb.promise;\n    }\n    /**\n     * Invokes a callback function attached to this promise.\n     * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n     *    fulfillment callback.\n     * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n     *    rejection callback.\n     * @template R\n     * @private\n     */\n\n  }, {\n    key: \"invokeCallback_\",\n    value: function invokeCallback_(callback, errback) {\n      var callbackFn = callback;\n\n      if (this.state_ === PromiseState.REJECTED) {\n        callbackFn = errback;\n      }\n\n      if (typeof callbackFn === 'function') {\n        if (isGenerator(callbackFn)) {\n          return consume(callbackFn, null, this.value_);\n        }\n\n        return callbackFn(this.value_);\n      } else if (this.state_ === PromiseState.REJECTED) {\n        throw this.value_;\n      } else {\n        return this.value_;\n      }\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(opt_value) {\n      if (opt_value instanceof ManagedPromise) {\n        return opt_value;\n      }\n\n      return new ManagedPromise(function (resolve) {\n        return resolve(opt_value);\n      });\n    }\n    /**\n     * Creates a promise that is immediately rejected with the given reason.\n     *\n     * @param {*=} opt_reason The rejection reason.\n     * @return {!ManagedPromise<?>} A new rejected promise.\n     */\n\n  }, {\n    key: \"reject\",\n    value: function reject(opt_reason) {\n      return new ManagedPromise(function (_, reject) {\n        return reject(opt_reason);\n      });\n    }\n  }]);\n\n  return ManagedPromise;\n}();\n\nCancellableThenable.addImplementation(ManagedPromise);\n/**\n * @param {!ManagedPromise} promise\n * @return {boolean}\n */\n\nfunction isPending(promise) {\n  return promise.state_ === PromiseState.PENDING;\n}\n/**\n * Structural interface for a deferred promise resolver.\n * @record\n * @template T\n */\n\n\nfunction Resolver() {}\n/**\n * The promised value for this resolver.\n * @type {!Thenable<T>}\n */\n\n\nResolver.prototype.promise;\n/**\n * Resolves the promised value with the given `value`.\n * @param {T|Thenable<T>} value\n * @return {void}\n */\n\nResolver.prototype.resolve;\n/**\n * Rejects the promised value with the given `reason`.\n * @param {*} reason\n * @return {void}\n */\n\nResolver.prototype.reject;\n/**\n * Represents a value that will be resolved at some point in the future. This\n * class represents the protected \"producer\" half of a ManagedPromise - each Deferred\n * has a {@code promise} property that may be returned to consumers for\n * registering callbacks, reserving the ability to resolve the deferred to the\n * producer.\n *\n * If this Deferred is rejected and there are no listeners registered before\n * the next turn of the event loop, the rejection will be passed to the\n * {@link ControlFlow} as an unhandled failure.\n *\n * @template T\n * @implements {Resolver<T>}\n */\n\nvar Deferred =\n/**\n * @param {ControlFlow=} opt_flow The control flow this instance was\n *     created under. This should only be provided during unit tests.\n * @param {?=} opt_skipLog An internal parameter used to skip logging the\n *     creation of this promise. This parameter has no effect unless it is\n *     strictly equal to an internal symbol. In other words, this parameter\n *     is always ignored for external code.\n */\nfunction Deferred(opt_flow, opt_skipLog) {\n  _classCallCheck(this, Deferred);\n\n  var fulfill, reject;\n  /** @type {!ManagedPromise<T>} */\n\n  this.promise = new ManagedPromise(function (f, r) {\n    fulfill = f;\n    reject = r;\n  }, opt_flow, opt_skipLog);\n  var self = this;\n\n  var checkNotSelf = function checkNotSelf(value) {\n    if (value === self) {\n      throw new TypeError('May not resolve a Deferred with itself');\n    }\n  };\n  /**\n   * Resolves this deferred with the given value. It is safe to call this as a\n   * normal function (with no bound \"this\").\n   * @param {(T|IThenable<T>|Thenable)=} opt_value The fulfilled value.\n   * @const\n   */\n\n\n  this.resolve = function (opt_value) {\n    checkNotSelf(opt_value);\n    fulfill(opt_value);\n  };\n  /**\n   * An alias for {@link #resolve}.\n   * @const\n   */\n\n\n  this.fulfill = this.resolve;\n  /**\n   * Rejects this promise with the given reason. It is safe to call this as a\n   * normal function (with no bound \"this\").\n   * @param {*=} opt_reason The rejection reason.\n   * @const\n   */\n\n  this.reject = function (opt_reason) {\n    checkNotSelf(opt_reason);\n    reject(opt_reason);\n  };\n};\n/**\n * Tests if a value is an Error-like object. This is more than an straight\n * instanceof check since the value may originate from another context.\n * @param {*} value The value to test.\n * @return {boolean} Whether the value is an error.\n */\n\n\nfunction isError(value) {\n  return value instanceof Error || !!value && typeof value === 'object' && typeof value.message === 'string';\n}\n/**\n * Determines whether a {@code value} should be treated as a promise.\n * Any object whose \"then\" property is a function will be considered a promise.\n *\n * @param {?} value The value to test.\n * @return {boolean} Whether the value is a promise.\n */\n\n\nfunction isPromise(value) {\n  try {\n    // Use array notation so the Closure compiler does not obfuscate away our\n    // contract.\n    return value && (typeof value === 'object' || typeof value === 'function') && typeof value['then'] === 'function';\n  } catch (ex) {\n    return false;\n  }\n}\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Thenable} The promise.\n */\n\n\nfunction delayed(ms) {\n  return createPromise(function (resolve) {\n    setTimeout(function () {\n      return resolve();\n    }, ms);\n  });\n}\n/**\n * Creates a new deferred resolver.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@link Deferred} instance. Otherwise, it will return a resolver for a\n * {@linkplain NativePromise native promise}.\n *\n * @return {!Resolver<T>} A new deferred resolver.\n * @template T\n */\n\n\nfunction defer() {\n  if (usePromiseManager()) {\n    return new Deferred();\n  }\n\n  var resolve, reject;\n  var promise = new NativePromise(function (_resolve, _reject) {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {\n    promise: promise,\n    resolve: resolve,\n    reject: reject\n  };\n}\n/**\n * Creates a promise that has been resolved with the given value.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {T=} opt_value The resolved value.\n * @return {!Thenable<T>} The resolved promise.\n * @template T\n */\n\n\nfunction fulfilled(opt_value) {\n  var ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n\n  if (opt_value instanceof ctor) {\n    return (\n      /** @type {!Thenable} */\n      opt_value\n    );\n  }\n\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(function (resolve) {\n      return resolve(opt_value);\n    }, undefined, SKIP_LOG);\n  }\n\n  return NativePromise.resolve(opt_value);\n}\n/**\n * Creates a promise that has been rejected with the given reason.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {*=} opt_reason The rejection reason; may be any value, but is\n *     usually an Error or a string.\n * @return {!Thenable<?>} The rejected promise.\n */\n\n\nfunction rejected(opt_reason) {\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(function (_, reject) {\n      return reject(opt_reason);\n    }, undefined, SKIP_LOG);\n  }\n\n  return NativePromise.reject(opt_reason);\n}\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} var_args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\n\n\nfunction checkedNodeCall(fn, var_args) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return createPromise(function (fulfill, reject) {\n    try {\n      args.push(function (error, value) {\n        error ? reject(error) : fulfill(value);\n      });\n      fn.apply(undefined, args);\n    } catch (ex) {\n      reject(ex);\n    }\n  });\n}\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!IThenable<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\n\n\nfunction thenFinally(promise, callback) {\n  var error;\n  var mustThrow = false;\n  return promise.then(function () {\n    return callback();\n  }, function (err) {\n    error = err;\n    mustThrow = true;\n    return callback();\n  }).then(function () {\n    if (mustThrow) {\n      throw error;\n    }\n  });\n}\n/**\n * Registers an observer on a promised {@code value}, returning a new promise\n * that will be resolved when the value is. If {@code value} is not a promise,\n * then the return promise will be immediately resolved.\n * @param {*} value The value to observe.\n * @param {Function=} opt_callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n * @return {!Thenable} A new promise.\n * @deprecated Use `promise.fulfilled(value).then(opt_callback, opt_errback)`\n */\n\n\nfunction when(value, opt_callback, opt_errback) {\n  return fulfilled(value).then(opt_callback, opt_errback);\n}\n/**\n * Invokes the appropriate callback function as soon as a promised `value` is\n * resolved.\n *\n * @param {*} value The value to observe.\n * @param {Function} callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n */\n\n\nfunction asap(value, callback, opt_errback) {\n  if (isPromise(value)) {\n    value.then(callback, opt_errback);\n  } else if (callback) {\n    callback(value);\n  }\n}\n/**\n * Given an array of promises, will return a promise that will be fulfilled\n * with the fulfillment values of the input array's values. If any of the\n * input array's promises are rejected, the returned promise will be rejected\n * with the same reason.\n *\n * @param {!Array<(T|!ManagedPromise<T>)>} arr An array of\n *     promises to wait on.\n * @return {!Thenable<!Array<T>>} A promise that is\n *     fulfilled with an array containing the fulfilled values of the\n *     input array, or rejected with the same reason as the first\n *     rejected value.\n * @template T\n */\n\n\nfunction all(arr) {\n  return createPromise(function (fulfill, reject) {\n    var n = arr.length;\n    var values = [];\n\n    if (!n) {\n      fulfill(values);\n      return;\n    }\n\n    var toFulfill = n;\n\n    var onFulfilled = function onFulfilled(index, value) {\n      values[index] = value;\n      toFulfill--;\n\n      if (toFulfill == 0) {\n        fulfill(values);\n      }\n    };\n\n    function processPromise(index) {\n      asap(arr[index], function (value) {\n        onFulfilled(index, value);\n      }, reject);\n    }\n\n    for (var i = 0; i < n; ++i) {\n      processPromise(i);\n    }\n  });\n}\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\n\n\nfunction map(arr, fn, opt_self) {\n  return createPromise(function (resolve) {\n    return resolve(arr);\n  }).then(function (v) {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n\n    var arr =\n    /** @type {!Array} */\n    v;\n    return createPromise(function (fulfill, reject) {\n      var n = arr.length;\n      var values = new Array(n);\n\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n\n        try {\n          asap(fn.call(opt_self, arr[i], i,\n          /** @type {!Array} */\n          arr), function (value) {\n            values[i] = value;\n            processNext(i + 1);\n          }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|ManagedPromise<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\n\n\nfunction filter(arr, fn, opt_self) {\n  return createPromise(function (resolve) {\n    return resolve(arr);\n  }).then(function (v) {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n\n    var arr =\n    /** @type {!Array} */\n    v;\n    return createPromise(function (fulfill, reject) {\n      var n = arr.length;\n      var values = [];\n      var valuesLength = 0;\n\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n\n        try {\n          var value = arr[i];\n          var include = fn.call(opt_self, value, i,\n          /** @type {!Array} */\n          arr);\n          asap(include, function (include) {\n            if (include) {\n              values[valuesLength++] = value;\n            }\n\n            processNext(i + 1);\n          }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\n\n\nfunction fullyResolved(value) {\n  if (isPromise(value)) {\n    return fulfilled(value).then(fullyResolveValue);\n  }\n\n  return fullyResolveValue(value);\n}\n/**\n * @param {*} value The value to fully resolve. If a promise, assumed to\n *     already be resolved.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\n\n\nfunction fullyResolveValue(value) {\n  if (Array.isArray(value)) {\n    return fullyResolveKeys(\n    /** @type {!Array} */\n    value);\n  }\n\n  if (isPromise(value)) {\n    if (isPromise(value)) {\n      // We get here when the original input value is a promise that\n      // resolves to itself. When the user provides us with such a promise,\n      // trust that it counts as a \"fully resolved\" value and return it.\n      // Of course, since it's already a promise, we can just return it\n      // to the user instead of wrapping it in another promise.\n      return (\n        /** @type {!ManagedPromise} */\n        value\n      );\n    }\n  }\n\n  if (value && typeof value === 'object') {\n    return fullyResolveKeys(\n    /** @type {!Object} */\n    value);\n  }\n\n  if (typeof value === 'function') {\n    return fullyResolveKeys(\n    /** @type {!Object} */\n    value);\n  }\n\n  return createPromise(function (resolve) {\n    return resolve(value);\n  });\n}\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\n\n\nfunction fullyResolveKeys(obj) {\n  var isArray = Array.isArray(obj);\n  var numKeys = isArray ? obj.length : function () {\n    var n = 0;\n\n    for (var key in obj) {\n      n += 1;\n    }\n\n    return n;\n  }();\n\n  if (!numKeys) {\n    return createPromise(function (resolve) {\n      return resolve(obj);\n    });\n  }\n\n  function forEachProperty(obj, fn) {\n    for (var key in obj) {\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n\n  function forEachElement(arr, fn) {\n    arr.forEach(fn);\n  }\n\n  var numResolved = 0;\n  return createPromise(function (fulfill, reject) {\n    var forEachKey = isArray ? forEachElement : forEachProperty;\n    forEachKey(obj, function (partialValue, key) {\n      if (!Array.isArray(partialValue) && (!partialValue || typeof partialValue !== 'object')) {\n        maybeResolveValue();\n        return;\n      }\n\n      fullyResolved(partialValue).then(function (resolvedValue) {\n        obj[key] = resolvedValue;\n        maybeResolveValue();\n      }, reject);\n    });\n\n    function maybeResolveValue() {\n      if (++numResolved == numKeys) {\n        fulfill(obj);\n      }\n    }\n  });\n} //////////////////////////////////////////////////////////////////////////////\n//\n//  ControlFlow\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Defines methods for coordinating the execution of asynchronous tasks.\n * @record\n */\n\n\nvar Scheduler = /*#__PURE__*/function () {\n  function Scheduler() {\n    _classCallCheck(this, Scheduler);\n  }\n\n  _createClass(Scheduler, [{\n    key: \"execute\",\n\n    /**\n     * Schedules a task for execution. If the task function is a generator, the\n     * task will be executed using {@link ./promise.consume consume()}.\n     *\n     * @param {function(): (T|IThenable<T>)} fn The function to call to start the\n     *     task.\n     * @param {string=} opt_description A description of the task for debugging\n     *     purposes.\n     * @return {!Thenable<T>} A promise that will be resolved with the task\n     *     result.\n     * @template T\n     */\n    value: function execute(fn, opt_description) {}\n    /**\n     * Creates a new promise using the given resolver function.\n     *\n     * @param {function(\n     *             function((T|IThenable<T>|Thenable|null)=),\n     *             function(*=))} resolver\n     * @return {!Thenable<T>}\n     * @template T\n     */\n\n  }, {\n    key: \"promise\",\n    value: function promise(resolver) {}\n    /**\n     * Schedules a `setTimeout` call.\n     *\n     * @param {number} ms The timeout delay, in milliseconds.\n     * @param {string=} opt_description A description to accompany the timeout.\n     * @return {!Thenable<void>} A promise that will be resolved when the timeout\n     *     fires.\n     */\n\n  }, {\n    key: \"timeout\",\n    value: function timeout(ms, opt_description) {}\n    /**\n     * Schedules a task to wait for a condition to hold.\n     *\n     * If the condition is defined as a function, it may return any value. Promise\n     * will be resolved before testing if the condition holds (resolution time\n     * counts towards the timeout). Once resolved, values are always evaluated as\n     * booleans.\n     *\n     * If the condition function throws, or returns a rejected promise, the\n     * wait task will fail.\n     *\n     * If the condition is defined as a promise, the scheduler will wait for it to\n     * settle. If the timeout expires before the promise settles, the promise\n     * returned by this function will be rejected.\n     *\n     * If this function is invoked with `timeout === 0`, or the timeout is\n     * omitted, this scheduler will wait indefinitely for the condition to be\n     * satisfied.\n     *\n     * @param {(!IThenable<T>|function())} condition The condition to poll,\n     *     or a promise to wait on.\n     * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n     *     condition to hold before timing out. If omitted, the flow will wait\n     *     indefinitely.\n     * @param {string=} opt_message An optional error message to include if the\n     *     wait times out; defaults to the empty string.\n     * @return {!Thenable<T>} A promise that will be fulfilled\n     *     when the condition has been satisfied. The promise shall be rejected\n     *     if the wait times out waiting for the condition.\n     * @throws {TypeError} If condition is not a function or promise or if timeout\n     *     is not a number >= 0.\n     * @template T\n     */\n\n  }, {\n    key: \"wait\",\n    value: function wait(condition, opt_timeout, opt_message) {}\n  }]);\n\n  return Scheduler;\n}();\n\nvar USE_PROMISE_MANAGER;\n\nfunction usePromiseManager() {\n  if (typeof USE_PROMISE_MANAGER !== 'undefined') {\n    return !!USE_PROMISE_MANAGER;\n  }\n\n  return process.env['SELENIUM_PROMISE_MANAGER'] === undefined || !/^0|false$/i.test(process.env['SELENIUM_PROMISE_MANAGER']);\n}\n/**\n * Creates a new promise with the given `resolver` function. If the promise\n * manager is currently enabled, the returned promise will be a\n * {@linkplain ManagedPromise} instance. Otherwise, it will be a native promise.\n *\n * @param {function(\n *             function((T|IThenable<T>|Thenable|null)=),\n *             function(*=))} resolver\n * @return {!Thenable<T>}\n * @template T\n */\n\n\nfunction createPromise(resolver) {\n  var ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  return new ctor(resolver);\n}\n/**\n * @param {!Scheduler} scheduler The scheduler to use.\n * @param {(!IThenable<T>|function())} condition The condition to poll,\n *     or a promise to wait on.\n * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n *     condition to hold before timing out. If omitted, the flow will wait\n *     indefinitely.\n * @param {string=} opt_message An optional error message to include if the\n *     wait times out; defaults to the empty string.\n * @return {!Thenable<T>} A promise that will be fulfilled\n *     when the condition has been satisfied. The promise shall be rejected\n *     if the wait times out waiting for the condition.\n * @throws {TypeError} If condition is not a function or promise or if timeout\n *     is not a number >= 0.\n * @template T\n */\n\n\nfunction scheduleWait(scheduler, condition, opt_timeout, opt_message) {\n  var timeout = opt_timeout || 0;\n\n  if (typeof timeout !== 'number' || timeout < 0) {\n    throw TypeError('timeout must be a number >= 0: ' + timeout);\n  }\n\n  if (isPromise(condition)) {\n    return scheduler.execute(function () {\n      if (!timeout) {\n        return condition;\n      }\n\n      return scheduler.promise(function (fulfill, reject) {\n        var start = Date.now();\n        var timer = setTimeout(function () {\n          timer = null;\n          reject(new error.TimeoutError((opt_message ? opt_message + '\\n' : '') + 'Timed out waiting for promise to resolve after ' + (Date.now() - start) + 'ms'));\n        }, timeout);\n        /** @type {Thenable} */\n\n        condition.then(function (value) {\n          timer && clearTimeout(timer);\n          fulfill(value);\n        }, function (error) {\n          timer && clearTimeout(timer);\n          reject(error);\n        });\n      });\n    }, opt_message || '<anonymous wait: promise resolution>');\n  }\n\n  if (typeof condition !== 'function') {\n    throw TypeError('Invalid condition; must be a function or promise: ' + typeof condition);\n  }\n\n  if (isGenerator(condition)) {\n    var original = condition;\n\n    condition = function condition() {\n      return consume(original);\n    };\n  }\n\n  return scheduler.execute(function () {\n    var startTime = Date.now();\n    return scheduler.promise(function (fulfill, reject) {\n      pollCondition();\n\n      function pollCondition() {\n        var conditionFn =\n        /** @type {function()} */\n        condition;\n        scheduler.execute(conditionFn).then(function (value) {\n          var elapsed = Date.now() - startTime;\n\n          if (!!value) {\n            fulfill(value);\n          } else if (timeout && elapsed >= timeout) {\n            reject(new error.TimeoutError((opt_message ? opt_message + '\\n' : '') + \"Wait timed out after \".concat(elapsed, \"ms\")));\n          } else {\n            // Do not use asyncRun here because we need a non-micro yield\n            // here so the UI thread is given a chance when running in a\n            // browser.\n            setTimeout(pollCondition, 0);\n          }\n        }, reject);\n      }\n    });\n  }, opt_message || '<anonymous wait>');\n}\n/**\n * A scheduler that executes all tasks immediately, with no coordination. This\n * class is an event emitter for API compatibility with the {@link ControlFlow},\n * however, it emits no events.\n *\n * @implements {Scheduler}\n */\n\n\nvar SimpleScheduler = /*#__PURE__*/function (_events$EventEmitter) {\n  _inherits(SimpleScheduler, _events$EventEmitter);\n\n  var _super5 = _createSuper(SimpleScheduler);\n\n  function SimpleScheduler() {\n    _classCallCheck(this, SimpleScheduler);\n\n    return _super5.apply(this, arguments);\n  }\n\n  _createClass(SimpleScheduler, [{\n    key: \"execute\",\n\n    /** @override */\n    value: function execute(fn) {\n      return this.promise(function (resolve, reject) {\n        try {\n          if (isGenerator(fn)) {\n            consume(fn).then(resolve, reject);\n          } else {\n            resolve(fn.call(undefined));\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      });\n    }\n    /** @override */\n\n  }, {\n    key: \"promise\",\n    value: function promise(resolver) {\n      return new NativePromise(resolver);\n    }\n    /** @override */\n\n  }, {\n    key: \"timeout\",\n    value: function timeout(ms) {\n      return this.promise(function (resolve) {\n        return setTimeout(function (_) {\n          return resolve();\n        }, ms);\n      });\n    }\n    /** @override */\n\n  }, {\n    key: \"wait\",\n    value: function wait(condition, opt_timeout, opt_message) {\n      return scheduleWait(this, condition, opt_timeout, opt_message);\n    }\n  }]);\n\n  return SimpleScheduler;\n}(events.EventEmitter);\n\nvar SIMPLE_SCHEDULER = new SimpleScheduler();\n/**\n * Handles the execution of scheduled tasks, each of which may be an\n * asynchronous operation. The control flow will ensure tasks are executed in\n * the order scheduled, starting each task only once those before it have\n * completed.\n *\n * Each task scheduled within this flow may return a {@link ManagedPromise} to\n * indicate it is an asynchronous operation. The ControlFlow will wait for such\n * promises to be resolved before marking the task as completed.\n *\n * Tasks and each callback registered on a {@link ManagedPromise} will be run\n * in their own ControlFlow frame. Any tasks scheduled within a frame will take\n * priority over previously scheduled tasks. Furthermore, if any of the tasks in\n * the frame fail, the remainder of the tasks in that frame will be discarded\n * and the failure will be propagated to the user through the callback/task's\n * promised result.\n *\n * Each time a ControlFlow empties its task queue, it will fire an\n * {@link ControlFlow.EventType.IDLE IDLE} event. Conversely, whenever\n * the flow terminates due to an unhandled error, it will remove all\n * remaining tasks in its queue and fire an\n * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION UNCAUGHT_EXCEPTION} event.\n * If there are no listeners registered with the flow, the error will be\n * rethrown to the global error handler.\n *\n * Refer to the {@link ./promise} module documentation for a detailed\n * explanation of how the ControlFlow coordinates task execution.\n *\n * @implements {Scheduler}\n * @final\n */\n\nvar ControlFlow = /*#__PURE__*/function (_events$EventEmitter2) {\n  _inherits(ControlFlow, _events$EventEmitter2);\n\n  var _super6 = _createSuper(ControlFlow);\n\n  function ControlFlow() {\n    var _this6;\n\n    _classCallCheck(this, ControlFlow);\n\n    if (!usePromiseManager()) {\n      throw TypeError('Cannot instantiate control flow when the promise manager has' + ' been disabled');\n    }\n\n    _this6 = _super6.call(this);\n    /** @private {boolean} */\n\n    _this6.propagateUnhandledRejections_ = true;\n    /** @private {TaskQueue} */\n\n    _this6.activeQueue_ = null;\n    /** @private {Set<TaskQueue>} */\n\n    _this6.taskQueues_ = null;\n    /**\n     * Microtask that controls shutting down the control flow. Upon shut down,\n     * the flow will emit an\n     * {@link ControlFlow.EventType.IDLE} event. Idle events\n     * always follow a brief timeout in order to catch latent errors from the\n     * last completed task. If this task had a callback registered, but no\n     * errback, and the task fails, the unhandled failure would not be reported\n     * by the promise system until the next turn of the event loop:\n     *\n     *   // Schedule 1 task that fails.\n     *   var result = promise.controlFlow().execute(\n     *       () => promise.rejected('failed'), 'example');\n     *   // Set a callback on the result. This delays reporting the unhandled\n     *   // failure for 1 turn of the event loop.\n     *   result.then(function() {});\n     *\n     * @private {MicroTask}\n     */\n\n    _this6.shutdownTask_ = null;\n    /**\n     * ID for a long running interval used to keep a Node.js process running\n     * while a control flow's event loop is still working. This is a cheap hack\n     * required since JS events are only scheduled to run when there is\n     * _actually_ something to run. When a control flow is waiting on a task,\n     * there will be nothing in the JS event loop and the process would\n     * terminate without this.\n     * @private\n     */\n\n    _this6.hold_ = null;\n    return _this6;\n  }\n  /**\n   * Returns a string representation of this control flow, which is its current\n   * {@linkplain #getSchedule() schedule}, sans task stack traces.\n   * @return {string} The string representation of this control flow.\n   * @override\n   */\n\n\n  _createClass(ControlFlow, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.getSchedule();\n    }\n    /**\n     * Sets whether any unhandled rejections should propagate up through the\n     * control flow stack and cause rejections within parent tasks. If error\n     * propagation is disabled, tasks will not be aborted when an unhandled\n     * promise rejection is detected, but the rejection _will_ trigger an\n     * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n     *\n     * The default behavior is to propagate all unhandled rejections. _The use\n     * of this option is highly discouraged._\n     *\n     * @param {boolean} propagate whether to propagate errors.\n     */\n\n  }, {\n    key: \"setPropagateUnhandledRejections\",\n    value: function setPropagateUnhandledRejections(propagate) {\n      this.propagateUnhandledRejections_ = propagate;\n    }\n    /**\n     * @return {boolean} Whether this flow is currently idle.\n     */\n\n  }, {\n    key: \"isIdle\",\n    value: function isIdle() {\n      return !this.shutdownTask_ && (!this.taskQueues_ || !this.taskQueues_.size);\n    }\n    /**\n     * Resets this instance, clearing its queue and removing all event listeners.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.cancelQueues_(new FlowResetError());\n      this.emit(ControlFlow.EventType.RESET);\n      this.removeAllListeners();\n      this.cancelShutdown_();\n    }\n    /**\n     * Generates an annotated string describing the internal state of this control\n     * flow, including the currently executing as well as pending tasks. If\n     * {@code opt_includeStackTraces === true}, the string will include the\n     * stack trace from when each task was scheduled.\n     * @param {string=} opt_includeStackTraces Whether to include the stack traces\n     * from when each task was scheduled. Defaults to false.\n     * @return {string} String representation of this flow's internal state.\n     */\n\n  }, {\n    key: \"getSchedule\",\n    value: function getSchedule(opt_includeStackTraces) {\n      var ret = 'ControlFlow::' + getUid(this);\n      var activeQueue = this.activeQueue_;\n\n      if (!this.taskQueues_ || !this.taskQueues_.size) {\n        return ret;\n      }\n\n      var childIndent = '| ';\n\n      var _iterator = _createForOfIteratorHelper(this.taskQueues_),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var q = _step.value;\n          ret += '\\n' + printQ(q, childIndent);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return ret;\n\n      function printQ(q, indent) {\n        var ret = q.toString();\n\n        if (q === activeQueue) {\n          ret = '(active) ' + ret;\n        }\n\n        var prefix = indent + childIndent;\n\n        if (q.pending_) {\n          if (q.pending_.q.state_ !== TaskQueueState.FINISHED) {\n            ret += '\\n' + prefix + '(pending) ' + q.pending_.task;\n            ret += '\\n' + printQ(q.pending_.q, prefix + childIndent);\n          } else {\n            ret += '\\n' + prefix + '(blocked) ' + q.pending_.task;\n          }\n        }\n\n        if (q.interrupts_) {\n          q.interrupts_.forEach(function (task) {\n            ret += '\\n' + prefix + task;\n          });\n        }\n\n        if (q.tasks_) {\n          q.tasks_.forEach(function (task) {\n            return ret += printTask(task, '\\n' + prefix);\n          });\n        }\n\n        return indent + ret;\n      }\n\n      function printTask(task, prefix) {\n        var ret = prefix + task;\n\n        if (opt_includeStackTraces && task.promise.stack_) {\n          ret += prefix + childIndent + (task.promise.stack_.stack || task.promise.stack_).replace(/\\n/g, prefix);\n        }\n\n        return ret;\n      }\n    }\n    /**\n     * Returns the currently active task queue for this flow. If there is no\n     * active queue, one will be created.\n     * @return {!TaskQueue} the currently active task queue for this flow.\n     * @private\n     */\n\n  }, {\n    key: \"getActiveQueue_\",\n    value: function getActiveQueue_() {\n      var _this7 = this;\n\n      if (this.activeQueue_) {\n        return this.activeQueue_;\n      }\n\n      this.activeQueue_ = new TaskQueue(this);\n\n      if (!this.taskQueues_) {\n        this.taskQueues_ = new Set();\n      }\n\n      this.taskQueues_.add(this.activeQueue_);\n      this.activeQueue_.once('end', this.onQueueEnd_, this).once('error', this.onQueueError_, this);\n      asyncRun(function () {\n        return _this7.activeQueue_ = null;\n      });\n      this.activeQueue_.start();\n      return this.activeQueue_;\n    }\n    /** @override */\n\n  }, {\n    key: \"execute\",\n    value: function execute(fn, opt_description) {\n      if (isGenerator(fn)) {\n        var original = fn;\n\n        fn = function fn() {\n          return consume(original);\n        };\n      }\n\n      if (!this.hold_) {\n        var holdIntervalMs = 2147483647; // 2^31-1; max timer length for Node.js\n\n        this.hold_ = setInterval(function () {}, holdIntervalMs);\n      }\n\n      var task = new Task(this, fn, opt_description || '<anonymous>', {\n        name: 'Task',\n        top: ControlFlow.prototype.execute\n      }, true);\n      var q = this.getActiveQueue_();\n\n      var _loop = function _loop(i) {\n        var previousTask = q.tasks_[i - 1];\n\n        if (previousTask.userTask_) {\n          FLOW_LOG.warning(function () {\n            return \"Detected scheduling of an unchained task.\\nWhen the promise manager is disabled, unchained tasks will not wait for\\npreviously scheduled tasks to finish before starting to execute.\\nNew task: \".concat(task.promise.stack_.stack, \"\\nPrevious task: \").concat(previousTask.promise.stack_.stack).split(/\\n/).join('\\n    ');\n          });\n          return \"break\";\n        }\n      };\n\n      for (var i = q.tasks_.length; i > 0; i--) {\n        var _ret = _loop(i);\n\n        if (_ret === \"break\") break;\n      }\n\n      q.enqueue(task);\n      this.emit(ControlFlow.EventType.SCHEDULE_TASK, task.description);\n      return task.promise;\n    }\n    /** @override */\n\n  }, {\n    key: \"promise\",\n    value: function promise(resolver) {\n      return new ManagedPromise(resolver, this, SKIP_LOG);\n    }\n    /** @override */\n\n  }, {\n    key: \"timeout\",\n    value: function timeout(ms, opt_description) {\n      var _this8 = this;\n\n      return this.execute(function () {\n        return _this8.promise(function (resolve) {\n          return setTimeout(function () {\n            return resolve();\n          }, ms);\n        });\n      }, opt_description);\n    }\n    /** @override */\n\n  }, {\n    key: \"wait\",\n    value: function wait(condition, opt_timeout, opt_message) {\n      return scheduleWait(this, condition, opt_timeout, opt_message);\n    }\n    /**\n     * Executes a function in the next available turn of the JavaScript event\n     * loop. This ensures the function runs with its own task queue and any\n     * scheduled tasks will run in \"parallel\" to those scheduled in the current\n     * function.\n     *\n     *     flow.execute(() => console.log('a'));\n     *     flow.execute(() => console.log('b'));\n     *     flow.execute(() => console.log('c'));\n     *     flow.async(() => {\n     *        flow.execute(() => console.log('d'));\n     *        flow.execute(() => console.log('e'));\n     *     });\n     *     flow.async(() => {\n     *        flow.execute(() => console.log('f'));\n     *        flow.execute(() => console.log('g'));\n     *     });\n     *     flow.once('idle', () => console.log('fin'));\n     *     // a\n     *     // d\n     *     // f\n     *     // b\n     *     // e\n     *     // g\n     *     // c\n     *     // fin\n     *\n     * If the function itself throws, the error will be treated the same as an\n     * unhandled rejection within the control flow.\n     *\n     * __NOTE__: This function is considered _unstable_.\n     *\n     * @param {!Function} fn The function to execute.\n     * @param {Object=} opt_self The object in whose context to run the function.\n     * @param {...*} var_args Any arguments to pass to the function.\n     */\n\n  }, {\n    key: \"async\",\n    value: function async(fn, opt_self, var_args) {\n      var _this9 = this;\n\n      asyncRun(function () {\n        // Clear any lingering queues, forces getActiveQueue_ to create a new one.\n        _this9.activeQueue_ = null;\n\n        var q = _this9.getActiveQueue_();\n\n        try {\n          q.execute_(fn.bind(opt_self, var_args));\n        } catch (ex) {\n          var cancellationError = CancellationError.wrap(ex, 'Function passed to ControlFlow.async() threw');\n          cancellationError.silent_ = true;\n          q.abort_(cancellationError);\n        } finally {\n          _this9.activeQueue_ = null;\n        }\n      });\n    }\n    /**\n     * Event handler for when a task queue is exhausted. This starts the shutdown\n     * sequence for this instance if there are no remaining task queues: after\n     * one turn of the event loop, this object will emit the\n     * {@link ControlFlow.EventType.IDLE IDLE} event to signal\n     * listeners that it has completed. During this wait, if another task is\n     * scheduled, the shutdown will be aborted.\n     *\n     * @param {!TaskQueue} q the completed task queue.\n     * @private\n     */\n\n  }, {\n    key: \"onQueueEnd_\",\n    value: function onQueueEnd_(q) {\n      var _this10 = this;\n\n      if (!this.taskQueues_) {\n        return;\n      }\n\n      this.taskQueues_.delete(q);\n      vlog(1, function () {\n        return q + ' has finished';\n      });\n      vlog(1, function () {\n        return _this10.taskQueues_.size + ' queues remain\\n' + _this10;\n      }, this);\n\n      if (!this.taskQueues_.size) {\n        if (this.shutdownTask_) {\n          throw Error('Already have a shutdown task??');\n        }\n\n        vlog(1, function () {\n          return 'Scheduling shutdown\\n' + _this10;\n        });\n        this.shutdownTask_ = new MicroTask(function () {\n          return _this10.shutdown_();\n        });\n      }\n    }\n    /**\n     * Event handler for when a task queue terminates with an error. This triggers\n     * the cancellation of all other task queues and a\n     * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n     * If there are no error event listeners registered with this instance, the\n     * error will be rethrown to the global error handler.\n     *\n     * @param {*} error the error that caused the task queue to terminate.\n     * @param {!TaskQueue} q the task queue.\n     * @private\n     */\n\n  }, {\n    key: \"onQueueError_\",\n    value: function onQueueError_(error, q) {\n      var _this11 = this;\n\n      if (this.taskQueues_) {\n        this.taskQueues_.delete(q);\n      }\n\n      this.cancelQueues_(CancellationError.wrap(error, 'There was an uncaught error in the control flow'));\n      this.cancelShutdown_();\n      this.cancelHold_();\n      setTimeout(function () {\n        var listeners = _this11.listeners(ControlFlow.EventType.UNCAUGHT_EXCEPTION);\n\n        if (!listeners.size) {\n          throw error;\n        } else {\n          _this11.reportUncaughtException_(error);\n        }\n      }, 0);\n    }\n    /**\n     * Cancels all remaining task queues.\n     * @param {!CancellationError} reason The cancellation reason.\n     * @private\n     */\n\n  }, {\n    key: \"cancelQueues_\",\n    value: function cancelQueues_(reason) {\n      reason.silent_ = true;\n\n      if (this.taskQueues_) {\n        var _iterator2 = _createForOfIteratorHelper(this.taskQueues_),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var q = _step2.value;\n            q.removeAllListeners();\n            q.abort_(reason);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        this.taskQueues_.clear();\n        this.taskQueues_ = null;\n      }\n    }\n    /**\n     * Reports an uncaught exception using a\n     * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n     *\n     * @param {*} e the error to report.\n     * @private\n     */\n\n  }, {\n    key: \"reportUncaughtException_\",\n    value: function reportUncaughtException_(e) {\n      this.emit(ControlFlow.EventType.UNCAUGHT_EXCEPTION, e);\n    }\n    /** @private */\n\n  }, {\n    key: \"cancelHold_\",\n    value: function cancelHold_() {\n      if (this.hold_) {\n        clearInterval(this.hold_);\n        this.hold_ = null;\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"shutdown_\",\n    value: function shutdown_() {\n      var _this12 = this;\n\n      vlog(1, function () {\n        return 'Going idle: ' + _this12;\n      });\n      this.cancelHold_();\n      this.shutdownTask_ = null;\n      this.emit(ControlFlow.EventType.IDLE);\n    }\n    /**\n     * Cancels the shutdown sequence if it is currently scheduled.\n     * @private\n     */\n\n  }, {\n    key: \"cancelShutdown_\",\n    value: function cancelShutdown_() {\n      if (this.shutdownTask_) {\n        this.shutdownTask_.cancel();\n        this.shutdownTask_ = null;\n      }\n    }\n  }]);\n\n  return ControlFlow;\n}(events.EventEmitter);\n/**\n * Events that may be emitted by an {@link ControlFlow}.\n * @enum {string}\n */\n\n\nControlFlow.EventType = {\n  /** Emitted when all tasks have been successfully executed. */\n  IDLE: 'idle',\n\n  /** Emitted when a ControlFlow has been reset. */\n  RESET: 'reset',\n\n  /** Emitted whenever a new task has been scheduled. */\n  SCHEDULE_TASK: 'scheduleTask',\n\n  /**\n   * Emitted whenever a control flow aborts due to an unhandled promise\n   * rejection. This event will be emitted along with the offending rejection\n   * reason. Upon emitting this event, the control flow will empty its task\n   * queue and revert to its initial state.\n   */\n  UNCAUGHT_EXCEPTION: 'uncaughtException'\n};\n/**\n * Wraps a function to execute as a cancellable micro task.\n * @final\n */\n\nvar MicroTask = /*#__PURE__*/function () {\n  /**\n   * @param {function()} fn The function to run as a micro task.\n   */\n  function MicroTask(fn) {\n    var _this13 = this;\n\n    _classCallCheck(this, MicroTask);\n\n    /** @private {boolean} */\n    this.cancelled_ = false;\n    asyncRun(function () {\n      if (!_this13.cancelled_) {\n        fn();\n      }\n    });\n  }\n  /**\n   * Runs the given function after a microtask yield.\n   * @param {function()} fn The function to run.\n   */\n\n\n  _createClass(MicroTask, [{\n    key: \"cancel\",\n\n    /**\n     * Cancels the execution of this task. Note: this will not prevent the task\n     * timer from firing, just the invocation of the wrapped function.\n     */\n    value: function cancel() {\n      this.cancelled_ = true;\n    }\n  }], [{\n    key: \"run\",\n    value: function run(fn) {\n      NativePromise.resolve().then(function () {\n        try {\n          fn();\n        } catch (ignored) {// Do nothing.\n        }\n      });\n    }\n  }]);\n\n  return MicroTask;\n}();\n/**\n * A task to be executed by a {@link ControlFlow}.\n *\n * @template T\n * @final\n */\n\n\nvar Task = /*#__PURE__*/function (_Deferred) {\n  _inherits(Task, _Deferred);\n\n  var _super7 = _createSuper(Task);\n\n  /**\n   * @param {!ControlFlow} flow The flow this instances belongs\n   *     to.\n   * @param {function(): (T|!ManagedPromise<T>)} fn The function to\n   *     call when the task executes. If it returns a\n   *     {@link ManagedPromise}, the flow will wait for it to be\n   *     resolved before starting the next task.\n   * @param {string} description A description of the task for debugging.\n   * @param {{name: string, top: !Function}=} opt_stackOptions Options to use\n   *     when capturing the stacktrace for when this task was created.\n   * @param {boolean=} opt_isUserTask Whether this task was explicitly scheduled\n   *     by the use of the promise manager.\n   */\n  function Task(flow, fn, description, opt_stackOptions, opt_isUserTask) {\n    var _this14;\n\n    _classCallCheck(this, Task);\n\n    _this14 = _super7.call(this, flow, SKIP_LOG);\n    getUid(_assertThisInitialized(_this14));\n    /** @type {function(): (T|!ManagedPromise<T>)} */\n\n    _this14.execute = fn;\n    /** @type {string} */\n\n    _this14.description = description;\n    /** @type {TaskQueue} */\n\n    _this14.queue = null;\n    /** @private @const {boolean} */\n\n    _this14.userTask_ = !!opt_isUserTask;\n    /**\n     * Whether this task is considered block. A blocked task may be registered\n     * in a task queue, but will be dropped if it is still blocked when it\n     * reaches the front of the queue. A dropped task may always be rescheduled.\n     *\n     * Blocked tasks are used when a callback is attached to an unsettled\n     * promise to reserve a spot in line (in a manner of speaking). If the\n     * promise is not settled before the callback reaches the front of the\n     * of the queue, it will be dropped. Once the promise is settled, the\n     * dropped task will be rescheduled as an interrupt on the currently task\n     * queue.\n     *\n     * @type {boolean}\n     */\n\n    _this14.blocked = false;\n\n    if (opt_stackOptions) {\n      _this14.promise.stack_ = captureStackTrace(opt_stackOptions.name, _this14.description, opt_stackOptions.top);\n    }\n\n    return _this14;\n  }\n  /** @override */\n\n\n  _createClass(Task, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'Task::' + getUid(this) + '<' + this.description + '>';\n    }\n  }]);\n\n  return Task;\n}(Deferred);\n/** @enum {string} */\n\n\nvar TaskQueueState = {\n  NEW: 'new',\n  STARTED: 'started',\n  FINISHED: 'finished'\n};\n/**\n * @final\n */\n\nvar TaskQueue = /*#__PURE__*/function (_events$EventEmitter3) {\n  _inherits(TaskQueue, _events$EventEmitter3);\n\n  var _super8 = _createSuper(TaskQueue);\n\n  /** @param {!ControlFlow} flow . */\n  function TaskQueue(flow) {\n    var _this15;\n\n    _classCallCheck(this, TaskQueue);\n\n    _this15 = _super8.call(this);\n    /** @private {string} */\n\n    _this15.name_ = 'TaskQueue::' + getUid(_assertThisInitialized(_this15));\n    /** @private {!ControlFlow} */\n\n    _this15.flow_ = flow;\n    /** @private {!Array<!Task>} */\n\n    _this15.tasks_ = [];\n    /** @private {Array<!Task>} */\n\n    _this15.interrupts_ = null;\n    /** @private {({task: !Task, q: !TaskQueue}|null)} */\n\n    _this15.pending_ = null;\n    /** @private {TaskQueue} */\n\n    _this15.subQ_ = null;\n    /** @private {TaskQueueState} */\n\n    _this15.state_ = TaskQueueState.NEW;\n    /** @private {!Set<!ManagedPromise>} */\n\n    _this15.unhandledRejections_ = new Set();\n    return _this15;\n  }\n  /** @override */\n\n\n  _createClass(TaskQueue, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'TaskQueue::' + getUid(this);\n    }\n    /**\n     * @param {!ManagedPromise} promise .\n     */\n\n  }, {\n    key: \"addUnhandledRejection\",\n    value: function addUnhandledRejection(promise) {\n      var _this16 = this;\n\n      // TODO: node 4.0.0+\n      vlog(2, function () {\n        return _this16 + ' registering unhandled rejection: ' + promise;\n      }, this);\n      this.unhandledRejections_.add(promise);\n    }\n    /**\n     * @param {!ManagedPromise} promise .\n     */\n\n  }, {\n    key: \"clearUnhandledRejection\",\n    value: function clearUnhandledRejection(promise) {\n      var _this17 = this;\n\n      var deleted = this.unhandledRejections_.delete(promise);\n\n      if (deleted) {\n        // TODO: node 4.0.0+\n        vlog(2, function () {\n          return _this17 + ' clearing unhandled rejection: ' + promise;\n        }, this);\n      }\n    }\n    /**\n     * Enqueues a new task for execution.\n     * @param {!Task} task The task to enqueue.\n     * @throws {Error} If this instance has already started execution.\n     */\n\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(task) {\n      var _this18 = this;\n\n      if (this.state_ !== TaskQueueState.NEW) {\n        throw Error('TaskQueue has started: ' + this);\n      }\n\n      if (task.queue) {\n        throw Error('Task is already scheduled in another queue');\n      }\n\n      this.tasks_.push(task);\n      task.queue = this;\n      ON_CANCEL_HANDLER.set(task.promise, function (e) {\n        return _this18.onTaskCancelled_(task, e);\n      });\n      vlog(1, function () {\n        return _this18 + '.enqueue(' + task + ')';\n      }, this);\n      vlog(2, function () {\n        return _this18.flow_.toString();\n      }, this);\n    }\n    /**\n     * Schedules the callbacks registered on the given promise in this queue.\n     *\n     * @param {!ManagedPromise} promise the promise whose callbacks should be\n     *     registered as interrupts in this task queue.\n     * @throws {Error} if this queue has already finished.\n     */\n\n  }, {\n    key: \"scheduleCallbacks\",\n    value: function scheduleCallbacks(promise) {\n      var _this19 = this;\n\n      if (this.state_ === TaskQueueState.FINISHED) {\n        throw new Error('cannot interrupt a finished q(' + this + ')');\n      }\n\n      if (this.pending_ && this.pending_.task.promise === promise) {\n        this.pending_.task.promise.queue_ = null;\n        this.pending_ = null;\n        asyncRun(function () {\n          return _this19.executeNext_();\n        });\n      }\n\n      if (!promise.callbacks_) {\n        return;\n      }\n\n      promise.callbacks_.forEach(function (cb) {\n        var _this20 = this;\n\n        cb.blocked = false;\n\n        if (cb.queue) {\n          return;\n        }\n\n        ON_CANCEL_HANDLER.set(cb.promise, function (e) {\n          return _this20.onTaskCancelled_(cb, e);\n        });\n\n        if (cb.queue === this && this.tasks_.indexOf(cb) !== -1) {\n          return;\n        }\n\n        if (cb.queue) {\n          cb.queue.dropTask_(cb);\n        }\n\n        cb.queue = this;\n\n        if (!this.interrupts_) {\n          this.interrupts_ = [];\n        }\n\n        this.interrupts_.push(cb);\n      }, this);\n      promise.callbacks_ = null;\n      vlog(2, function () {\n        return _this19 + ' interrupted\\n' + _this19.flow_;\n      }, this);\n    }\n    /**\n     * Starts executing tasks in this queue. Once called, no further tasks may\n     * be {@linkplain #enqueue() enqueued} with this instance.\n     *\n     * @throws {Error} if this queue has already been started.\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this21 = this;\n\n      if (this.state_ !== TaskQueueState.NEW) {\n        throw new Error('TaskQueue has already started');\n      } // Always asynchronously execute next, even if there doesn't look like\n      // there is anything in the queue. This will catch pending unhandled\n      // rejections that were registered before start was called.\n\n\n      asyncRun(function () {\n        return _this21.executeNext_();\n      });\n    }\n    /**\n     * Aborts this task queue. If there are any scheduled tasks, they are silently\n     * cancelled and discarded (their callbacks will never fire). If this queue\n     * has a _pending_ task, the abortion error is used to cancel that task.\n     * Otherwise, this queue will emit an error event.\n     *\n     * @param {*} error The abortion reason.\n     * @private\n     */\n\n  }, {\n    key: \"abort_\",\n    value: function abort_(error) {\n      var _this22 = this;\n\n      var cancellation;\n\n      if (error instanceof FlowResetError) {\n        cancellation = error;\n      } else {\n        cancellation = new DiscardedTaskError(error);\n      }\n\n      if (this.interrupts_ && this.interrupts_.length) {\n        this.interrupts_.forEach(function (t) {\n          return t.reject(cancellation);\n        });\n        this.interrupts_ = [];\n      }\n\n      if (this.tasks_ && this.tasks_.length) {\n        this.tasks_.forEach(function (t) {\n          return t.reject(cancellation);\n        });\n        this.tasks_ = [];\n      } // Now that all of the remaining tasks have been silently cancelled (e.g. no\n      // existing callbacks on those tasks will fire), clear the silence bit on\n      // the cancellation error. This ensures additional callbacks registered in\n      // the future will actually execute.\n\n\n      cancellation.silent_ = false;\n\n      if (this.pending_) {\n        vlog(2, function () {\n          return _this22 + '.abort(); cancelling pending task';\n        }, this);\n        this.pending_.task.promise.cancel(\n        /** @type {!CancellationError} */\n        error);\n      } else {\n        vlog(2, function () {\n          return _this22 + '.abort(); emitting error event';\n        }, this);\n        this.emit('error', error, this);\n      }\n    }\n    /** @private */\n\n  }, {\n    key: \"executeNext_\",\n    value: function executeNext_() {\n      var _this23 = this;\n\n      if (this.state_ === TaskQueueState.FINISHED) {\n        return;\n      }\n\n      this.state_ = TaskQueueState.STARTED;\n\n      if (this.pending_ !== null || this.processUnhandledRejections_()) {\n        return;\n      }\n\n      var task;\n\n      do {\n        task = this.getNextTask_();\n      } while (task && !isPending(task.promise));\n\n      if (!task) {\n        this.state_ = TaskQueueState.FINISHED;\n        this.tasks_ = [];\n        this.interrupts_ = null;\n        vlog(2, function () {\n          return _this23 + '.emit(end)';\n        }, this);\n        this.emit('end', this);\n        return;\n      }\n\n      var result = undefined;\n      this.subQ_ = new TaskQueue(this.flow_);\n      this.subQ_.once('end', function () {\n        // On task completion.\n        _this23.subQ_ = null;\n        _this23.pending_ && _this23.pending_.task.resolve(result);\n      });\n      this.subQ_.once('error', function (e) {\n        // On task failure.\n        _this23.subQ_ = null;\n\n        if (Thenable.isImplementation(result)) {\n          result.cancel(CancellationError.wrap(e));\n        }\n\n        _this23.pending_ && _this23.pending_.task.reject(e);\n      });\n      vlog(2, function () {\n        return \"\".concat(_this23, \" created \").concat(_this23.subQ_, \" for \").concat(task);\n      });\n\n      try {\n        this.pending_ = {\n          task: task,\n          q: this.subQ_\n        };\n        task.promise.queue_ = this;\n        result = this.subQ_.execute_(task.execute);\n        this.subQ_.start();\n      } catch (ex) {\n        this.subQ_.abort_(ex);\n      }\n    }\n    /**\n     * @param {!Function} fn .\n     * @return {T} .\n     * @template T\n     * @private\n     */\n\n  }, {\n    key: \"execute_\",\n    value: function execute_(fn) {\n      try {\n        activeFlows.push(this.flow_);\n        this.flow_.activeQueue_ = this;\n        return fn();\n      } finally {\n        this.flow_.activeQueue_ = null;\n        activeFlows.pop();\n      }\n    }\n    /**\n     * Process any unhandled rejections registered with this task queue. If there\n     * is a rejection, this queue will be aborted with the rejection error. If\n     * there are multiple rejections registered, this queue will be aborted with\n     * a {@link MultipleUnhandledRejectionError}.\n     * @return {boolean} whether there was an unhandled rejection.\n     * @private\n     */\n\n  }, {\n    key: \"processUnhandledRejections_\",\n    value: function processUnhandledRejections_() {\n      var _this24 = this;\n\n      if (!this.unhandledRejections_.size) {\n        return false;\n      }\n\n      var errors = new Set();\n\n      var _iterator3 = _createForOfIteratorHelper(this.unhandledRejections_),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var rejection = _step3.value;\n          errors.add(rejection.value_);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this.unhandledRejections_.clear();\n      var errorToReport = errors.size === 1 ? errors.values().next().value : new MultipleUnhandledRejectionError(errors);\n      vlog(1, function () {\n        return _this24 + ' aborting due to unhandled rejections';\n      }, this);\n\n      if (this.flow_.propagateUnhandledRejections_) {\n        this.abort_(errorToReport);\n        return true;\n      } else {\n        vlog(1, 'error propagation disabled; reporting to control flow');\n        this.flow_.reportUncaughtException_(errorToReport);\n        return false;\n      }\n    }\n    /**\n     * @param {!Task} task The task to drop.\n     * @private\n     */\n\n  }, {\n    key: \"dropTask_\",\n    value: function dropTask_(task) {\n      var index;\n\n      if (this.interrupts_) {\n        index = this.interrupts_.indexOf(task);\n\n        if (index != -1) {\n          task.queue = null;\n          this.interrupts_.splice(index, 1);\n          return;\n        }\n      }\n\n      index = this.tasks_.indexOf(task);\n\n      if (index != -1) {\n        task.queue = null;\n        this.tasks_.splice(index, 1);\n      }\n    }\n    /**\n     * @param {!Task} task The task that was cancelled.\n     * @param {!CancellationError} reason The cancellation reason.\n     * @private\n     */\n\n  }, {\n    key: \"onTaskCancelled_\",\n    value: function onTaskCancelled_(task, reason) {\n      if (this.pending_ && this.pending_.task === task) {\n        this.pending_.q.abort_(reason);\n      } else {\n        this.dropTask_(task);\n      }\n    }\n    /**\n     * @return {(Task|undefined)} the next task scheduled within this queue,\n     *     if any.\n     * @private\n     */\n\n  }, {\n    key: \"getNextTask_\",\n    value: function getNextTask_() {\n      var _this25 = this;\n\n      var task = undefined;\n\n      while (true) {\n        if (this.interrupts_) {\n          task = this.interrupts_.shift();\n        }\n\n        if (!task && this.tasks_) {\n          task = this.tasks_.shift();\n        }\n\n        if (task && task.blocked) {\n          vlog(2, function () {\n            return _this25 + ' skipping blocked task ' + task;\n          }, this);\n          task.queue = null;\n          task = null; // TODO: recurse when tail-call optimization is available in node.\n        } else {\n          break;\n        }\n      }\n\n      return task;\n    }\n  }]);\n\n  return TaskQueue;\n}(events.EventEmitter);\n/**\n * The default flow to use if no others are active.\n * @type {ControlFlow}\n */\n\n\nvar defaultFlow;\n/**\n * A stack of active control flows, with the top of the stack used to schedule\n * commands. When there are multiple flows on the stack, the flow at index N\n * represents a callback triggered within a task owned by the flow at index\n * N-1.\n * @type {!Array<!ControlFlow>}\n */\n\nvar activeFlows = [];\n/**\n * Changes the default flow to use when no others are active.\n * @param {!ControlFlow} flow The new default flow.\n * @throws {Error} If the default flow is not currently active.\n */\n\nfunction setDefaultFlow(flow) {\n  if (!usePromiseManager()) {\n    throw Error('You  may not change set the control flow when the promise' + ' manager is disabled');\n  }\n\n  if (activeFlows.length) {\n    throw Error('You may only change the default flow while it is active');\n  }\n\n  defaultFlow = flow;\n}\n/**\n * @return {!ControlFlow} The currently active control flow.\n * @suppress {checkTypes}\n */\n\n\nfunction controlFlow() {\n  if (!usePromiseManager()) {\n    return SIMPLE_SCHEDULER;\n  }\n\n  if (activeFlows.length) {\n    return activeFlows[activeFlows.length - 1];\n  }\n\n  if (!defaultFlow) {\n    defaultFlow = new ControlFlow();\n  }\n\n  return defaultFlow;\n}\n/**\n * Creates a new control flow. The provided callback will be invoked as the\n * first task within the new flow, with the flow as its sole argument. Returns\n * a promise that resolves to the callback result.\n * @param {function(!ControlFlow)} callback The entry point\n *     to the newly created flow.\n * @return {!Thenable} A promise that resolves to the callback result.\n */\n\n\nfunction createFlow(callback) {\n  var flow = new ControlFlow();\n  return flow.execute(function () {\n    return callback(flow);\n  });\n}\n/**\n * Tests is a function is a generator.\n * @param {!Function} fn The function to test.\n * @return {boolean} Whether the function is a generator.\n */\n\n\nfunction isGenerator(fn) {\n  return fn.constructor.name === 'GeneratorFunction';\n}\n/**\n * Consumes a {@code GeneratorFunction}. Each time the generator yields a\n * promise, this function will wait for it to be fulfilled before feeding the\n * fulfilled value back into {@code next}. Likewise, if a yielded promise is\n * rejected, the rejection error will be passed to {@code throw}.\n *\n * __Example 1:__ the Fibonacci Sequence.\n *\n *     promise.consume(function* fibonacci() {\n *       var n1 = 1, n2 = 1;\n *       for (var i = 0; i < 4; ++i) {\n *         var tmp = yield n1 + n2;\n *         n1 = n2;\n *         n2 = tmp;\n *       }\n *       return n1 + n2;\n *     }).then(function(result) {\n *       console.log(result);  // 13\n *     });\n *\n * __Example 2:__ a generator that throws.\n *\n *     promise.consume(function* () {\n *       yield promise.delayed(250).then(function() {\n *         throw Error('boom');\n *       });\n *     }).catch(function(e) {\n *       console.log(e.toString());  // Error: boom\n *     });\n *\n * @param {!Function} generatorFn The generator function to execute.\n * @param {Object=} opt_self The object to use as \"this\" when invoking the\n *     initial generator.\n * @param {...*} var_args Any arguments to pass to the initial generator.\n * @return {!Thenable<?>} A promise that will resolve to the\n *     generator's final result.\n * @throws {TypeError} If the given function is not a generator.\n */\n\n\nfunction consume(generatorFn, opt_self) {\n  for (var _len = arguments.length, var_args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    var_args[_key - 2] = arguments[_key];\n  }\n\n  if (!isGenerator(generatorFn)) {\n    throw new TypeError('Input is not a GeneratorFunction: ' + generatorFn.constructor.name);\n  }\n\n  var ret;\n  return ret = createPromise(function (resolve, reject) {\n    var generator = generatorFn.apply(opt_self, var_args);\n    callNext();\n    /** @param {*=} opt_value . */\n\n    function callNext(opt_value) {\n      pump(generator.next, opt_value);\n    }\n    /** @param {*=} opt_error . */\n\n\n    function callThrow(opt_error) {\n      pump(generator.throw, opt_error);\n    }\n\n    function pump(fn, opt_arg) {\n      if (ret instanceof ManagedPromise && !isPending(ret)) {\n        return; // Deferred was cancelled; silently abort.\n      }\n\n      try {\n        var result = fn.call(generator, opt_arg);\n      } catch (ex) {\n        reject(ex);\n        return;\n      }\n\n      if (result.done) {\n        resolve(result.value);\n        return;\n      }\n\n      asap(result.value, callNext, callThrow);\n    }\n  });\n} // PUBLIC API\n\n\nmodule.exports = {\n  CancellableThenable: CancellableThenable,\n  CancellationError: CancellationError,\n  ControlFlow: ControlFlow,\n  Deferred: Deferred,\n  MultipleUnhandledRejectionError: MultipleUnhandledRejectionError,\n  Thenable: Thenable,\n  Promise: ManagedPromise,\n  Resolver: Resolver,\n  Scheduler: Scheduler,\n  all: all,\n  asap: asap,\n  captureStackTrace: captureStackTrace,\n  checkedNodeCall: checkedNodeCall,\n  consume: consume,\n  controlFlow: controlFlow,\n  createFlow: createFlow,\n  createPromise: createPromise,\n  defer: defer,\n  delayed: delayed,\n  filter: filter,\n  finally: thenFinally,\n  fulfilled: fulfilled,\n  fullyResolved: fullyResolved,\n  isGenerator: isGenerator,\n  isPromise: isPromise,\n  map: map,\n  rejected: rejected,\n  setDefaultFlow: setDefaultFlow,\n  when: when,\n\n  /**\n   * Indicates whether the promise manager is currently enabled. When disabled,\n   * attempting to use the {@link ControlFlow} or {@link ManagedPromise Promise}\n   * classes will generate an error.\n   *\n   * The promise manager is currently enabled by default, but may be disabled\n   * by setting the environment variable `SELENIUM_PROMISE_MANAGER=0` or by\n   * setting this property to false. Setting this property will always take\n   * precedence over the use of the environment variable.\n   *\n   * @return {boolean} Whether the promise manager is enabled.\n   * @see <https://github.com/SeleniumHQ/selenium/issues/2969>\n   */\n  get USE_PROMISE_MANAGER() {\n    return usePromiseManager();\n  },\n\n  set USE_PROMISE_MANAGER(\n  /** boolean */\n  value) {\n    USE_PROMISE_MANAGER = value;\n  },\n\n  get LONG_STACK_TRACES() {\n    return LONG_STACK_TRACES;\n  },\n\n  set LONG_STACK_TRACES(v) {\n    LONG_STACK_TRACES = v;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/selenium-webdriver/lib/promise.js"],"names":["error","require","events","logging","NativePromise","Promise","LONG_STACK_TRACES","LOG","getLogger","UNIQUE_IDS","WeakMap","nextId","getUid","obj","id","get","set","asyncRun","fn","resolve","then","ignored","vlog","level","loggable","opt_self","logLevel","Level","FINE","FINEST","FINER","bind","log","captureStackTrace","name","msg","opt_topFn","e","Error","stack","toString","CancellationError","opt_msg","constructor","silent_","message","FlowResetError","DiscardedTaskError","MultipleUnhandledRejectionError","errors","IMPLEMENTED_BY_SYMBOL","Symbol","CANCELLABLE_SYMBOL","addMarkerSymbol","ctor","symbol","prototype","hasMarkerSymbol","object","Thenable","opt_callback","opt_errback","errback","CancellableThenable","opt_reason","addImplementation","PromiseState","PENDING","BLOCKED","REJECTED","FULFILLED","ON_CANCEL_HANDLER","SKIP_LOG","FLOW_LOG","ManagedPromise","resolver","opt_flow","opt_skipLog","usePromiseManager","TypeError","process","env","warning","flow_","controlFlow","stack_","parent_","callbacks_","state_","handled_","value_","undefined","queue_","self","value","resolve_","reason","ex","newState","newValue","isImplementation","unblockAndResolve_","scheduleNotifications_","invokeThen_","isError","x","called","resolvePromise","rejectPromise","call","delete","getActiveQueue_","addUnhandledRejection","scheduleCallbacks","canCancel","cancel","wrap","onCancel","promise","addCallback_","catch","callback","result","thenFinally","clearUnhandledRejection","cb","Task","invokeCallback_","top","enqueue","push","blocked","callbackFn","isGenerator","consume","opt_value","_","reject","isPending","Resolver","Deferred","fulfill","f","r","checkNotSelf","isPromise","delayed","ms","createPromise","setTimeout","defer","_resolve","_reject","fulfilled","rejected","checkedNodeCall","var_args","args","Array","slice","arguments","apply","mustThrow","err","when","asap","all","arr","n","length","values","toFulfill","onFulfilled","index","processPromise","i","map","v","isArray","processNext","filter","valuesLength","include","fullyResolved","fullyResolveValue","fullyResolveKeys","numKeys","key","forEachProperty","forEachElement","forEach","numResolved","forEachKey","partialValue","maybeResolveValue","resolvedValue","Scheduler","opt_description","condition","opt_timeout","opt_message","USE_PROMISE_MANAGER","test","scheduleWait","scheduler","timeout","execute","start","Date","now","timer","TimeoutError","clearTimeout","original","startTime","pollCondition","conditionFn","elapsed","SimpleScheduler","EventEmitter","SIMPLE_SCHEDULER","ControlFlow","propagateUnhandledRejections_","activeQueue_","taskQueues_","shutdownTask_","hold_","getSchedule","propagate","size","cancelQueues_","emit","EventType","RESET","removeAllListeners","cancelShutdown_","opt_includeStackTraces","ret","activeQueue","childIndent","q","printQ","indent","prefix","pending_","TaskQueueState","FINISHED","task","interrupts_","tasks_","printTask","replace","TaskQueue","Set","add","once","onQueueEnd_","onQueueError_","holdIntervalMs","setInterval","previousTask","userTask_","split","join","SCHEDULE_TASK","description","execute_","cancellationError","abort_","MicroTask","shutdown_","cancelHold_","listeners","UNCAUGHT_EXCEPTION","reportUncaughtException_","clear","clearInterval","IDLE","cancelled_","flow","opt_stackOptions","opt_isUserTask","queue","NEW","STARTED","name_","subQ_","unhandledRejections_","deleted","onTaskCancelled_","executeNext_","indexOf","dropTask_","cancellation","t","processUnhandledRejections_","getNextTask_","activeFlows","pop","rejection","errorToReport","next","splice","shift","defaultFlow","setDefaultFlow","createFlow","generatorFn","generator","callNext","pump","callThrow","opt_error","throw","opt_arg","done","module","exports","finally"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAC,WAAD,CAAvB;AAGA;AACA;AACA;AACA;;;AACA,IAAMG,aAAa,GAAGC,OAAtB;AAGA;AACA;AACA;AACA;;AACA,IAAIC,iBAAiB,GAAG,KAAxB,C,CAAgC;;AAGhC;;AACA,IAAMC,GAAG,GAAGJ,OAAO,CAACK,SAAR,CAAkB,SAAlB,CAAZ;AAGA,IAAMC,UAAU,GAAG,IAAIC,OAAJ,EAAnB;AACA,IAAIC,MAAM,GAAG,CAAb;;AAGA,SAASC,MAAT,CAAgBC,GAAhB,EAAqB;AACnB,MAAIC,EAAE,GAAGL,UAAU,CAACM,GAAX,CAAeF,GAAf,CAAT;;AACA,MAAI,CAACC,EAAL,EAAS;AAC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AAG,IAAIF,eAAJ,EAAzB;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACMG,W;;;;;AACJ,yBAAc;AAAA;;AAAA;;AACZ,QAAI,CAAC/I,iBAAiB,EAAtB,EAA0B;AACxB,YAAMC,SAAS,CACX,iEACM,gBAFK,CAAf;AAGD;;AAED;AAEA;;AACA,WAAK+I,6BAAL,GAAqC,IAArC;AAEA;;AACA,WAAKC,YAAL,GAAoB,IAApB;AAEA;;AACA,WAAKC,WAAL,GAAmB,IAAnB;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,WAAKC,aAAL,GAAqB,IAArB;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,WAAKC,KAAL,GAAa,IAAb;AA/CY;AAgDb;AAED;AACF;AACA;AACA;AACA;AACA;;;;;+BACa;AACT,aAAO,KAAKC,WAAL,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;oDACkCC,S,EAAW;AACzC,WAAKN,6BAAL,GAAqCM,SAArC;AACD;AAED;AACF;AACA;;;;6BACW;AACP,aAAO,CAAC,KAAKH,aAAN,KAAwB,CAAC,KAAKD,WAAN,IAAqB,CAAC,KAAKA,WAAL,CAAiBK,IAA/D,CAAP;AACD;AAED;AACF;AACA;;;;4BACU;AACN,WAAKC,aAAL,CAAmB,IAAIxL,cAAJ,EAAnB;AACA,WAAKyL,IAAL,CAAUV,WAAW,CAACW,SAAZ,CAAsBC,KAAhC;AACA,WAAKC,kBAAL;AACA,WAAKC,eAAL;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;gCACcC,sB,EAAwB;AAClC,UAAIC,GAAG,GAAG,kBAAkBjO,MAAM,CAAC,IAAD,CAAlC;AACA,UAAIkO,WAAW,GAAG,K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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview\n *\n * > ### IMPORTANT NOTICE\n * >\n * > The promise manager contained in this module is in the process of being\n * > phased out in favor of native JavaScript promises. This will be a long\n * > process and will not be completed until there have been two major LTS Node\n * > releases (approx. Node v10.0) that support\n * > [async functions](https://tc39.github.io/ecmascript-asyncawait/).\n * >\n * > At this time, the promise manager can be disabled by setting an environment\n * > variable, `SELENIUM_PROMISE_MANAGER=0`. In the absence of async functions,\n * > users may use generators with the\n * > {@link ./promise.consume promise.consume()} function to write \"synchronous\"\n * > style tests:\n * >\n * > ```js\n * > const {Builder, By, Key, promise, until} = require('selenium-webdriver');\n * >\n * > let result = promise.consume(function* doGoogleSearch() {\n * >   let driver = new Builder().forBrowser('firefox').build();\n * >   yield driver.get('http://www.google.com/ncr');\n * >   yield driver.findElement(By.name('q')).sendKeys('webdriver', Key.RETURN);\n * >   yield driver.wait(until.titleIs('webdriver - Google Search'), 1000);\n * >   yield driver.quit();\n * > });\n * >\n * > result.then(_ => console.log('SUCCESS!'),\n * >             e => console.error('FAILURE: ' + e));\n * > ```\n * >\n * > The motivation behind this change and full deprecation plan are documented\n * > in [issue 2969](https://github.com/SeleniumHQ/selenium/issues/2969).\n * >\n * >\n *\n * The promise module is centered around the {@linkplain ControlFlow}, a class\n * that coordinates the execution of asynchronous tasks. The ControlFlow allows\n * users to focus on the imperative commands for their script without worrying\n * about chaining together every single asynchronous action, which can be\n * tedious and verbose. APIs may be layered on top of the control flow to read\n * as if they were synchronous. For instance, the core\n * {@linkplain ./webdriver.WebDriver WebDriver} API is built on top of the\n * control flow, allowing users to write\n *\n *     driver.get('http://www.google.com/ncr');\n *     driver.findElement({name: 'q'}).sendKeys('webdriver', Key.RETURN);\n *\n * instead of\n *\n *     driver.get('http://www.google.com/ncr')\n *     .then(function() {\n *       return driver.findElement({name: 'q'});\n *     })\n *     .then(function(q) {\n *       return q.sendKeys('webdriver', Key.RETURN);\n *     });\n *\n * ## Tasks and Task Queues\n *\n * The control flow is based on the concept of tasks and task queues. Tasks are\n * functions that define the basic unit of work for the control flow to execute.\n * Each task is scheduled via {@link ControlFlow#execute()}, which will return\n * a {@link ManagedPromise} that will be resolved with the task's result.\n *\n * A task queue contains all of the tasks scheduled within a single turn of the\n * [JavaScript event loop][JSEL]. The control flow will create a new task queue\n * the first time a task is scheduled within an event loop.\n *\n *     var flow = promise.controlFlow();\n *     flow.execute(foo);       // Creates a new task queue and inserts foo.\n *     flow.execute(bar);       // Inserts bar into the same queue as foo.\n *     setTimeout(function() {\n *       flow.execute(baz);     // Creates a new task queue and inserts baz.\n *     }, 0);\n *\n * Whenever the control flow creates a new task queue, it will automatically\n * begin executing tasks in the next available turn of the event loop. This\n * execution is [scheduled as a microtask][MicrotasksArticle] like e.g. a\n * (native) `Promise.then()` callback.\n *\n *     setTimeout(() => console.log('a'));\n *     Promise.resolve().then(() => console.log('b'));  // A native promise.\n *     flow.execute(() => console.log('c'));\n *     Promise.resolve().then(() => console.log('d'));\n *     setTimeout(() => console.log('fin'));\n *     // b\n *     // c\n *     // d\n *     // a\n *     // fin\n *\n * In the example above, b/c/d is logged before a/fin because native promises\n * and this module use \"microtask\" timers, which have a higher priority than\n * \"macrotasks\" like `setTimeout`.\n *\n * ## Task Execution\n *\n * Upon creating a task queue, and whenever an existing queue completes a task,\n * the control flow will schedule a microtask timer to process any scheduled\n * tasks. This ensures no task is ever started within the same turn of the\n * JavaScript event loop in which it was scheduled, nor is a task ever started\n * within the same turn that another finishes.\n *\n * When the execution timer fires, a single task will be dequeued and executed.\n * There are several important events that may occur while executing a task\n * function:\n *\n * 1. A new task queue is created by a call to {@link ControlFlow#execute()}.\n *    Any tasks scheduled within this task queue are considered subtasks of the\n *    current task.\n * 2. The task function throws an error. Any scheduled tasks are immediately\n *    discarded and the task's promised result (previously returned by\n *    {@link ControlFlow#execute()}) is immediately rejected with the thrown\n *    error.\n * 3. The task function returns successfully.\n *\n * If a task function created a new task queue, the control flow will wait for\n * that queue to complete before processing the task result. If the queue\n * completes without error, the flow will settle the task's promise with the\n * value originally returned by the task function. On the other hand, if the task\n * queue terminates with an error, the task's promise will be rejected with that\n * error.\n *\n *     flow.execute(function() {\n *       flow.execute(() => console.log('a'));\n *       flow.execute(() => console.log('b'));\n *     });\n *     flow.execute(() => console.log('c'));\n *     // a\n *     // b\n *     // c\n *\n * ## ManagedPromise Integration\n *\n * In addition to the {@link ControlFlow} class, the promise module also exports\n * a [Promises/A+] {@linkplain ManagedPromise implementation} that is deeply\n * integrated with the ControlFlow. First and foremost, each promise\n * {@linkplain ManagedPromise#then() callback} is scheduled with the\n * control flow as a task. As a result, each callback is invoked in its own turn\n * of the JavaScript event loop with its own task queue. If any tasks are\n * scheduled within a callback, the callback's promised result will not be\n * settled until the task queue has completed.\n *\n *     promise.fulfilled().then(function() {\n *       flow.execute(function() {\n *         console.log('b');\n *       });\n *     }).then(() => console.log('a'));\n *     // b\n *     // a\n *\n * ### Scheduling ManagedPromise Callbacks <a id=\"scheduling_callbacks\"></a>\n *\n * How callbacks are scheduled in the control flow depends on when they are\n * attached to the promise. Callbacks attached to a _previously_ resolved\n * promise are immediately enqueued as subtasks of the currently running task.\n *\n *     var p = promise.fulfilled();\n *     flow.execute(function() {\n *       flow.execute(() => console.log('A'));\n *       p.then(      () => console.log('B'));\n *       flow.execute(() => console.log('C'));\n *       p.then(      () => console.log('D'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * When a promise is resolved while a task function is on the call stack, any\n * callbacks also registered in that stack frame are scheduled as if the promise\n * were already resolved:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // fin\n *\n * Callbacks attached to an _unresolved_ promise within a task function are\n * only weakly scheduled as subtasks and will be dropped if they reach the\n * front of the queue before the promise is resolved. In the example below, the\n * callbacks for `B` & `D` are dropped as sub-tasks since they are attached to\n * an unresolved promise when they reach the front of the task queue.\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('A'));\n *       d.promise.then(() => console.log('B'));\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       setTimeout(d.fulfill, 20);\n *     }).then(function() {\n *       console.log('fin')\n *     });\n *     // A\n *     // C\n *     // fin\n *     // B\n *     // D\n *\n * If a promise is resolved while a task function is on the call stack, any\n * previously registered and unqueued callbacks (i.e. either attached while no\n * task was on the call stack, or previously dropped as described above) act as\n * _interrupts_ and are inserted at the front of the task queue. If multiple\n * promises are fulfilled, their interrupts are enqueued in the order the\n * promises are resolved.\n *\n *     var d1 = promise.defer();\n *     d1.promise.then(() => console.log('A'));\n *\n *     var d2 = promise.defer();\n *     d2.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       d1.promise.then(() => console.log('C'));\n *       flow.execute(() => console.log('D'));\n *     });\n *     flow.execute(function() {\n *       flow.execute(() => console.log('E'));\n *       flow.execute(() => console.log('F'));\n *       d1.fulfill();\n *       d2.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // D\n *     // A\n *     // C\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Within a task function (or callback), each step of a promise chain acts as\n * an interrupt on the task queue:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       d.promise.\n *           then(() => console.log('A')).\n *           then(() => console.log('B')).\n *           then(() => console.log('C')).\n *           then(() => console.log('D'));\n *\n *       flow.execute(() => console.log('E'));\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // fin\n *\n * If there are multiple promise chains derived from a single promise, they are\n * processed in the order created:\n *\n *     var d = promise.defer();\n *     flow.execute(function() {\n *       var chain = d.promise.then(() => console.log('A'));\n *\n *       chain.then(() => console.log('B')).\n *           then(() => console.log('C'));\n *\n *       chain.then(() => console.log('D')).\n *           then(() => console.log('E'));\n *\n *       flow.execute(() => console.log('F'));\n *\n *       d.fulfill();\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // fin\n *\n * Even though a subtask's promised result will never resolve while the task\n * function is on the stack, it will be treated as a promise resolved within the\n * task. In all other scenarios, a task's promise behaves just like a normal\n * promise. In the sample below, `C/D` is logged before `B` because the\n * resolution of `subtask1` interrupts the flow of the enclosing task. Within\n * the final subtask, `E/F` is logged in order because `subtask1` is a resolved\n * promise when that task runs.\n *\n *     flow.execute(function() {\n *       var subtask1 = flow.execute(() => console.log('A'));\n *       var subtask2 = flow.execute(() => console.log('B'));\n *\n *       subtask1.then(() => console.log('C'));\n *       subtask1.then(() => console.log('D'));\n *\n *       flow.execute(function() {\n *         flow.execute(() => console.log('E'));\n *         subtask1.then(() => console.log('F'));\n *       });\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // C\n *     // D\n *     // B\n *     // E\n *     // F\n *     // fin\n *\n * Finally, consider the following:\n *\n *     var d = promise.defer();\n *     d.promise.then(() => console.log('A'));\n *     d.promise.then(() => console.log('B'));\n *\n *     flow.execute(function() {\n *       flow.execute(  () => console.log('C'));\n *       d.promise.then(() => console.log('D'));\n *\n *       flow.execute(  () => console.log('E'));\n *       d.promise.then(() => console.log('F'));\n *\n *       d.fulfill();\n *\n *       flow.execute(  () => console.log('G'));\n *       d.promise.then(() => console.log('H'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // A\n *     // B\n *     // C\n *     // D\n *     // E\n *     // F\n *     // G\n *     // H\n *     // fin\n *\n * In this example, callbacks are registered on `d.promise` both before and\n * during the invocation of the task function. When `d.fulfill()` is called,\n * the callbacks registered before the task (`A` & `B`) are registered as\n * interrupts. The remaining callbacks were all attached within the task and\n * are scheduled in the flow as standard tasks.\n *\n * ## Generator Support\n *\n * [Generators][GF] may be scheduled as tasks within a control flow or attached\n * as callbacks to a promise. Each time the generator yields a promise, the\n * control flow will wait for that promise to settle before executing the next\n * iteration of the generator. The yielded promise's fulfilled value will be\n * passed back into the generator:\n *\n *     flow.execute(function* () {\n *       var d = promise.defer();\n *\n *       setTimeout(() => console.log('...waiting...'), 25);\n *       setTimeout(() => d.fulfill(123), 50);\n *\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield d.promise;\n *       console.log('mid: %d; value = %d', Date.now(), value);\n *\n *       yield promise.delayed(10);\n *       console.log('end: ' + Date.now());\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // ...waiting...\n *     // mid: 50; value = 123\n *     // end: 60\n *     // fin\n *\n * Yielding the result of a promise chain will wait for the entire chain to\n * complete:\n *\n *     promise.fulfilled().then(function* () {\n *       console.log('start: ' + Date.now());\n *\n *       var value = yield flow.\n *           execute(() => console.log('A')).\n *           then(   () => console.log('B')).\n *           then(   () => 123);\n *\n *       console.log('mid: %s; value = %d', Date.now(), value);\n *\n *       yield flow.execute(() => console.log('C'));\n *     }).then(function() {\n *       console.log('fin');\n *     });\n *     // start: 0\n *     // A\n *     // B\n *     // mid: 2; value = 123\n *     // C\n *     // fin\n *\n * Yielding a _rejected_ promise will cause the rejected value to be thrown\n * within the generator function:\n *\n *     flow.execute(function* () {\n *       console.log('start: ' + Date.now());\n *       try {\n *         yield promise.delayed(10).then(function() {\n *           throw Error('boom');\n *         });\n *       } catch (ex) {\n *         console.log('caught time: ' + Date.now());\n *         console.log(ex.message);\n *       }\n *     });\n *     // start: 0\n *     // caught time: 10\n *     // boom\n *\n * # Error Handling\n *\n * ES6 promises do not require users to handle a promise rejections. This can\n * result in subtle bugs as the rejections are silently \"swallowed\" by the\n * Promise class.\n *\n *     Promise.reject(Error('boom'));\n *     // ... *crickets* ...\n *\n * Selenium's promise module, on the other hand, requires that every rejection\n * be explicitly handled. When a {@linkplain ManagedPromise ManagedPromise} is\n * rejected and no callbacks are defined on that promise, it is considered an\n * _unhandled rejection_ and reported to the active task queue. If the rejection\n * remains unhandled after a single turn of the [event loop][JSEL] (scheduled\n * with a microtask), it will propagate up the stack.\n *\n * ## Error Propagation\n *\n * If an unhandled rejection occurs within a task function, that task's promised\n * result is rejected and all remaining subtasks are discarded:\n *\n *     flow.execute(function() {\n *       // No callbacks registered on promise -> unhandled rejection\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('this will never run'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * The promised results for discarded tasks are silently rejected with a\n * cancellation error and existing callback chains will never fire.\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       flow.execute(function() { console.log('a'); }).\n *           then(function() { console.log('b'); });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * An unhandled rejection takes precedence over a task function's returned\n * result, even if that value is another promise:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       return flow.execute(someOtherTask);\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // boom\n *\n * If there are multiple unhandled rejections within a task, they are packaged\n * in a {@link MultipleUnhandledRejectionError}, which has an `errors` property\n * that is a `Set` of the recorded unhandled rejections:\n *\n *     flow.execute(function() {\n *       promise.rejected(Error('boom1'));\n *       promise.rejected(Error('boom2'));\n *     }).catch(function(ex) {\n *       console.log(ex instanceof MultipleUnhandledRejectionError);\n *       for (var e of ex.errors) {\n *         console.log(e.message);\n *       }\n *     });\n *     // boom1\n *     // boom2\n *\n * When a subtask is discarded due to an unreported rejection in its parent\n * frame, the existing callbacks on that task will never settle and the\n * callbacks will not be invoked. If a new callback is attached to the subtask\n * _after_ it has been discarded, it is handled the same as adding a callback\n * to a cancelled promise: the error-callback path is invoked. This behavior is\n * intended to handle cases where the user saves a reference to a task promise,\n * as illustrated below.\n *\n *     var subTask;\n *     flow.execute(function() {\n *       promise.rejected(Error('boom'));\n *       subTask = flow.execute(function() {});\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     }).then(function() {\n *       return subTask.then(\n *           () => console.log('subtask success!'),\n *           (e) => console.log('subtask failed:\\n' + e));\n *     });\n *     // boom\n *     // subtask failed:\n *     // DiscardedTaskError: Task was discarded due to a previous failure: boom\n *\n * When a subtask fails, its promised result is treated the same as any other\n * promise: it must be handled within one turn of the rejection or the unhandled\n * rejection is propagated to the parent task. This means users can catch errors\n * from complex flows from the top level task:\n *\n *     flow.execute(function() {\n *       flow.execute(function() {\n *         flow.execute(function() {\n *           throw Error('fail!');\n *         });\n *       });\n *     }).catch(function(e) {\n *       console.log(e.message);\n *     });\n *     // fail!\n *\n * ## Unhandled Rejection Events\n *\n * When an unhandled rejection propagates to the root of the control flow, the\n * flow will emit an __uncaughtException__ event. If no listeners are registered\n * on the flow, the error will be rethrown to the global error handler: an\n * __uncaughtException__ event from the\n * [`process`](https://nodejs.org/api/process.html) object in node, or\n * `window.onerror` when running in a browser.\n *\n * Bottom line: you __*must*__ handle rejected promises.\n *\n * # Promises/A+ Compatibility\n *\n * This `promise` module is compliant with the [Promises/A+] specification\n * except for sections `2.2.6.1` and `2.2.6.2`:\n *\n * >\n * > - `then` may be called multiple times on the same promise.\n * >    - If/when `promise` is fulfilled, all respective `onFulfilled` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >    - If/when `promise` is rejected, all respective `onRejected` callbacks\n * >      must execute in the order of their originating calls to `then`.\n * >\n *\n * Specifically, the conformance tests contain the following scenario (for\n * brevity, only the fulfillment version is shown):\n *\n *     var p1 = Promise.resolve();\n *     p1.then(function() {\n *       console.log('A');\n *       p1.then(() => console.log('B'));\n *     });\n *     p1.then(() => console.log('C'));\n *     // A\n *     // C\n *     // B\n *\n * Since the [ControlFlow](#scheduling_callbacks) executes promise callbacks as\n * tasks, with this module, the result would be:\n *\n *     var p2 = promise.fulfilled();\n *     p2.then(function() {\n *       console.log('A');\n *       p2.then(() => console.log('B');\n *     });\n *     p2.then(() => console.log('C'));\n *     // A\n *     // B\n *     // C\n *\n * [JSEL]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\n * [GF]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n * [Promises/A+]: https://promisesaplus.com/\n * [MicrotasksArticle]: https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n */\n\n'use strict';\n\nconst error = require('./error');\nconst events = require('./events');\nconst logging = require('./logging');\n\n\n/**\n * Alias to help with readability and differentiate types.\n * @const\n */\nconst NativePromise = Promise;\n\n\n/**\n * Whether to append traces of `then` to rejection errors.\n * @type {boolean}\n */\nvar LONG_STACK_TRACES = false;  // TODO: this should not be CONSTANT_CASE\n\n\n/** @const */\nconst LOG = logging.getLogger('promise');\n\n\nconst UNIQUE_IDS = new WeakMap;\nlet nextId = 1;\n\n\nfunction getUid(obj) {\n  let id = UNIQUE_IDS.get(obj);\n  if (!id) {\n    id = nextId;\n    nextId += 1;\n    UNIQUE_IDS.set(obj, id);\n  }\n  return id;\n}\n\n\n/**\n * Runs the given function after a microtask yield.\n * @param {function()} fn The function to run.\n */\nfunction asyncRun(fn) {\n  NativePromise.resolve().then(function() {\n    try {\n      fn();\n    } catch (ignored) {\n      // Do nothing.\n    }\n  });\n}\n\n/**\n * @param {number} level What level of verbosity to log with.\n * @param {(string|function(this: T): string)} loggable The message to log.\n * @param {T=} opt_self The object in whose context to run the loggable\n *     function.\n * @template T\n */\nfunction vlog(level, loggable, opt_self) {\n  var logLevel = logging.Level.FINE;\n  if (level > 1) {\n    logLevel = logging.Level.FINEST;\n  } else if (level > 0) {\n    logLevel = logging.Level.FINER;\n  }\n\n  if (typeof loggable === 'function') {\n    loggable = loggable.bind(opt_self);\n  }\n\n  LOG.log(logLevel, loggable);\n}\n\n\n/**\n * Generates an error to capture the current stack trace.\n * @param {string} name Error name for this stack trace.\n * @param {string} msg Message to record.\n * @param {Function=} opt_topFn The function that should appear at the top of\n *     the stack; only applicable in V8.\n * @return {!Error} The generated error.\n */\nfunction captureStackTrace(name, msg, opt_topFn) {\n  var e = Error(msg);\n  e.name = name;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, opt_topFn);\n  } else {\n    var stack = Error().stack;\n    if (stack) {\n      e.stack = e.toString();\n      e.stack += '\\n' + stack;\n    }\n  }\n  return e;\n}\n\n\n/**\n * Error used when the computation of a promise is cancelled.\n */\nclass CancellationError extends Error {\n  /**\n   * @param {string=} opt_msg The cancellation message.\n   */\n  constructor(opt_msg) {\n    super(opt_msg);\n\n    /** @override */\n    this.name = this.constructor.name;\n\n    /** @private {boolean} */\n    this.silent_ = false;\n  }\n\n  /**\n   * Wraps the given error in a CancellationError.\n   *\n   * @param {*} error The error to wrap.\n   * @param {string=} opt_msg The prefix message to use.\n   * @return {!CancellationError} A cancellation error.\n   */\n  static wrap(error, opt_msg) {\n    var message;\n    if (error instanceof CancellationError) {\n      return new CancellationError(\n          opt_msg ? (opt_msg + ': ' + error.message) : error.message);\n    } else if (opt_msg) {\n      message = opt_msg;\n      if (error) {\n        message += ': ' + error;\n      }\n      return new CancellationError(message);\n    }\n    if (error) {\n      message = error + '';\n    }\n    return new CancellationError(message);\n  }\n}\n\n\n/**\n * Error used to cancel tasks when a control flow is reset.\n * @final\n */\nclass FlowResetError extends CancellationError {\n  constructor() {\n    super('ControlFlow was reset');\n    this.silent_ = true;\n  }\n}\n\n\n/**\n * Error used to cancel tasks that have been discarded due to an uncaught error\n * reported earlier in the control flow.\n * @final\n */\nclass DiscardedTaskError extends CancellationError {\n  /** @param {*} error The original error. */\n  constructor(error) {\n    if (error instanceof DiscardedTaskError) {\n      return /** @type {!DiscardedTaskError} */(error);\n    }\n\n    var msg = '';\n    if (error) {\n      msg = ': ' + (\n          typeof error.message === 'string' ? error.message : error);\n    }\n\n    super('Task was discarded due to a previous failure' + msg);\n    this.silent_ = true;\n  }\n}\n\n\n/**\n * Error used when there are multiple unhandled promise rejections detected\n * within a task or callback.\n *\n * @final\n */\nclass MultipleUnhandledRejectionError extends Error {\n  /**\n   * @param {!(Set<*>)} errors The errors to report.\n   */\n  constructor(errors) {\n    super('Multiple unhandled promise rejections reported');\n\n    /** @override */\n    this.name = this.constructor.name;\n\n    /** @type {!Set<*>} */\n    this.errors = errors;\n  }\n}\n\n\n/**\n * Property used to flag constructor's as implementing the Thenable interface\n * for runtime type checking.\n * @const\n */\nconst IMPLEMENTED_BY_SYMBOL = Symbol('promise.Thenable');\nconst CANCELLABLE_SYMBOL = Symbol('promise.CancellableThenable');\n\n\n/**\n * @param {function(new: ?)} ctor\n * @param {!Object} symbol\n */\nfunction addMarkerSymbol(ctor, symbol) {\n  try {\n    ctor.prototype[symbol] = true;\n  } catch (ignored) {\n    // Property access denied?\n  }\n}\n\n\n/**\n * @param {*} object\n * @param {!Object} symbol\n * @return {boolean}\n */\nfunction hasMarkerSymbol(object, symbol) {\n  if (!object) {\n    return false;\n  }\n  try {\n    return !!object[symbol];\n  } catch (e) {\n    return false;  // Property access seems to be forbidden.\n  }\n}\n\n\n/**\n * Thenable is a promise-like object with a {@code then} method which may be\n * used to schedule callbacks on a promised value.\n *\n * @record\n * @extends {IThenable<T>}\n * @template T\n */\nclass Thenable {\n  /**\n   * Adds a property to a class prototype to allow runtime checks of whether\n   * instances of that class implement the Thenable interface.\n   * @param {function(new: Thenable, ...?)} ctor The\n   *     constructor whose prototype to modify.\n   */\n  static addImplementation(ctor) {\n    addMarkerSymbol(ctor, IMPLEMENTED_BY_SYMBOL);\n  }\n\n  /**\n   * Checks if an object has been tagged for implementing the Thenable\n   * interface as defined by {@link Thenable.addImplementation}.\n   * @param {*} object The object to test.\n   * @return {boolean} Whether the object is an implementation of the Thenable\n   *     interface.\n   */\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, IMPLEMENTED_BY_SYMBOL);\n  }\n\n  /**\n   * Registers listeners for when this instance is resolved.\n   *\n   * @param {?(function(T): (R|IThenable<R>))=} opt_callback The\n   *     function to call if this promise is successfully resolved. The function\n   *     should expect a single argument: the promise's resolved value.\n   * @param {?(function(*): (R|IThenable<R>))=} opt_errback\n   *     The function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n  then(opt_callback, opt_errback) {}\n\n  /**\n   * Registers a listener for when this promise is rejected. This is synonymous\n   * with the {@code catch} clause in a synchronous API:\n   *\n   *     // Synchronous API:\n   *     try {\n   *       doSynchronousWork();\n   *     } catch (ex) {\n   *       console.error(ex);\n   *     }\n   *\n   *     // Asynchronous promise API:\n   *     doAsynchronousWork().catch(function(ex) {\n   *       console.error(ex);\n   *     });\n   *\n   * @param {function(*): (R|IThenable<R>)} errback The\n   *     function to call if this promise is rejected. The function should\n   *     expect a single argument: the rejection reason.\n   * @return {!Thenable<R>} A new promise which will be resolved with the result\n   *     of the invoked callback.\n   * @template R\n   */\n  catch(errback) {}\n}\n\n\n/**\n * Marker interface for objects that allow consumers to request the cancellation\n * of a promise-based operation. A cancelled promise will be rejected with a\n * {@link CancellationError}.\n *\n * This interface is considered package-private and should not be used outside\n * of selenium-webdriver.\n *\n * @interface\n * @extends {Thenable<T>}\n * @template T\n * @package\n */\nclass CancellableThenable {\n  /**\n   * @param {function(new: CancellableThenable, ...?)} ctor\n   */\n  static addImplementation(ctor) {\n    Thenable.addImplementation(ctor);\n    addMarkerSymbol(ctor, CANCELLABLE_SYMBOL);\n  }\n\n  /**\n   * @param {*} object\n   * @return {boolean}\n   */\n  static isImplementation(object) {\n    return hasMarkerSymbol(object, CANCELLABLE_SYMBOL);\n  }\n\n  /**\n   * Requests the cancellation of the computation of this promise's value,\n   * rejecting the promise in the process. This method is a no-op if the promise\n   * has already been resolved.\n   *\n   * @param {(string|Error)=} opt_reason The reason this promise is being\n   *     cancelled. This value will be wrapped in a {@link CancellationError}.\n   */\n  cancel(opt_reason) {}\n}\n\n\n/**\n * @enum {string}\n */\nconst PromiseState = {\n  PENDING: 'pending',\n  BLOCKED: 'blocked',\n  REJECTED: 'rejected',\n  FULFILLED: 'fulfilled'\n};\n\n\n/**\n * Internal map used to store cancellation handlers for {@link ManagedPromise}\n * objects. This is an internal implementation detail used by the\n * {@link TaskQueue} class to monitor for when a promise is cancelled without\n * generating an extra promise via then().\n *\n * @const {!WeakMap<!ManagedPromise, function(!CancellationError)>}\n */\nconst ON_CANCEL_HANDLER = new WeakMap;\n\nconst SKIP_LOG = Symbol('skip-log');\nconst FLOW_LOG = logging.getLogger('promise.ControlFlow');\n\n\n/**\n * Represents the eventual value of a completed operation. Each promise may be\n * in one of three states: pending, fulfilled, or rejected. Each promise starts\n * in the pending state and may make a single transition to either a\n * fulfilled or rejected state, at which point the promise is considered\n * resolved.\n *\n * @implements {CancellableThenable<T>}\n * @template T\n * @see http://promises-aplus.github.io/promises-spec/\n */\nclass ManagedPromise {\n  /**\n   * @param {function(\n   *           function((T|IThenable<T>|Thenable)=),\n   *           function(*=))} resolver\n   *     Function that is invoked immediately to begin computation of this\n   *     promise's value. The function should accept a pair of callback\n   *     functions, one for fulfilling the promise and another for rejecting it.\n   * @param {ControlFlow=} opt_flow The control flow\n   *     this instance was created under. Defaults to the currently active flow.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(resolver, opt_flow, opt_skipLog) {\n    if (!usePromiseManager()) {\n      throw TypeError(\n        'Unable to create a managed promise instance: the promise manager has'\n            + ' been disabled by the SELENIUM_PROMISE_MANAGER environment'\n            + ' variable: ' + process.env['SELENIUM_PROMISE_MANAGER']);\n    } else if (opt_skipLog !== SKIP_LOG) {\n      FLOW_LOG.warning(() => {\n        let e =\n            captureStackTrace(\n                'ManagedPromiseError',\n                'Creating a new managed Promise. This call will fail when the'\n                    + ' promise manager is disabled',\n            ManagedPromise)\n        return e.stack;\n      });\n    }\n\n    getUid(this);\n\n    /** @private {!ControlFlow} */\n    this.flow_ = opt_flow || controlFlow();\n\n    /** @private {Error} */\n    this.stack_ = null;\n    if (LONG_STACK_TRACES) {\n      this.stack_ = captureStackTrace('ManagedPromise', 'new', this.constructor);\n    }\n\n    /** @private {Thenable<?>} */\n    this.parent_ = null;\n\n    /** @private {Array<!Task>} */\n    this.callbacks_ = null;\n\n    /** @private {PromiseState} */\n    this.state_ = PromiseState.PENDING;\n\n    /** @private {boolean} */\n    this.handled_ = false;\n\n    /** @private {*} */\n    this.value_ = undefined;\n\n    /** @private {TaskQueue} */\n    this.queue_ = null;\n\n    try {\n      var self = this;\n      resolver(function(value) {\n        self.resolve_(PromiseState.FULFILLED, value);\n      }, function(reason) {\n        self.resolve_(PromiseState.REJECTED, reason);\n      });\n    } catch (ex) {\n      this.resolve_(PromiseState.REJECTED, ex);\n    }\n  }\n\n  /**\n   * Creates a promise that is immediately resolved with the given value.\n   *\n   * @param {T=} opt_value The value to resolve.\n   * @return {!ManagedPromise<T>} A promise resolved with the given value.\n   * @template T\n   */\n  static resolve(opt_value) {\n    if (opt_value instanceof ManagedPromise) {\n      return opt_value;\n    }\n    return new ManagedPromise(resolve => resolve(opt_value));\n  }\n\n  /**\n   * Creates a promise that is immediately rejected with the given reason.\n   *\n   * @param {*=} opt_reason The rejection reason.\n   * @return {!ManagedPromise<?>} A new rejected promise.\n   */\n  static reject(opt_reason) {\n    return new ManagedPromise((_, reject) => reject(opt_reason));\n  }\n\n  /** @override */\n  toString() {\n    return 'ManagedPromise::' + getUid(this) +\n      ' {[[PromiseStatus]]: \"' + this.state_ + '\"}';\n  }\n\n  /**\n   * Resolves this promise. If the new value is itself a promise, this function\n   * will wait for it to be resolved before notifying the registered listeners.\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @throws {TypeError} If {@code newValue === this}.\n   * @private\n   */\n  resolve_(newState, newValue) {\n    if (PromiseState.PENDING !== this.state_) {\n      return;\n    }\n\n    if (newValue === this) {\n      // See promise a+, 2.3.1\n      // http://promises-aplus.github.io/promises-spec/#point-48\n      newValue = new TypeError('A promise may not resolve to itself');\n      newState = PromiseState.REJECTED;\n    }\n\n    this.parent_ = null;\n    this.state_ = PromiseState.BLOCKED;\n\n    if (newState !== PromiseState.REJECTED) {\n      if (Thenable.isImplementation(newValue)) {\n        // 2.3.2\n        newValue = /** @type {!Thenable} */(newValue);\n        this.parent_ = newValue;\n        newValue.then(\n            this.unblockAndResolve_.bind(this, PromiseState.FULFILLED),\n            this.unblockAndResolve_.bind(this, PromiseState.REJECTED));\n        return;\n\n      } else if (newValue\n          && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        // 2.3.3\n\n        try {\n          // 2.3.3.1\n          var then = newValue['then'];\n        } catch (e) {\n          // 2.3.3.2\n          this.state_ = PromiseState.REJECTED;\n          this.value_ = e;\n          this.scheduleNotifications_();\n          return;\n        }\n\n        if (typeof then === 'function') {\n          // 2.3.3.3\n          this.invokeThen_(/** @type {!Object} */(newValue), then);\n          return;\n        }\n      }\n    }\n\n    if (newState === PromiseState.REJECTED &&\n        isError(newValue) && newValue.stack && this.stack_) {\n      newValue.stack += '\\nFrom: ' + (this.stack_.stack || this.stack_);\n    }\n\n    // 2.3.3.4 and 2.3.4\n    this.state_ = newState;\n    this.value_ = newValue;\n    this.scheduleNotifications_();\n  }\n\n  /**\n   * Invokes a thenable's \"then\" method according to 2.3.3.3 of the promise\n   * A+ spec.\n   * @param {!Object} x The thenable object.\n   * @param {!Function} then The \"then\" function to invoke.\n   * @private\n   */\n  invokeThen_(x, then) {\n    var called = false;\n    var self = this;\n\n    var resolvePromise = function(value) {\n      if (!called) {  // 2.3.3.3.3\n        called = true;\n        // 2.3.3.3.1\n        self.unblockAndResolve_(PromiseState.FULFILLED, value);\n      }\n    };\n\n    var rejectPromise = function(reason) {\n      if (!called) {  // 2.3.3.3.3\n        called = true;\n        // 2.3.3.3.2\n        self.unblockAndResolve_(PromiseState.REJECTED, reason);\n      }\n    };\n\n    try {\n      // 2.3.3.3\n      then.call(x, resolvePromise, rejectPromise);\n    } catch (e) {\n      // 2.3.3.3.4.2\n      rejectPromise(e);\n    }\n  }\n\n  /**\n   * @param {PromiseState} newState The promise's new state.\n   * @param {*} newValue The promise's new value.\n   * @private\n   */\n  unblockAndResolve_(newState, newValue) {\n    if (this.state_ === PromiseState.BLOCKED) {\n      this.state_ = PromiseState.PENDING;\n      this.resolve_(newState, newValue);\n    }\n  }\n\n  /**\n   * @private\n   */\n  scheduleNotifications_() {\n    vlog(2, () => this + ' scheduling notifications', this);\n\n    ON_CANCEL_HANDLER.delete(this);\n    if (this.value_ instanceof CancellationError\n        && this.value_.silent_) {\n      this.callbacks_ = null;\n    }\n\n    if (!this.queue_) {\n      this.queue_ = this.flow_.getActiveQueue_();\n    }\n\n    if (!this.handled_ &&\n        this.state_ === PromiseState.REJECTED &&\n        !(this.value_ instanceof CancellationError)) {\n      this.queue_.addUnhandledRejection(this);\n    }\n    this.queue_.scheduleCallbacks(this);\n  }\n\n  /** @override */\n  cancel(opt_reason) {\n    if (!canCancel(this)) {\n      return;\n    }\n\n    if (this.parent_ && canCancel(this.parent_)) {\n      /** @type {!CancellableThenable} */(this.parent_).cancel(opt_reason);\n    } else {\n      var reason = CancellationError.wrap(opt_reason);\n      let onCancel = ON_CANCEL_HANDLER.get(this);\n      if (onCancel) {\n        onCancel(reason);\n        ON_CANCEL_HANDLER.delete(this);\n      }\n\n      if (this.state_ === PromiseState.BLOCKED) {\n        this.unblockAndResolve_(PromiseState.REJECTED, reason);\n      } else {\n        this.resolve_(PromiseState.REJECTED, reason);\n      }\n    }\n\n    function canCancel(promise) {\n      if (!(promise instanceof ManagedPromise)) {\n        return CancellableThenable.isImplementation(promise);\n      }\n      return promise.state_ === PromiseState.PENDING\n          || promise.state_ === PromiseState.BLOCKED;\n    }\n  }\n\n  /** @override */\n  then(opt_callback, opt_errback) {\n    return this.addCallback_(\n        opt_callback, opt_errback, 'then', ManagedPromise.prototype.then);\n  }\n\n  /** @override */\n  catch(errback) {\n    return this.addCallback_(\n        null, errback, 'catch', ManagedPromise.prototype.catch);\n  }\n\n  /**\n   * @param {function(): (R|IThenable<R>)} callback\n   * @return {!ManagedPromise<R>}\n   * @template R\n   * @see ./promise.finally()\n   */\n  finally(callback) {\n    let result = thenFinally(this, callback);\n    return /** @type {!ManagedPromise} */(result);\n  }\n\n  /**\n   * Registers a new callback with this promise\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @param {string} name The callback name.\n   * @param {!Function} fn The function to use as the top of the stack when\n   *     recording the callback's creation point.\n   * @return {!ManagedPromise<R>} A new promise which will be resolved with the\n   *     result of the invoked callback.\n   * @template R\n   * @private\n   */\n  addCallback_(callback, errback, name, fn) {\n    if (typeof callback !== 'function' && typeof errback !== 'function') {\n      return this;\n    }\n\n    this.handled_ = true;\n    if (this.queue_) {\n      this.queue_.clearUnhandledRejection(this);\n    }\n\n    var cb = new Task(\n        this.flow_,\n        this.invokeCallback_.bind(this, callback, errback),\n        name,\n        LONG_STACK_TRACES ? {name: 'Promise', top: fn} : undefined);\n    cb.promise.parent_ = this;\n\n    if (this.state_ !== PromiseState.PENDING &&\n        this.state_ !== PromiseState.BLOCKED) {\n      this.flow_.getActiveQueue_().enqueue(cb);\n    } else {\n      if (!this.callbacks_) {\n        this.callbacks_ = [];\n      }\n      this.callbacks_.push(cb);\n      cb.blocked = true;\n      this.flow_.getActiveQueue_().enqueue(cb);\n    }\n\n    return cb.promise;\n  }\n\n  /**\n   * Invokes a callback function attached to this promise.\n   * @param {(function(T): (R|IThenable<R>)|null|undefined)} callback The\n   *    fulfillment callback.\n   * @param {(function(*): (R|IThenable<R>)|null|undefined)} errback The\n   *    rejection callback.\n   * @template R\n   * @private\n   */\n  invokeCallback_(callback, errback) {\n    var callbackFn = callback;\n    if (this.state_ === PromiseState.REJECTED) {\n      callbackFn = errback;\n    }\n\n    if (typeof callbackFn === 'function') {\n      if (isGenerator(callbackFn)) {\n        return consume(callbackFn, null, this.value_);\n      }\n      return callbackFn(this.value_);\n    } else if (this.state_ === PromiseState.REJECTED) {\n      throw this.value_;\n    } else {\n      return this.value_;\n    }\n  }\n}\nCancellableThenable.addImplementation(ManagedPromise);\n\n\n/**\n * @param {!ManagedPromise} promise\n * @return {boolean}\n */\nfunction isPending(promise) {\n  return promise.state_ === PromiseState.PENDING;\n}\n\n\n/**\n * Structural interface for a deferred promise resolver.\n * @record\n * @template T\n */\nfunction Resolver() {}\n\n\n/**\n * The promised value for this resolver.\n * @type {!Thenable<T>}\n */\nResolver.prototype.promise;\n\n\n/**\n * Resolves the promised value with the given `value`.\n * @param {T|Thenable<T>} value\n * @return {void}\n */\nResolver.prototype.resolve;\n\n\n/**\n * Rejects the promised value with the given `reason`.\n * @param {*} reason\n * @return {void}\n */\nResolver.prototype.reject;\n\n\n/**\n * Represents a value that will be resolved at some point in the future. This\n * class represents the protected \"producer\" half of a ManagedPromise - each Deferred\n * has a {@code promise} property that may be returned to consumers for\n * registering callbacks, reserving the ability to resolve the deferred to the\n * producer.\n *\n * If this Deferred is rejected and there are no listeners registered before\n * the next turn of the event loop, the rejection will be passed to the\n * {@link ControlFlow} as an unhandled failure.\n *\n * @template T\n * @implements {Resolver<T>}\n */\nclass Deferred {\n  /**\n   * @param {ControlFlow=} opt_flow The control flow this instance was\n   *     created under. This should only be provided during unit tests.\n   * @param {?=} opt_skipLog An internal parameter used to skip logging the\n   *     creation of this promise. This parameter has no effect unless it is\n   *     strictly equal to an internal symbol. In other words, this parameter\n   *     is always ignored for external code.\n   */\n  constructor(opt_flow, opt_skipLog) {\n    var fulfill, reject;\n\n    /** @type {!ManagedPromise<T>} */\n    this.promise = new ManagedPromise(function(f, r) {\n      fulfill = f;\n      reject = r;\n    }, opt_flow, opt_skipLog);\n\n    var self = this;\n    var checkNotSelf = function(value) {\n      if (value === self) {\n        throw new TypeError('May not resolve a Deferred with itself');\n      }\n    };\n\n    /**\n     * Resolves this deferred with the given value. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {(T|IThenable<T>|Thenable)=} opt_value The fulfilled value.\n     * @const\n     */\n    this.resolve = function(opt_value) {\n      checkNotSelf(opt_value);\n      fulfill(opt_value);\n    };\n\n    /**\n     * An alias for {@link #resolve}.\n     * @const\n     */\n    this.fulfill = this.resolve;\n\n    /**\n     * Rejects this promise with the given reason. It is safe to call this as a\n     * normal function (with no bound \"this\").\n     * @param {*=} opt_reason The rejection reason.\n     * @const\n     */\n    this.reject = function(opt_reason) {\n      checkNotSelf(opt_reason);\n      reject(opt_reason);\n    };\n  }\n}\n\n\n/**\n * Tests if a value is an Error-like object. This is more than an straight\n * instanceof check since the value may originate from another context.\n * @param {*} value The value to test.\n * @return {boolean} Whether the value is an error.\n */\nfunction isError(value) {\n  return value instanceof Error ||\n      (!!value && typeof value === 'object'\n          && typeof value.message === 'string');\n}\n\n\n/**\n * Determines whether a {@code value} should be treated as a promise.\n * Any object whose \"then\" property is a function will be considered a promise.\n *\n * @param {?} value The value to test.\n * @return {boolean} Whether the value is a promise.\n */\nfunction isPromise(value) {\n  try {\n    // Use array notation so the Closure compiler does not obfuscate away our\n    // contract.\n    return value\n        && (typeof value === 'object' || typeof value === 'function')\n        && typeof value['then'] === 'function';\n  } catch (ex) {\n    return false;\n  }\n}\n\n\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Thenable} The promise.\n */\nfunction delayed(ms) {\n  return createPromise(resolve => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n\n\n/**\n * Creates a new deferred resolver.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@link Deferred} instance. Otherwise, it will return a resolver for a\n * {@linkplain NativePromise native promise}.\n *\n * @return {!Resolver<T>} A new deferred resolver.\n * @template T\n */\nfunction defer() {\n  if (usePromiseManager()) {\n    return new Deferred();\n  }\n  let resolve, reject;\n  let promise = new NativePromise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {promise, resolve, reject};\n}\n\n\n/**\n * Creates a promise that has been resolved with the given value.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {T=} opt_value The resolved value.\n * @return {!Thenable<T>} The resolved promise.\n * @template T\n */\nfunction fulfilled(opt_value) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  if (opt_value instanceof ctor) {\n    return /** @type {!Thenable} */(opt_value);\n  }\n\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(\n        resolve => resolve(opt_value), undefined, SKIP_LOG);\n  }\n  return NativePromise.resolve(opt_value);\n}\n\n\n/**\n * Creates a promise that has been rejected with the given reason.\n *\n * If the promise manager is currently enabled, this function will return a\n * {@linkplain ManagedPromise managed promise}. Otherwise, it will return a\n * {@linkplain NativePromise native promise}.\n *\n * @param {*=} opt_reason The rejection reason; may be any value, but is\n *     usually an Error or a string.\n * @return {!Thenable<?>} The rejected promise.\n */\nfunction rejected(opt_reason) {\n  if (usePromiseManager()) {\n    // We can skip logging warnings about creating a managed promise because\n    // this function will automatically switch to use a native promise when\n    // the promise manager is disabled.\n    return new ManagedPromise(\n        (_, reject) => reject(opt_reason), undefined, SKIP_LOG);\n  }\n  return NativePromise.reject(opt_reason);\n}\n\n\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} var_args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\nfunction checkedNodeCall(fn, var_args) {\n  let args = Array.prototype.slice.call(arguments, 1);\n  return createPromise(function(fulfill, reject) {\n    try {\n      args.push(function(error, value) {\n        error ? reject(error) : fulfill(value);\n      });\n      fn.apply(undefined, args);\n    } catch (ex) {\n      reject(ex);\n    }\n  });\n}\n\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!IThenable<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\nfunction thenFinally(promise, callback) {\n  let error;\n  let mustThrow = false;\n  return promise.then(function() {\n    return callback();\n  }, function(err) {\n    error = err;\n    mustThrow = true;\n    return callback();\n  }).then(function() {\n    if (mustThrow) {\n      throw error;\n    }\n  });\n}\n\n\n/**\n * Registers an observer on a promised {@code value}, returning a new promise\n * that will be resolved when the value is. If {@code value} is not a promise,\n * then the return promise will be immediately resolved.\n * @param {*} value The value to observe.\n * @param {Function=} opt_callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n * @return {!Thenable} A new promise.\n * @deprecated Use `promise.fulfilled(value).then(opt_callback, opt_errback)`\n */\nfunction when(value, opt_callback, opt_errback) {\n  return fulfilled(value).then(opt_callback, opt_errback);\n}\n\n\n/**\n * Invokes the appropriate callback function as soon as a promised `value` is\n * resolved.\n *\n * @param {*} value The value to observe.\n * @param {Function} callback The function to call when the value is\n *     resolved successfully.\n * @param {Function=} opt_errback The function to call when the value is\n *     rejected.\n */\nfunction asap(value, callback, opt_errback) {\n  if (isPromise(value)) {\n    value.then(callback, opt_errback);\n\n  } else if (callback) {\n    callback(value);\n  }\n}\n\n\n/**\n * Given an array of promises, will return a promise that will be fulfilled\n * with the fulfillment values of the input array's values. If any of the\n * input array's promises are rejected, the returned promise will be rejected\n * with the same reason.\n *\n * @param {!Array<(T|!ManagedPromise<T>)>} arr An array of\n *     promises to wait on.\n * @return {!Thenable<!Array<T>>} A promise that is\n *     fulfilled with an array containing the fulfilled values of the\n *     input array, or rejected with the same reason as the first\n *     rejected value.\n * @template T\n */\nfunction all(arr) {\n  return createPromise(function(fulfill, reject) {\n    var n = arr.length;\n    var values = [];\n\n    if (!n) {\n      fulfill(values);\n      return;\n    }\n\n    var toFulfill = n;\n    var onFulfilled = function(index, value) {\n      values[index] = value;\n      toFulfill--;\n      if (toFulfill == 0) {\n        fulfill(values);\n      }\n    };\n\n    function processPromise(index) {\n      asap(arr[index], function(value) {\n        onFulfilled(index, value);\n      }, reject);\n    }\n\n    for (var i = 0; i < n; ++i) {\n      processPromise(i);\n    }\n  });\n}\n\n\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\nfunction map(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n    var arr = /** @type {!Array} */(v);\n    return createPromise(function(fulfill, reject) {\n      var n = arr.length;\n      var values = new Array(n);\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n        try {\n          asap(\n              fn.call(opt_self, arr[i], i, /** @type {!Array} */(arr)),\n              function(value) {\n                values[i] = value;\n                processNext(i + 1);\n              },\n              reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n\n\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The\n *     array to iterator over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|ManagedPromise<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} opt_self The object to be used as the value of 'this' within\n *     {@code fn}.\n * @template TYPE, SELF\n */\nfunction filter(arr, fn, opt_self) {\n  return createPromise(resolve => resolve(arr)).then(v => {\n    if (!Array.isArray(v)) {\n      throw TypeError('not an array');\n    }\n    var arr = /** @type {!Array} */(v);\n    return createPromise(function(fulfill, reject) {\n      var n = arr.length;\n      var values = [];\n      var valuesLength = 0;\n      (function processNext(i) {\n        for (; i < n; i++) {\n          if (i in arr) {\n            break;\n          }\n        }\n        if (i >= n) {\n          fulfill(values);\n          return;\n        }\n        try {\n          var value = arr[i];\n          var include = fn.call(opt_self, value, i, /** @type {!Array} */(arr));\n          asap(include, function(include) {\n            if (include) {\n              values[valuesLength++] = value;\n            }\n            processNext(i + 1);\n            }, reject);\n        } catch (ex) {\n          reject(ex);\n        }\n      })(0);\n    });\n  });\n}\n\n\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nfunction fullyResolved(value) {\n  if (isPromise(value)) {\n    return fulfilled(value).then(fullyResolveValue);\n  }\n  return fullyResolveValue(value);\n}\n\n\n/**\n * @param {*} value The value to fully resolve. If a promise, assumed to\n *     already be resolved.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nfunction fullyResolveValue(value) {\n  if (Array.isArray(value)) {\n    return fullyResolveKeys(/** @type {!Array} */ (value));\n  }\n\n  if (isPromise(value)) {\n    if (isPromise(value)) {\n      // We get here when the original input value is a promise that\n      // resolves to itself. When the user provides us with such a promise,\n      // trust that it counts as a \"fully resolved\" value and return it.\n      // Of course, since it's already a promise, we can just return it\n      // to the user instead of wrapping it in another promise.\n      return /** @type {!ManagedPromise} */ (value);\n    }\n  }\n\n  if (value && typeof value === 'object') {\n    return fullyResolveKeys(/** @type {!Object} */ (value));\n  }\n\n  if (typeof value === 'function') {\n    return fullyResolveKeys(/** @type {!Object} */ (value));\n  }\n\n  return createPromise(resolve => resolve(value));\n}\n\n\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\nfunction fullyResolveKeys(obj) {\n  var isArray = Array.isArray(obj);\n  var numKeys = isArray ? obj.length : (function() {\n    let n = 0;\n    for (let key in obj) {\n      n += 1;\n    }\n    return n;\n  })();\n\n  if (!numKeys) {\n    return createPromise(resolve => resolve(obj));\n  }\n\n  function forEachProperty(obj, fn) {\n    for (let key in obj) {\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n\n  function forEachElement(arr, fn) {\n    arr.forEach(fn);\n  }\n\n  var numResolved = 0;\n  return createPromise(function(fulfill, reject) {\n    var forEachKey = isArray ? forEachElement: forEachProperty;\n\n    forEachKey(obj, function(partialValue, key) {\n      if (!Array.isArray(partialValue)\n          && (!partialValue || typeof partialValue !== 'object')) {\n        maybeResolveValue();\n        return;\n      }\n\n      fullyResolved(partialValue).then(\n          function(resolvedValue) {\n            obj[key] = resolvedValue;\n            maybeResolveValue();\n          },\n          reject);\n    });\n\n    function maybeResolveValue() {\n      if (++numResolved == numKeys) {\n        fulfill(obj);\n      }\n    }\n  });\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  ControlFlow\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Defines methods for coordinating the execution of asynchronous tasks.\n * @record\n */\nclass Scheduler {\n  /**\n   * Schedules a task for execution. If the task function is a generator, the\n   * task will be executed using {@link ./promise.consume consume()}.\n   *\n   * @param {function(): (T|IThenable<T>)} fn The function to call to start the\n   *     task.\n   * @param {string=} opt_description A description of the task for debugging\n   *     purposes.\n   * @return {!Thenable<T>} A promise that will be resolved with the task\n   *     result.\n   * @template T\n   */\n  execute(fn, opt_description) {}\n\n  /**\n   * Creates a new promise using the given resolver function.\n   *\n   * @param {function(\n   *             function((T|IThenable<T>|Thenable|null)=),\n   *             function(*=))} resolver\n   * @return {!Thenable<T>}\n   * @template T\n   */\n  promise(resolver) {}\n\n  /**\n   * Schedules a `setTimeout` call.\n   *\n   * @param {number} ms The timeout delay, in milliseconds.\n   * @param {string=} opt_description A description to accompany the timeout.\n   * @return {!Thenable<void>} A promise that will be resolved when the timeout\n   *     fires.\n   */\n  timeout(ms, opt_description) {}\n\n  /**\n   * Schedules a task to wait for a condition to hold.\n   *\n   * If the condition is defined as a function, it may return any value. Promise\n   * will be resolved before testing if the condition holds (resolution time\n   * counts towards the timeout). Once resolved, values are always evaluated as\n   * booleans.\n   *\n   * If the condition function throws, or returns a rejected promise, the\n   * wait task will fail.\n   *\n   * If the condition is defined as a promise, the scheduler will wait for it to\n   * settle. If the timeout expires before the promise settles, the promise\n   * returned by this function will be rejected.\n   *\n   * If this function is invoked with `timeout === 0`, or the timeout is\n   * omitted, this scheduler will wait indefinitely for the condition to be\n   * satisfied.\n   *\n   * @param {(!IThenable<T>|function())} condition The condition to poll,\n   *     or a promise to wait on.\n   * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n   *     condition to hold before timing out. If omitted, the flow will wait\n   *     indefinitely.\n   * @param {string=} opt_message An optional error message to include if the\n   *     wait times out; defaults to the empty string.\n   * @return {!Thenable<T>} A promise that will be fulfilled\n   *     when the condition has been satisfied. The promise shall be rejected\n   *     if the wait times out waiting for the condition.\n   * @throws {TypeError} If condition is not a function or promise or if timeout\n   *     is not a number >= 0.\n   * @template T\n   */\n  wait(condition, opt_timeout, opt_message) {}\n}\n\n\nlet USE_PROMISE_MANAGER;\nfunction usePromiseManager() {\n  if (typeof USE_PROMISE_MANAGER !== 'undefined') {\n    return !!USE_PROMISE_MANAGER;\n  }\n  return process.env['SELENIUM_PROMISE_MANAGER'] === undefined\n      || !/^0|false$/i.test(process.env['SELENIUM_PROMISE_MANAGER']);\n}\n\n\n/**\n * Creates a new promise with the given `resolver` function. If the promise\n * manager is currently enabled, the returned promise will be a\n * {@linkplain ManagedPromise} instance. Otherwise, it will be a native promise.\n *\n * @param {function(\n *             function((T|IThenable<T>|Thenable|null)=),\n *             function(*=))} resolver\n * @return {!Thenable<T>}\n * @template T\n */\nfunction createPromise(resolver) {\n  let ctor = usePromiseManager() ? ManagedPromise : NativePromise;\n  return new ctor(resolver);\n}\n\n\n/**\n * @param {!Scheduler} scheduler The scheduler to use.\n * @param {(!IThenable<T>|function())} condition The condition to poll,\n *     or a promise to wait on.\n * @param {number=} opt_timeout How long to wait, in milliseconds, for the\n *     condition to hold before timing out. If omitted, the flow will wait\n *     indefinitely.\n * @param {string=} opt_message An optional error message to include if the\n *     wait times out; defaults to the empty string.\n * @return {!Thenable<T>} A promise that will be fulfilled\n *     when the condition has been satisfied. The promise shall be rejected\n *     if the wait times out waiting for the condition.\n * @throws {TypeError} If condition is not a function or promise or if timeout\n *     is not a number >= 0.\n * @template T\n */\nfunction scheduleWait(scheduler, condition, opt_timeout, opt_message) {\n  let timeout = opt_timeout || 0;\n  if (typeof timeout !== 'number' || timeout < 0) {\n    throw TypeError('timeout must be a number >= 0: ' + timeout);\n  }\n\n  if (isPromise(condition)) {\n    return scheduler.execute(function() {\n      if (!timeout) {\n        return condition;\n      }\n      return scheduler.promise(function(fulfill, reject) {\n        let start = Date.now();\n        let timer = setTimeout(function() {\n          timer = null;\n          reject(\n              new error.TimeoutError(\n                  (opt_message ? opt_message + '\\n' : '')\n                      + 'Timed out waiting for promise to resolve after '\n                      + (Date.now() - start) + 'ms'));\n        }, timeout);\n\n        /** @type {Thenable} */(condition).then(\n          function(value) {\n            timer && clearTimeout(timer);\n            fulfill(value);\n          },\n          function(error) {\n            timer && clearTimeout(timer);\n            reject(error);\n          });\n      });\n    }, opt_message || '<anonymous wait: promise resolution>');\n  }\n\n  if (typeof condition !== 'function') {\n    throw TypeError('Invalid condition; must be a function or promise: ' +\n        typeof condition);\n  }\n\n  if (isGenerator(condition)) {\n    let original = condition;\n    condition = () => consume(original);\n  }\n\n  return scheduler.execute(function() {\n    var startTime = Date.now();\n    return scheduler.promise(function(fulfill, reject) {\n      pollCondition();\n\n      function pollCondition() {\n        var conditionFn = /** @type {function()} */(condition);\n        scheduler.execute(conditionFn).then(function(value) {\n          var elapsed = Date.now() - startTime;\n          if (!!value) {\n            fulfill(value);\n          } else if (timeout && elapsed >= timeout) {\n            reject(\n                new error.TimeoutError(\n                    (opt_message ? opt_message + '\\n' : '')\n                        + `Wait timed out after ${elapsed}ms`));\n          } else {\n            // Do not use asyncRun here because we need a non-micro yield\n            // here so the UI thread is given a chance when running in a\n            // browser.\n            setTimeout(pollCondition, 0);\n          }\n        }, reject);\n      }\n    });\n  }, opt_message || '<anonymous wait>');\n}\n\n\n/**\n * A scheduler that executes all tasks immediately, with no coordination. This\n * class is an event emitter for API compatibility with the {@link ControlFlow},\n * however, it emits no events.\n *\n * @implements {Scheduler}\n */\nclass SimpleScheduler extends events.EventEmitter {\n  /** @override */\n  execute(fn) {\n    return this.promise((resolve, reject) => {\n      try {\n        if (isGenerator(fn)) {\n          consume(fn).then(resolve, reject);\n        } else {\n          resolve(fn.call(undefined));\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    });\n  }\n\n  /** @override */\n  promise(resolver) {\n    return new NativePromise(resolver);\n  }\n\n  /** @override */\n  timeout(ms) {\n    return this.promise(resolve => setTimeout(_ => resolve(), ms));\n  }\n\n  /** @override */\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n}\nconst SIMPLE_SCHEDULER = new SimpleScheduler;\n\n\n/**\n * Handles the execution of scheduled tasks, each of which may be an\n * asynchronous operation. The control flow will ensure tasks are executed in\n * the order scheduled, starting each task only once those before it have\n * completed.\n *\n * Each task scheduled within this flow may return a {@link ManagedPromise} to\n * indicate it is an asynchronous operation. The ControlFlow will wait for such\n * promises to be resolved before marking the task as completed.\n *\n * Tasks and each callback registered on a {@link ManagedPromise} will be run\n * in their own ControlFlow frame. Any tasks scheduled within a frame will take\n * priority over previously scheduled tasks. Furthermore, if any of the tasks in\n * the frame fail, the remainder of the tasks in that frame will be discarded\n * and the failure will be propagated to the user through the callback/task's\n * promised result.\n *\n * Each time a ControlFlow empties its task queue, it will fire an\n * {@link ControlFlow.EventType.IDLE IDLE} event. Conversely, whenever\n * the flow terminates due to an unhandled error, it will remove all\n * remaining tasks in its queue and fire an\n * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION UNCAUGHT_EXCEPTION} event.\n * If there are no listeners registered with the flow, the error will be\n * rethrown to the global error handler.\n *\n * Refer to the {@link ./promise} module documentation for a detailed\n * explanation of how the ControlFlow coordinates task execution.\n *\n * @implements {Scheduler}\n * @final\n */\nclass ControlFlow extends events.EventEmitter {\n  constructor() {\n    if (!usePromiseManager()) {\n      throw TypeError(\n          'Cannot instantiate control flow when the promise manager has'\n              + ' been disabled');\n    }\n\n    super();\n\n    /** @private {boolean} */\n    this.propagateUnhandledRejections_ = true;\n\n    /** @private {TaskQueue} */\n    this.activeQueue_ = null;\n\n    /** @private {Set<TaskQueue>} */\n    this.taskQueues_ = null;\n\n    /**\n     * Microtask that controls shutting down the control flow. Upon shut down,\n     * the flow will emit an\n     * {@link ControlFlow.EventType.IDLE} event. Idle events\n     * always follow a brief timeout in order to catch latent errors from the\n     * last completed task. If this task had a callback registered, but no\n     * errback, and the task fails, the unhandled failure would not be reported\n     * by the promise system until the next turn of the event loop:\n     *\n     *   // Schedule 1 task that fails.\n     *   var result = promise.controlFlow().execute(\n     *       () => promise.rejected('failed'), 'example');\n     *   // Set a callback on the result. This delays reporting the unhandled\n     *   // failure for 1 turn of the event loop.\n     *   result.then(function() {});\n     *\n     * @private {MicroTask}\n     */\n    this.shutdownTask_ = null;\n\n    /**\n     * ID for a long running interval used to keep a Node.js process running\n     * while a control flow's event loop is still working. This is a cheap hack\n     * required since JS events are only scheduled to run when there is\n     * _actually_ something to run. When a control flow is waiting on a task,\n     * there will be nothing in the JS event loop and the process would\n     * terminate without this.\n     * @private\n     */\n    this.hold_ = null;\n  }\n\n  /**\n   * Returns a string representation of this control flow, which is its current\n   * {@linkplain #getSchedule() schedule}, sans task stack traces.\n   * @return {string} The string representation of this control flow.\n   * @override\n   */\n  toString() {\n    return this.getSchedule();\n  }\n\n  /**\n   * Sets whether any unhandled rejections should propagate up through the\n   * control flow stack and cause rejections within parent tasks. If error\n   * propagation is disabled, tasks will not be aborted when an unhandled\n   * promise rejection is detected, but the rejection _will_ trigger an\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   *\n   * The default behavior is to propagate all unhandled rejections. _The use\n   * of this option is highly discouraged._\n   *\n   * @param {boolean} propagate whether to propagate errors.\n   */\n  setPropagateUnhandledRejections(propagate) {\n    this.propagateUnhandledRejections_ = propagate;\n  }\n\n  /**\n   * @return {boolean} Whether this flow is currently idle.\n   */\n  isIdle() {\n    return !this.shutdownTask_ && (!this.taskQueues_ || !this.taskQueues_.size);\n  }\n\n  /**\n   * Resets this instance, clearing its queue and removing all event listeners.\n   */\n  reset() {\n    this.cancelQueues_(new FlowResetError);\n    this.emit(ControlFlow.EventType.RESET);\n    this.removeAllListeners();\n    this.cancelShutdown_();\n  }\n\n  /**\n   * Generates an annotated string describing the internal state of this control\n   * flow, including the currently executing as well as pending tasks. If\n   * {@code opt_includeStackTraces === true}, the string will include the\n   * stack trace from when each task was scheduled.\n   * @param {string=} opt_includeStackTraces Whether to include the stack traces\n   * from when each task was scheduled. Defaults to false.\n   * @return {string} String representation of this flow's internal state.\n   */\n  getSchedule(opt_includeStackTraces) {\n    var ret = 'ControlFlow::' + getUid(this);\n    var activeQueue = this.activeQueue_;\n    if (!this.taskQueues_ || !this.taskQueues_.size) {\n      return ret;\n    }\n    var childIndent = '| ';\n    for (var q of this.taskQueues_) {\n      ret += '\\n' + printQ(q, childIndent);\n    }\n    return ret;\n\n    function printQ(q, indent) {\n      var ret = q.toString();\n      if (q === activeQueue) {\n        ret = '(active) ' + ret;\n      }\n      var prefix = indent + childIndent;\n      if (q.pending_) {\n        if (q.pending_.q.state_ !== TaskQueueState.FINISHED) {\n          ret += '\\n' + prefix + '(pending) ' + q.pending_.task;\n          ret += '\\n' + printQ(q.pending_.q, prefix + childIndent);\n        } else {\n          ret += '\\n' + prefix + '(blocked) ' + q.pending_.task;\n        }\n      }\n      if (q.interrupts_) {\n        q.interrupts_.forEach((task) => {\n          ret += '\\n' + prefix + task;\n        });\n      }\n      if (q.tasks_) {\n        q.tasks_.forEach((task) => ret += printTask(task, '\\n' + prefix));\n      }\n      return indent + ret;\n    }\n\n    function printTask(task, prefix) {\n      var ret = prefix + task;\n      if (opt_includeStackTraces && task.promise.stack_) {\n        ret += prefix + childIndent\n            + (task.promise.stack_.stack || task.promise.stack_)\n                  .replace(/\\n/g, prefix);\n      }\n      return ret;\n    }\n  }\n\n  /**\n   * Returns the currently active task queue for this flow. If there is no\n   * active queue, one will be created.\n   * @return {!TaskQueue} the currently active task queue for this flow.\n   * @private\n   */\n  getActiveQueue_() {\n    if (this.activeQueue_) {\n      return this.activeQueue_;\n    }\n\n    this.activeQueue_ = new TaskQueue(this);\n    if (!this.taskQueues_) {\n      this.taskQueues_ = new Set();\n    }\n    this.taskQueues_.add(this.activeQueue_);\n    this.activeQueue_\n        .once('end', this.onQueueEnd_, this)\n        .once('error', this.onQueueError_, this);\n\n    asyncRun(() => this.activeQueue_ = null);\n    this.activeQueue_.start();\n    return this.activeQueue_;\n  }\n\n  /** @override */\n  execute(fn, opt_description) {\n    if (isGenerator(fn)) {\n      let original = fn;\n      fn = () => consume(original);\n    }\n\n    if (!this.hold_) {\n      let holdIntervalMs = 2147483647;  // 2^31-1; max timer length for Node.js\n      this.hold_ = setInterval(function() {}, holdIntervalMs);\n    }\n\n    let task = new Task(\n        this, fn, opt_description || '<anonymous>',\n        {name: 'Task', top: ControlFlow.prototype.execute},\n        true);\n\n    let q = this.getActiveQueue_();\n\n    for (let i = q.tasks_.length; i > 0; i--) {\n      let previousTask = q.tasks_[i - 1];\n      if (previousTask.userTask_) {\n        FLOW_LOG.warning(() => {\n          return `Detected scheduling of an unchained task.\nWhen the promise manager is disabled, unchained tasks will not wait for\npreviously scheduled tasks to finish before starting to execute.\nNew task: ${task.promise.stack_.stack}\nPrevious task: ${previousTask.promise.stack_.stack}`.split(/\\n/).join('\\n    ');\n        });\n        break;\n      }\n    }\n\n    q.enqueue(task);\n    this.emit(ControlFlow.EventType.SCHEDULE_TASK, task.description);\n    return task.promise;\n  }\n\n  /** @override */\n  promise(resolver) {\n    return new ManagedPromise(resolver, this, SKIP_LOG);\n  }\n\n  /** @override */\n  timeout(ms, opt_description) {\n    return this.execute(() => {\n      return this.promise(resolve => setTimeout(() => resolve(), ms));\n    }, opt_description);\n  }\n\n  /** @override */\n  wait(condition, opt_timeout, opt_message) {\n    return scheduleWait(this, condition, opt_timeout, opt_message);\n  }\n\n  /**\n   * Executes a function in the next available turn of the JavaScript event\n   * loop. This ensures the function runs with its own task queue and any\n   * scheduled tasks will run in \"parallel\" to those scheduled in the current\n   * function.\n   *\n   *     flow.execute(() => console.log('a'));\n   *     flow.execute(() => console.log('b'));\n   *     flow.execute(() => console.log('c'));\n   *     flow.async(() => {\n   *        flow.execute(() => console.log('d'));\n   *        flow.execute(() => console.log('e'));\n   *     });\n   *     flow.async(() => {\n   *        flow.execute(() => console.log('f'));\n   *        flow.execute(() => console.log('g'));\n   *     });\n   *     flow.once('idle', () => console.log('fin'));\n   *     // a\n   *     // d\n   *     // f\n   *     // b\n   *     // e\n   *     // g\n   *     // c\n   *     // fin\n   *\n   * If the function itself throws, the error will be treated the same as an\n   * unhandled rejection within the control flow.\n   *\n   * __NOTE__: This function is considered _unstable_.\n   *\n   * @param {!Function} fn The function to execute.\n   * @param {Object=} opt_self The object in whose context to run the function.\n   * @param {...*} var_args Any arguments to pass to the function.\n   */\n  async(fn, opt_self, var_args) {\n    asyncRun(() => {\n      // Clear any lingering queues, forces getActiveQueue_ to create a new one.\n      this.activeQueue_ = null;\n      var q = this.getActiveQueue_();\n      try {\n        q.execute_(fn.bind(opt_self, var_args));\n      } catch (ex) {\n        var cancellationError = CancellationError.wrap(ex,\n            'Function passed to ControlFlow.async() threw');\n        cancellationError.silent_ = true;\n        q.abort_(cancellationError);\n      } finally {\n        this.activeQueue_ = null;\n      }\n    });\n  }\n\n  /**\n   * Event handler for when a task queue is exhausted. This starts the shutdown\n   * sequence for this instance if there are no remaining task queues: after\n   * one turn of the event loop, this object will emit the\n   * {@link ControlFlow.EventType.IDLE IDLE} event to signal\n   * listeners that it has completed. During this wait, if another task is\n   * scheduled, the shutdown will be aborted.\n   *\n   * @param {!TaskQueue} q the completed task queue.\n   * @private\n   */\n  onQueueEnd_(q) {\n    if (!this.taskQueues_) {\n      return;\n    }\n    this.taskQueues_.delete(q);\n\n    vlog(1, () => q + ' has finished');\n    vlog(1, () => this.taskQueues_.size + ' queues remain\\n' + this, this);\n\n    if (!this.taskQueues_.size) {\n      if (this.shutdownTask_) {\n        throw Error('Already have a shutdown task??');\n      }\n      vlog(1, () => 'Scheduling shutdown\\n' + this);\n      this.shutdownTask_ = new MicroTask(() => this.shutdown_());\n    }\n  }\n\n  /**\n   * Event handler for when a task queue terminates with an error. This triggers\n   * the cancellation of all other task queues and a\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   * If there are no error event listeners registered with this instance, the\n   * error will be rethrown to the global error handler.\n   *\n   * @param {*} error the error that caused the task queue to terminate.\n   * @param {!TaskQueue} q the task queue.\n   * @private\n   */\n  onQueueError_(error, q) {\n    if (this.taskQueues_) {\n      this.taskQueues_.delete(q);\n    }\n    this.cancelQueues_(CancellationError.wrap(\n        error, 'There was an uncaught error in the control flow'));\n    this.cancelShutdown_();\n    this.cancelHold_();\n\n    setTimeout(() => {\n      let listeners = this.listeners(ControlFlow.EventType.UNCAUGHT_EXCEPTION);\n      if (!listeners.size) {\n        throw error;\n      } else {\n        this.reportUncaughtException_(error);\n      }\n    }, 0);\n  }\n\n  /**\n   * Cancels all remaining task queues.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n  cancelQueues_(reason) {\n    reason.silent_ = true;\n    if (this.taskQueues_) {\n      for (var q of this.taskQueues_) {\n        q.removeAllListeners();\n        q.abort_(reason);\n      }\n      this.taskQueues_.clear();\n      this.taskQueues_ = null;\n    }\n  }\n\n  /**\n   * Reports an uncaught exception using a\n   * {@link ControlFlow.EventType.UNCAUGHT_EXCEPTION} event.\n   *\n   * @param {*} e the error to report.\n   * @private\n   */\n  reportUncaughtException_(e) {\n    this.emit(ControlFlow.EventType.UNCAUGHT_EXCEPTION, e);\n  }\n\n  /** @private */\n  cancelHold_() {\n    if (this.hold_) {\n      clearInterval(this.hold_);\n      this.hold_ = null;\n    }\n  }\n\n  /** @private */\n  shutdown_() {\n    vlog(1, () => 'Going idle: ' + this);\n    this.cancelHold_();\n    this.shutdownTask_ = null;\n    this.emit(ControlFlow.EventType.IDLE);\n  }\n\n  /**\n   * Cancels the shutdown sequence if it is currently scheduled.\n   * @private\n   */\n  cancelShutdown_() {\n    if (this.shutdownTask_) {\n      this.shutdownTask_.cancel();\n      this.shutdownTask_ = null;\n    }\n  }\n}\n\n\n/**\n * Events that may be emitted by an {@link ControlFlow}.\n * @enum {string}\n */\nControlFlow.EventType = {\n\n  /** Emitted when all tasks have been successfully executed. */\n  IDLE: 'idle',\n\n  /** Emitted when a ControlFlow has been reset. */\n  RESET: 'reset',\n\n  /** Emitted whenever a new task has been scheduled. */\n  SCHEDULE_TASK: 'scheduleTask',\n\n  /**\n   * Emitted whenever a control flow aborts due to an unhandled promise\n   * rejection. This event will be emitted along with the offending rejection\n   * reason. Upon emitting this event, the control flow will empty its task\n   * queue and revert to its initial state.\n   */\n  UNCAUGHT_EXCEPTION: 'uncaughtException'\n};\n\n\n/**\n * Wraps a function to execute as a cancellable micro task.\n * @final\n */\nclass MicroTask {\n  /**\n   * @param {function()} fn The function to run as a micro task.\n   */\n  constructor(fn) {\n    /** @private {boolean} */\n    this.cancelled_ = false;\n    asyncRun(() => {\n      if (!this.cancelled_) {\n        fn();\n      }\n    });\n  }\n\n  /**\n   * Runs the given function after a microtask yield.\n   * @param {function()} fn The function to run.\n   */\n  static run(fn) {\n    NativePromise.resolve().then(function() {\n      try {\n        fn();\n      } catch (ignored) {\n        // Do nothing.\n      }\n    });\n  }\n\n  /**\n   * Cancels the execution of this task. Note: this will not prevent the task\n   * timer from firing, just the invocation of the wrapped function.\n   */\n  cancel() {\n    this.cancelled_ = true;\n  }\n}\n\n\n/**\n * A task to be executed by a {@link ControlFlow}.\n *\n * @template T\n * @final\n */\nclass Task extends Deferred {\n  /**\n   * @param {!ControlFlow} flow The flow this instances belongs\n   *     to.\n   * @param {function(): (T|!ManagedPromise<T>)} fn The function to\n   *     call when the task executes. If it returns a\n   *     {@link ManagedPromise}, the flow will wait for it to be\n   *     resolved before starting the next task.\n   * @param {string} description A description of the task for debugging.\n   * @param {{name: string, top: !Function}=} opt_stackOptions Options to use\n   *     when capturing the stacktrace for when this task was created.\n   * @param {boolean=} opt_isUserTask Whether this task was explicitly scheduled\n   *     by the use of the promise manager.\n   */\n  constructor(flow, fn, description, opt_stackOptions, opt_isUserTask) {\n    super(flow, SKIP_LOG);\n    getUid(this);\n\n    /** @type {function(): (T|!ManagedPromise<T>)} */\n    this.execute = fn;\n\n    /** @type {string} */\n    this.description = description;\n\n    /** @type {TaskQueue} */\n    this.queue = null;\n\n    /** @private @const {boolean} */\n    this.userTask_ = !!opt_isUserTask;\n\n    /**\n     * Whether this task is considered block. A blocked task may be registered\n     * in a task queue, but will be dropped if it is still blocked when it\n     * reaches the front of the queue. A dropped task may always be rescheduled.\n     *\n     * Blocked tasks are used when a callback is attached to an unsettled\n     * promise to reserve a spot in line (in a manner of speaking). If the\n     * promise is not settled before the callback reaches the front of the\n     * of the queue, it will be dropped. Once the promise is settled, the\n     * dropped task will be rescheduled as an interrupt on the currently task\n     * queue.\n     *\n     * @type {boolean}\n     */\n    this.blocked = false;\n\n    if (opt_stackOptions) {\n      this.promise.stack_ = captureStackTrace(\n          opt_stackOptions.name, this.description, opt_stackOptions.top);\n    }\n  }\n\n  /** @override */\n  toString() {\n    return 'Task::' + getUid(this) + '<' + this.description + '>';\n  }\n}\n\n\n/** @enum {string} */\nconst TaskQueueState = {\n  NEW: 'new',\n  STARTED: 'started',\n  FINISHED: 'finished'\n};\n\n\n/**\n * @final\n */\nclass TaskQueue extends events.EventEmitter {\n  /** @param {!ControlFlow} flow . */\n  constructor(flow) {\n    super();\n\n    /** @private {string} */\n    this.name_ = 'TaskQueue::' + getUid(this);\n\n    /** @private {!ControlFlow} */\n    this.flow_ = flow;\n\n    /** @private {!Array<!Task>} */\n    this.tasks_ = [];\n\n    /** @private {Array<!Task>} */\n    this.interrupts_ = null;\n\n    /** @private {({task: !Task, q: !TaskQueue}|null)} */\n    this.pending_ = null;\n\n    /** @private {TaskQueue} */\n    this.subQ_ = null;\n\n    /** @private {TaskQueueState} */\n    this.state_ = TaskQueueState.NEW;\n\n    /** @private {!Set<!ManagedPromise>} */\n    this.unhandledRejections_ = new Set();\n  }\n\n  /** @override */\n  toString() {\n    return 'TaskQueue::' + getUid(this);\n  }\n\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n  addUnhandledRejection(promise) {\n    // TODO: node 4.0.0+\n    vlog(2, () => this + ' registering unhandled rejection: ' + promise, this);\n    this.unhandledRejections_.add(promise);\n  }\n\n  /**\n   * @param {!ManagedPromise} promise .\n   */\n  clearUnhandledRejection(promise) {\n    var deleted = this.unhandledRejections_.delete(promise);\n    if (deleted) {\n      // TODO: node 4.0.0+\n      vlog(2, () => this + ' clearing unhandled rejection: ' + promise, this);\n    }\n  }\n\n  /**\n   * Enqueues a new task for execution.\n   * @param {!Task} task The task to enqueue.\n   * @throws {Error} If this instance has already started execution.\n   */\n  enqueue(task) {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw Error('TaskQueue has started: ' + this);\n    }\n\n    if (task.queue) {\n      throw Error('Task is already scheduled in another queue');\n    }\n\n    this.tasks_.push(task);\n    task.queue = this;\n    ON_CANCEL_HANDLER.set(\n        task.promise,\n        (e) => this.onTaskCancelled_(task, e));\n\n    vlog(1, () => this + '.enqueue(' + task + ')', this);\n    vlog(2, () => this.flow_.toString(), this);\n  }\n\n  /**\n   * Schedules the callbacks registered on the given promise in this queue.\n   *\n   * @param {!ManagedPromise} promise the promise whose callbacks should be\n   *     registered as interrupts in this task queue.\n   * @throws {Error} if this queue has already finished.\n   */\n  scheduleCallbacks(promise) {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      throw new Error('cannot interrupt a finished q(' + this + ')');\n    }\n\n    if (this.pending_ && this.pending_.task.promise === promise) {\n      this.pending_.task.promise.queue_ = null;\n      this.pending_ = null;\n      asyncRun(() => this.executeNext_());\n    }\n\n    if (!promise.callbacks_) {\n      return;\n    }\n    promise.callbacks_.forEach(function(cb) {\n      cb.blocked = false;\n      if (cb.queue) {\n        return;\n      }\n\n      ON_CANCEL_HANDLER.set(\n          cb.promise,\n          (e) => this.onTaskCancelled_(cb, e));\n\n      if (cb.queue === this && this.tasks_.indexOf(cb) !== -1) {\n        return;\n      }\n\n      if (cb.queue) {\n        cb.queue.dropTask_(cb);\n      }\n\n      cb.queue = this;\n      if (!this.interrupts_) {\n        this.interrupts_ = [];\n      }\n      this.interrupts_.push(cb);\n    }, this);\n    promise.callbacks_ = null;\n    vlog(2, () => this + ' interrupted\\n' + this.flow_, this);\n  }\n\n  /**\n   * Starts executing tasks in this queue. Once called, no further tasks may\n   * be {@linkplain #enqueue() enqueued} with this instance.\n   *\n   * @throws {Error} if this queue has already been started.\n   */\n  start() {\n    if (this.state_ !== TaskQueueState.NEW) {\n      throw new Error('TaskQueue has already started');\n    }\n    // Always asynchronously execute next, even if there doesn't look like\n    // there is anything in the queue. This will catch pending unhandled\n    // rejections that were registered before start was called.\n    asyncRun(() => this.executeNext_());\n  }\n\n  /**\n   * Aborts this task queue. If there are any scheduled tasks, they are silently\n   * cancelled and discarded (their callbacks will never fire). If this queue\n   * has a _pending_ task, the abortion error is used to cancel that task.\n   * Otherwise, this queue will emit an error event.\n   *\n   * @param {*} error The abortion reason.\n   * @private\n   */\n  abort_(error) {\n    var cancellation;\n\n    if (error instanceof FlowResetError) {\n      cancellation = error;\n    } else {\n      cancellation = new DiscardedTaskError(error);\n    }\n\n    if (this.interrupts_ && this.interrupts_.length) {\n      this.interrupts_.forEach((t) => t.reject(cancellation));\n      this.interrupts_ = [];\n    }\n\n    if (this.tasks_ && this.tasks_.length) {\n      this.tasks_.forEach((t) => t.reject(cancellation));\n      this.tasks_ = [];\n    }\n\n    // Now that all of the remaining tasks have been silently cancelled (e.g. no\n    // existing callbacks on those tasks will fire), clear the silence bit on\n    // the cancellation error. This ensures additional callbacks registered in\n    // the future will actually execute.\n    cancellation.silent_ = false;\n\n    if (this.pending_) {\n      vlog(2, () => this + '.abort(); cancelling pending task', this);\n      this.pending_.task.promise.cancel(\n          /** @type {!CancellationError} */(error));\n\n    } else {\n      vlog(2, () => this + '.abort(); emitting error event', this);\n      this.emit('error', error, this);\n    }\n  }\n\n  /** @private */\n  executeNext_() {\n    if (this.state_ === TaskQueueState.FINISHED) {\n      return;\n    }\n    this.state_ = TaskQueueState.STARTED;\n\n    if (this.pending_ !== null || this.processUnhandledRejections_()) {\n      return;\n    }\n\n    var task;\n    do {\n      task = this.getNextTask_();\n    } while (task && !isPending(task.promise));\n\n    if (!task) {\n      this.state_ = TaskQueueState.FINISHED;\n      this.tasks_ = [];\n      this.interrupts_ = null;\n      vlog(2, () => this + '.emit(end)', this);\n      this.emit('end', this);\n      return;\n    }\n\n    let result = undefined;\n    this.subQ_ = new TaskQueue(this.flow_);\n\n    this.subQ_.once('end', () => {  // On task completion.\n      this.subQ_ = null;\n      this.pending_ && this.pending_.task.resolve(result);\n    });\n\n    this.subQ_.once('error', e => {  // On task failure.\n      this.subQ_ = null;\n      if (Thenable.isImplementation(result)) {\n        result.cancel(CancellationError.wrap(e));\n      }\n      this.pending_ && this.pending_.task.reject(e);\n    });\n    vlog(2, () => `${this} created ${this.subQ_} for ${task}`);\n\n    try {\n      this.pending_ = {task: task, q: this.subQ_};\n      task.promise.queue_ = this;\n      result = this.subQ_.execute_(task.execute);\n      this.subQ_.start();\n    } catch (ex) {\n      this.subQ_.abort_(ex);\n    }\n  }\n\n  /**\n   * @param {!Function} fn .\n   * @return {T} .\n   * @template T\n   * @private\n   */\n  execute_(fn) {\n    try {\n      activeFlows.push(this.flow_);\n      this.flow_.activeQueue_ = this;\n      return fn();\n    } finally {\n      this.flow_.activeQueue_ = null;\n      activeFlows.pop();\n    }\n  }\n\n  /**\n   * Process any unhandled rejections registered with this task queue. If there\n   * is a rejection, this queue will be aborted with the rejection error. If\n   * there are multiple rejections registered, this queue will be aborted with\n   * a {@link MultipleUnhandledRejectionError}.\n   * @return {boolean} whether there was an unhandled rejection.\n   * @private\n   */\n  processUnhandledRejections_() {\n    if (!this.unhandledRejections_.size) {\n      return false;\n    }\n\n    var errors = new Set();\n    for (var rejection of this.unhandledRejections_) {\n      errors.add(rejection.value_);\n    }\n    this.unhandledRejections_.clear();\n\n    var errorToReport = errors.size === 1\n        ? errors.values().next().value\n        : new MultipleUnhandledRejectionError(errors);\n\n    vlog(1, () => this + ' aborting due to unhandled rejections', this);\n    if (this.flow_.propagateUnhandledRejections_) {\n      this.abort_(errorToReport);\n      return true;\n    } else {\n      vlog(1, 'error propagation disabled; reporting to control flow');\n      this.flow_.reportUncaughtException_(errorToReport);\n      return false;\n    }\n  }\n\n  /**\n   * @param {!Task} task The task to drop.\n   * @private\n   */\n  dropTask_(task) {\n    var index;\n    if (this.interrupts_) {\n      index = this.interrupts_.indexOf(task);\n      if (index != -1) {\n        task.queue = null;\n        this.interrupts_.splice(index, 1);\n        return;\n      }\n    }\n\n    index = this.tasks_.indexOf(task);\n    if (index != -1) {\n      task.queue = null;\n      this.tasks_.splice(index, 1);\n    }\n  }\n\n  /**\n   * @param {!Task} task The task that was cancelled.\n   * @param {!CancellationError} reason The cancellation reason.\n   * @private\n   */\n  onTaskCancelled_(task, reason) {\n    if (this.pending_ && this.pending_.task === task) {\n      this.pending_.q.abort_(reason);\n    } else {\n      this.dropTask_(task);\n    }\n  }\n\n  /**\n   * @return {(Task|undefined)} the next task scheduled within this queue,\n   *     if any.\n   * @private\n   */\n  getNextTask_() {\n    var task = undefined;\n    while (true) {\n      if (this.interrupts_) {\n        task = this.interrupts_.shift();\n      }\n      if (!task && this.tasks_) {\n        task = this.tasks_.shift();\n      }\n      if (task && task.blocked) {\n        vlog(2, () => this + ' skipping blocked task ' + task, this);\n        task.queue = null;\n        task = null;\n        // TODO: recurse when tail-call optimization is available in node.\n      } else {\n        break;\n      }\n    }\n    return task;\n  }\n}\n\n\n\n/**\n * The default flow to use if no others are active.\n * @type {ControlFlow}\n */\nvar defaultFlow;\n\n\n/**\n * A stack of active control flows, with the top of the stack used to schedule\n * commands. When there are multiple flows on the stack, the flow at index N\n * represents a callback triggered within a task owned by the flow at index\n * N-1.\n * @type {!Array<!ControlFlow>}\n */\nvar activeFlows = [];\n\n\n/**\n * Changes the default flow to use when no others are active.\n * @param {!ControlFlow} flow The new default flow.\n * @throws {Error} If the default flow is not currently active.\n */\nfunction setDefaultFlow(flow) {\n  if (!usePromiseManager()) {\n    throw Error(\n        'You  may not change set the control flow when the promise'\n            +' manager is disabled');\n  }\n  if (activeFlows.length) {\n    throw Error('You may only change the default flow while it is active');\n  }\n  defaultFlow = flow;\n}\n\n\n/**\n * @return {!ControlFlow} The currently active control flow.\n * @suppress {checkTypes}\n */\nfunction controlFlow() {\n  if (!usePromiseManager()) {\n    return SIMPLE_SCHEDULER;\n  }\n\n  if (activeFlows.length) {\n    return activeFlows[activeFlows.length - 1];\n  }\n\n  if (!defaultFlow) {\n    defaultFlow = new ControlFlow;\n  }\n  return defaultFlow;\n}\n\n\n/**\n * Creates a new control flow. The provided callback will be invoked as the\n * first task within the new flow, with the flow as its sole argument. Returns\n * a promise that resolves to the callback result.\n * @param {function(!ControlFlow)} callback The entry point\n *     to the newly created flow.\n * @return {!Thenable} A promise that resolves to the callback result.\n */\nfunction createFlow(callback) {\n  var flow = new ControlFlow;\n  return flow.execute(function() {\n    return callback(flow);\n  });\n}\n\n\n/**\n * Tests is a function is a generator.\n * @param {!Function} fn The function to test.\n * @return {boolean} Whether the function is a generator.\n */\nfunction isGenerator(fn) {\n  return fn.constructor.name === 'GeneratorFunction';\n}\n\n\n/**\n * Consumes a {@code GeneratorFunction}. Each time the generator yields a\n * promise, this function will wait for it to be fulfilled before feeding the\n * fulfilled value back into {@code next}. Likewise, if a yielded promise is\n * rejected, the rejection error will be passed to {@code throw}.\n *\n * __Example 1:__ the Fibonacci Sequence.\n *\n *     promise.consume(function* fibonacci() {\n *       var n1 = 1, n2 = 1;\n *       for (var i = 0; i < 4; ++i) {\n *         var tmp = yield n1 + n2;\n *         n1 = n2;\n *         n2 = tmp;\n *       }\n *       return n1 + n2;\n *     }).then(function(result) {\n *       console.log(result);  // 13\n *     });\n *\n * __Example 2:__ a generator that throws.\n *\n *     promise.consume(function* () {\n *       yield promise.delayed(250).then(function() {\n *         throw Error('boom');\n *       });\n *     }).catch(function(e) {\n *       console.log(e.toString());  // Error: boom\n *     });\n *\n * @param {!Function} generatorFn The generator function to execute.\n * @param {Object=} opt_self The object to use as \"this\" when invoking the\n *     initial generator.\n * @param {...*} var_args Any arguments to pass to the initial generator.\n * @return {!Thenable<?>} A promise that will resolve to the\n *     generator's final result.\n * @throws {TypeError} If the given function is not a generator.\n */\nfunction consume(generatorFn, opt_self, ...var_args) {\n  if (!isGenerator(generatorFn)) {\n    throw new TypeError('Input is not a GeneratorFunction: ' +\n        generatorFn.constructor.name);\n  }\n\n  let ret;\n  return ret = createPromise((resolve, reject) => {\n    let generator = generatorFn.apply(opt_self, var_args);\n    callNext();\n\n    /** @param {*=} opt_value . */\n    function callNext(opt_value) {\n      pump(generator.next, opt_value);\n    }\n\n    /** @param {*=} opt_error . */\n    function callThrow(opt_error) {\n      pump(generator.throw, opt_error);\n    }\n\n    function pump(fn, opt_arg) {\n      if (ret instanceof ManagedPromise && !isPending(ret)) {\n        return;  // Deferred was cancelled; silently abort.\n      }\n\n      try {\n        var result = fn.call(generator, opt_arg);\n      } catch (ex) {\n        reject(ex);\n        return;\n      }\n\n      if (result.done) {\n        resolve(result.value);\n        return;\n      }\n\n      asap(result.value, callNext, callThrow);\n    }\n  });\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  CancellableThenable: CancellableThenable,\n  CancellationError: CancellationError,\n  ControlFlow: ControlFlow,\n  Deferred: Deferred,\n  MultipleUnhandledRejectionError: MultipleUnhandledRejectionError,\n  Thenable: Thenable,\n  Promise: ManagedPromise,\n  Resolver: Resolver,\n  Scheduler: Scheduler,\n  all: all,\n  asap: asap,\n  captureStackTrace: captureStackTrace,\n  checkedNodeCall: checkedNodeCall,\n  consume: consume,\n  controlFlow: controlFlow,\n  createFlow: createFlow,\n  createPromise: createPromise,\n  defer: defer,\n  delayed: delayed,\n  filter: filter,\n  finally: thenFinally,\n  fulfilled: fulfilled,\n  fullyResolved: fullyResolved,\n  isGenerator: isGenerator,\n  isPromise: isPromise,\n  map: map,\n  rejected: rejected,\n  setDefaultFlow: setDefaultFlow,\n  when: when,\n\n  /**\n   * Indicates whether the promise manager is currently enabled. When disabled,\n   * attempting to use the {@link ControlFlow} or {@link ManagedPromise Promise}\n   * classes will generate an error.\n   *\n   * The promise manager is currently enabled by default, but may be disabled\n   * by setting the environment variable `SELENIUM_PROMISE_MANAGER=0` or by\n   * setting this property to false. Setting this property will always take\n   * precedence over the use of the environment variable.\n   *\n   * @return {boolean} Whether the promise manager is enabled.\n   * @see <https://github.com/SeleniumHQ/selenium/issues/2969>\n   */\n  get USE_PROMISE_MANAGER() { return usePromiseManager(); },\n  set USE_PROMISE_MANAGER(/** boolean */value) { USE_PROMISE_MANAGER = value; },\n\n  get LONG_STACK_TRACES() { return LONG_STACK_TRACES; },\n  set LONG_STACK_TRACES(v) { LONG_STACK_TRACES = v; },\n};\n"]},"metadata":{},"sourceType":"script"}