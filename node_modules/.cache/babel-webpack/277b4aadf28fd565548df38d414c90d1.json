{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar http = require(\"http\");\n\nvar angular_wait_barrier_1 = require(\"./angular_wait_barrier\");\n\nvar highlight_delay_barrier_1 = require(\"./highlight_delay_barrier\");\n\nvar simple_webdriver_client_1 = require(\"./simple_webdriver_client\");\n\nvar webdriver_proxy_1 = require(\"./webdriver_proxy\");\n\nexports.BP_PREFIX = 'bpproxy';\n/**\n * The stability proxy is an http server responsible for intercepting\n * JSON webdriver commands. It keeps track of whether the page under test\n * needs to wait for page stability, and initiates a wait if so.\n */\n\nvar BlockingProxy = /*#__PURE__*/function () {\n  function BlockingProxy(seleniumAddress) {\n    var highlightDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, BlockingProxy);\n\n    this.server = http.createServer(this.requestListener.bind(this));\n    this.proxy = new webdriver_proxy_1.WebDriverProxy(seleniumAddress);\n    var client = new simple_webdriver_client_1.SimpleWebDriverClient(seleniumAddress);\n    this.waitBarrier = new angular_wait_barrier_1.AngularWaitBarrier(client);\n    this.highlightBarrier = new highlight_delay_barrier_1.HighlightDelayBarrier(client, highlightDelay);\n    this.proxy.addBarrier(this.waitBarrier);\n    this.proxy.addBarrier(this.highlightBarrier);\n  }\n  /**\n   * This command is for the proxy server, not to be forwarded to Selenium.\n   */\n\n\n  _createClass(BlockingProxy, [{\n    key: \"enableLogging\",\n\n    /**\n     * Turn on WebDriver logging.\n     *\n     * @param logDir The directory to create logs in.\n     */\n    value: function enableLogging(logDir) {\n      this.waitBarrier.enableLogging(logDir);\n    }\n    /**\n     * Override the logger instance. Only used for testing.\n     */\n\n  }, {\n    key: \"setLogger\",\n    value: function setLogger(logger) {\n      this.waitBarrier.setLogger(logger);\n    }\n    /**\n     * Change the parameters used by the wait function.\n     */\n\n  }, {\n    key: \"setWaitParams\",\n    value: function setWaitParams(rootEl) {\n      this.waitBarrier.setRootSelector(rootEl);\n    }\n  }, {\n    key: \"handleProxyCommand\",\n    value: function handleProxyCommand(message, data, response) {\n      var command = message.url.split('/')[2];\n\n      switch (command) {\n        case 'waitEnabled':\n          if (message.method === 'GET') {\n            response.writeHead(200);\n            response.write(JSON.stringify({\n              value: this.waitBarrier.enabled\n            }));\n            response.end();\n          } else if (message.method === 'POST') {\n            response.writeHead(200);\n            this.waitBarrier.enabled = JSON.parse(data).value;\n            response.end();\n          } else {\n            response.writeHead(405);\n            response.write('Invalid method');\n            response.end();\n          }\n\n          break;\n\n        case 'waitParams':\n          if (message.method === 'GET') {\n            response.writeHead(200);\n            response.write(JSON.stringify({\n              rootSelector: this.waitBarrier.rootSelector\n            }));\n            response.end();\n          } else if (message.method === 'POST') {\n            response.writeHead(200);\n            this.waitBarrier.rootSelector = JSON.parse(data).rootSelector;\n            response.end();\n          } else {\n            response.writeHead(405);\n            response.write('Invalid method');\n            response.end();\n          }\n\n          break;\n\n        default:\n          response.writeHead(404);\n          response.write('Unknown stabilizer proxy command');\n          response.end();\n      }\n    }\n  }, {\n    key: \"requestListener\",\n    value: function requestListener(originalRequest, response) {\n      var _this = this;\n\n      if (BlockingProxy.isProxyCommand(originalRequest.url)) {\n        var commandData = '';\n        originalRequest.on('data', function (d) {\n          commandData += d;\n        });\n        originalRequest.on('end', function () {\n          _this.handleProxyCommand(originalRequest, commandData, response);\n        });\n        return;\n      } // OK to ignore the promise returned by this.\n\n\n      this.proxy.handleRequest(originalRequest, response);\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(port) {\n      this.server.listen(port);\n      var actualPort = this.server.address().port;\n      return actualPort;\n    }\n  }, {\n    key: \"quit\",\n    value: function quit() {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        _this2.server.close(resolve);\n      });\n    }\n  }], [{\n    key: \"isProxyCommand\",\n    value: function isProxyCommand(commandPath) {\n      return commandPath.split('/')[1] === exports.BP_PREFIX;\n    }\n  }]);\n\n  return BlockingProxy;\n}();\n\nexports.BlockingProxy = BlockingProxy;","map":{"version":3,"sources":["../../lib/blockingproxy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst angular_wait_barrier_1 = require(\"./angular_wait_barrier\");\nconst highlight_delay_barrier_1 = require(\"./highlight_delay_barrier\");\nconst simple_webdriver_client_1 = require(\"./simple_webdriver_client\");\nconst webdriver_proxy_1 = require(\"./webdriver_proxy\");\nexports.BP_PREFIX = 'bpproxy';\n/**\n * The stability proxy is an http server responsible for intercepting\n * JSON webdriver commands. It keeps track of whether the page under test\n * needs to wait for page stability, and initiates a wait if so.\n */\nclass BlockingProxy {\n    constructor(seleniumAddress, highlightDelay = null) {\n        this.server = http.createServer(this.requestListener.bind(this));\n        this.proxy = new webdriver_proxy_1.WebDriverProxy(seleniumAddress);\n        let client = new simple_webdriver_client_1.SimpleWebDriverClient(seleniumAddress);\n        this.waitBarrier = new angular_wait_barrier_1.AngularWaitBarrier(client);\n        this.highlightBarrier = new highlight_delay_barrier_1.HighlightDelayBarrier(client, highlightDelay);\n        this.proxy.addBarrier(this.waitBarrier);\n        this.proxy.addBarrier(this.highlightBarrier);\n    }\n    /**\n     * This command is for the proxy server, not to be forwarded to Selenium.\n     */\n    static isProxyCommand(commandPath) {\n        return (commandPath.split('/')[1] === exports.BP_PREFIX);\n    }\n    /**\n     * Turn on WebDriver logging.\n     *\n     * @param logDir The directory to create logs in.\n     */\n    enableLogging(logDir) {\n        this.waitBarrier.enableLogging(logDir);\n    }\n    /**\n     * Override the logger instance. Only used for testing.\n     */\n    setLogger(logger) {\n        this.waitBarrier.setLogger(logger);\n    }\n    /**\n     * Change the parameters used by the wait function.\n     */\n    setWaitParams(rootEl) {\n        this.waitBarrier.setRootSelector(rootEl);\n    }\n    handleProxyCommand(message, data, response) {\n        let command = message.url.split('/')[2];\n        switch (command) {\n            case 'waitEnabled':\n                if (message.method === 'GET') {\n                    response.writeHead(200);\n                    response.write(JSON.stringify({ value: this.waitBarrier.enabled }));\n                    response.end();\n                }\n                else if (message.method === 'POST') {\n                    response.writeHead(200);\n                    this.waitBarrier.enabled = JSON.parse(data).value;\n                    response.end();\n                }\n                else {\n                    response.writeHead(405);\n                    response.write('Invalid method');\n                    response.end();\n                }\n                break;\n            case 'waitParams':\n                if (message.method === 'GET') {\n                    response.writeHead(200);\n                    response.write(JSON.stringify({ rootSelector: this.waitBarrier.rootSelector }));\n                    response.end();\n                }\n                else if (message.method === 'POST') {\n                    response.writeHead(200);\n                    this.waitBarrier.rootSelector = JSON.parse(data).rootSelector;\n                    response.end();\n                }\n                else {\n                    response.writeHead(405);\n                    response.write('Invalid method');\n                    response.end();\n                }\n                break;\n            default:\n                response.writeHead(404);\n                response.write('Unknown stabilizer proxy command');\n                response.end();\n        }\n    }\n    requestListener(originalRequest, response) {\n        if (BlockingProxy.isProxyCommand(originalRequest.url)) {\n            let commandData = '';\n            originalRequest.on('data', (d) => {\n                commandData += d;\n            });\n            originalRequest.on('end', () => {\n                this.handleProxyCommand(originalRequest, commandData, response);\n            });\n            return;\n        }\n        // OK to ignore the promise returned by this.\n        this.proxy.handleRequest(originalRequest, response);\n    }\n    listen(port) {\n        this.server.listen(port);\n        let actualPort = this.server.address().port;\n        return actualPort;\n    }\n    quit() {\n        return new Promise((resolve) => {\n            this.server.close(resolve);\n        });\n    }\n}\nexports.BlockingProxy = BlockingProxy;\n//# sourceMappingURL=blockingproxy.js.map"]},"metadata":{},"sourceType":"script"}