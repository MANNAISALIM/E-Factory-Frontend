{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n/**\n * Describes an event listener registered on an {@linkplain EventEmitter}.\n */\n\nvar _createForOfIteratorHelper = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar Listener =\n/**\n * @param {!Function} fn The actual listener function.\n * @param {(Object|undefined)} scope The object in whose scope to invoke the\n *     listener.\n * @param {boolean} oneshot Whether this listener should only be used once.\n */\nfunction Listener(fn, scope, oneshot) {\n  _classCallCheck(this, Listener);\n\n  this.fn = fn;\n  this.scope = scope;\n  this.oneshot = oneshot;\n};\n/** @type {!WeakMap<!EventEmitter, !Map<string, !Set<!Listener>>>} */\n\n\nvar EVENTS = new WeakMap();\n/**\n * Object that can emit events for others to listen for.\n */\n\nvar EventEmitter = /*#__PURE__*/function () {\n  function EventEmitter() {\n    _classCallCheck(this, EventEmitter);\n  }\n\n  _createClass(EventEmitter, [{\n    key: \"emit\",\n\n    /**\n     * Fires an event and calls all listeners.\n     * @param {string} type The type of event to emit.\n     * @param {...*} var_args Any arguments to pass to each listener.\n     */\n    value: function emit(type, var_args) {\n      var events = EVENTS.get(this);\n\n      if (!events) {\n        return;\n      }\n\n      var args = Array.prototype.slice.call(arguments, 1);\n      var listeners = events.get(type);\n\n      if (listeners) {\n        var _iterator = _createForOfIteratorHelper(listeners),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var listener = _step.value;\n            listener.fn.apply(listener.scope, args);\n\n            if (listener.oneshot) {\n              listeners.delete(listener);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n    /**\n     * Returns a mutable list of listeners for a specific type of event.\n     * @param {string} type The type of event to retrieve the listeners for.\n     * @return {!Set<!Listener>} The registered listeners for the given event\n     *     type.\n     */\n\n  }, {\n    key: \"listeners\",\n    value: function listeners(type) {\n      var events = EVENTS.get(this);\n\n      if (!events) {\n        events = new Map();\n        EVENTS.set(this, events);\n      }\n\n      var listeners = events.get(type);\n\n      if (!listeners) {\n        listeners = new Set();\n        events.set(type, listeners);\n      }\n\n      return listeners;\n    }\n    /**\n     * Registers a listener.\n     * @param {string} type The type of event to listen for.\n     * @param {!Function} fn The function to invoke when the event is fired.\n     * @param {Object=} opt_self The object in whose scope to invoke the listener.\n     * @param {boolean=} opt_oneshot Whether the listener should b (e removed after\n     *    the first event is fired.\n     * @return {!EventEmitter} A self reference.\n     * @private\n     */\n\n  }, {\n    key: \"addListener_\",\n    value: function addListener_(type, fn, opt_self, opt_oneshot) {\n      var listeners = this.listeners(type);\n\n      var _iterator2 = _createForOfIteratorHelper(listeners),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var listener = _step2.value;\n\n          if (listener.fn === fn) {\n            return this;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      listeners.add(new Listener(fn, opt_self || undefined, !!opt_oneshot));\n      return this;\n    }\n    /**\n     * Registers a listener.\n     * @param {string} type The type of event to listen for.\n     * @param {!Function} fn The function to invoke when the event is fired.\n     * @param {Object=} opt_self The object in whose scope to invoke the listener.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"addListener\",\n    value: function addListener(type, fn, opt_self) {\n      return this.addListener_(type, fn, opt_self, false);\n    }\n    /**\n     * Registers a one-time listener which will be called only the first time an\n     * event is emitted, after which it will be removed.\n     * @param {string} type The type of event to listen for.\n     * @param {!Function} fn The function to invoke when the event is fired.\n     * @param {Object=} opt_self The object in whose scope to invoke the listener.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(type, fn, opt_self) {\n      return this.addListener_(type, fn, opt_self, true);\n    }\n    /**\n     * An alias for {@link #addListener() addListener()}.\n     * @param {string} type The type of event to listen for.\n     * @param {!Function} fn The function to invoke when the event is fired.\n     * @param {Object=} opt_self The object in whose scope to invoke the listener.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(type, fn, opt_self) {\n      return this.addListener(type, fn, opt_self);\n    }\n    /**\n     * Removes a previously registered event listener.\n     * @param {string} type The type of event to unregister.\n     * @param {!Function} listenerFn The handler function to remove.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(type, listenerFn) {\n      if (typeof type !== 'string' || typeof listenerFn !== 'function') {\n        throw TypeError('invalid args: expected (string, function), got (' + typeof type + ', ' + typeof listenerFn + ')');\n      }\n\n      var events = EVENTS.get(this);\n\n      if (!events) {\n        return this;\n      }\n\n      var listeners = events.get(type);\n\n      if (!listeners) {\n        return this;\n      }\n\n      var match;\n\n      var _iterator3 = _createForOfIteratorHelper(listeners),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var listener = _step3.value;\n\n          if (listener.fn === listenerFn) {\n            match = listener;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (match) {\n        listeners.delete(match);\n\n        if (!listeners.size) {\n          events.delete(type);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Removes all listeners for a specific type of event. If no event is\n     * specified, all listeners across all types will be removed.\n     * @param {string=} opt_type The type of event to remove listeners from.\n     * @return {!EventEmitter} A self reference.\n     */\n\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(opt_type) {\n      var events = EVENTS.get(this);\n\n      if (events) {\n        if (typeof opt_type === 'string') {\n          events.delete(opt_type);\n        } else {\n          EVENTS.delete(this);\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return EventEmitter;\n}(); // PUBLIC API\n\n\nmodule.exports = {\n  EventEmitter: EventEmitter,\n  Listener: Listener\n};","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/selenium-webdriver/lib/events.js"],"names":["Listener","fn","scope","oneshot","EVENTS","WeakMap","EventEmitter","type","var_args","events","get","args","Array","prototype","slice","call","arguments","listeners","listener","apply","delete","Map","set","Set","opt_self","opt_oneshot","add","undefined","addListener_","addListener","listenerFn","TypeError","match","size","opt_type","module","exports"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n'use strict';\n\n/**\n * Describes an event listener registered on an {@linkplain EventEmitter}.\n */\nclass Listener {\n  /**\n   * @param {!Function} fn The actual listener function.\n   * @param {(Object|undefined)} scope The object in whose scope to invoke the\n   *     listener.\n   * @param {boolean} oneshot Whether this listener should only be used once.\n   */\n  constructor(fn, scope, oneshot) {\n    this.fn = fn;\n    this.scope = scope;\n    this.oneshot = oneshot;\n  }\n}\n\n\n/** @type {!WeakMap<!EventEmitter, !Map<string, !Set<!Listener>>>} */\nconst EVENTS = new WeakMap;\n\n\n/**\n * Object that can emit events for others to listen for.\n */\nclass EventEmitter {\n  /**\n   * Fires an event and calls all listeners.\n   * @param {string} type The type of event to emit.\n   * @param {...*} var_args Any arguments to pass to each listener.\n   */\n  emit(type, var_args) {\n    let events = EVENTS.get(this);\n    if (!events) {\n      return;\n    }\n\n    let args = Array.prototype.slice.call(arguments, 1);\n\n    let listeners = events.get(type);\n    if (listeners) {\n      for (let listener of listeners) {\n        listener.fn.apply(listener.scope, args);\n        if (listener.oneshot) {\n          listeners.delete(listener);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns a mutable list of listeners for a specific type of event.\n   * @param {string} type The type of event to retrieve the listeners for.\n   * @return {!Set<!Listener>} The registered listeners for the given event\n   *     type.\n   */\n  listeners(type) {\n    let events = EVENTS.get(this);\n    if (!events) {\n      events = new Map;\n      EVENTS.set(this, events);\n    }\n\n    let listeners = events.get(type);\n    if (!listeners) {\n      listeners = new Set;\n      events.set(type, listeners);\n    }\n    return listeners;\n  }\n\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @param {boolean=} opt_oneshot Whether the listener should b (e removed after\n   *    the first event is fired.\n   * @return {!EventEmitter} A self reference.\n   * @private\n   */\n  addListener_(type, fn, opt_self, opt_oneshot) {\n    let listeners = this.listeners(type);\n    for (let listener of listeners) {\n      if (listener.fn === fn) {\n        return this;\n      }\n    }\n    listeners.add(new Listener(fn, opt_self || undefined, !!opt_oneshot));\n    return this;\n  }\n\n  /**\n   * Registers a listener.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  addListener(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, false);\n  }\n\n  /**\n   * Registers a one-time listener which will be called only the first time an\n   * event is emitted, after which it will be removed.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  once(type, fn, opt_self) {\n    return this.addListener_(type, fn, opt_self, true);\n  }\n\n  /**\n   * An alias for {@link #addListener() addListener()}.\n   * @param {string} type The type of event to listen for.\n   * @param {!Function} fn The function to invoke when the event is fired.\n   * @param {Object=} opt_self The object in whose scope to invoke the listener.\n   * @return {!EventEmitter} A self reference.\n   */\n  on(type, fn, opt_self) {\n    return this.addListener(type, fn, opt_self);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   * @param {string} type The type of event to unregister.\n   * @param {!Function} listenerFn The handler function to remove.\n   * @return {!EventEmitter} A self reference.\n   */\n  removeListener(type, listenerFn) {\n    if (typeof type !== 'string' || typeof listenerFn !== 'function') {\n      throw TypeError('invalid args: expected (string, function), got ('\n          + (typeof type) + ', ' + (typeof listenerFn) + ')');\n    }\n\n    let events = EVENTS.get(this);\n    if (!events) {\n      return this;\n    }\n\n    let listeners = events.get(type);\n    if (!listeners) {\n      return this;\n    }\n\n    let match;\n    for (let listener of listeners) {\n      if (listener.fn === listenerFn) {\n        match = listener;\n        break;\n      }\n    }\n    if (match) {\n      listeners.delete(match);\n      if (!listeners.size) {\n        events.delete(type);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Removes all listeners for a specific type of event. If no event is\n   * specified, all listeners across all types will be removed.\n   * @param {string=} opt_type The type of event to remove listeners from.\n   * @return {!EventEmitter} A self reference.\n   */\n  removeAllListeners(opt_type) {\n    let events = EVENTS.get(this);\n    if (events) {\n      if (typeof opt_type === 'string') {\n        events.delete(opt_type);\n      } else {\n        EVENTS.delete(this);\n      }\n    }\n    return this;\n  }\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  EventEmitter: EventEmitter,\n  Listener: Listener\n};\n"]},"metadata":{},"sourceType":"script"}