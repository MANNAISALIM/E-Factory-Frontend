{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nvar locators_1 = require(\"./locators\");\n\nvar logger_1 = require(\"./logger\");\n\nvar util_1 = require(\"./util\");\n\nvar clientSideScripts = require('./clientsidescripts');\n\nvar logger = new logger_1.Logger('element');\n\nvar WebdriverWebElement = function WebdriverWebElement() {\n  _classCallCheck(this, WebdriverWebElement);\n};\n\nexports.WebdriverWebElement = WebdriverWebElement;\nvar WEB_ELEMENT_FUNCTIONS = ['click', 'sendKeys', 'getTagName', 'getCssValue', 'getAttribute', 'getText', 'getSize', 'getLocation', 'isEnabled', 'isSelected', 'submit', 'clear', 'isDisplayed', 'getId', 'takeScreenshot'];\n/**\n * ElementArrayFinder is used for operations on an array of elements (as opposed\n * to a single element).\n *\n * The ElementArrayFinder is used to set up a chain of conditions that identify\n * an array of elements. In particular, you can call all(locator) and\n * filter(filterFn) to return a new ElementArrayFinder modified by the\n * conditions, and you can call get(index) to return a single ElementFinder at\n * position 'index'.\n *\n * Similar to jquery, ElementArrayFinder will search all branches of the DOM\n * to find the elements that satisfy the conditions (i.e. all, filter, get).\n * However, an ElementArrayFinder will not actually retrieve the elements until\n * an action is called, which means it can be set up in helper files (i.e.\n * page objects) before the page is available, and reused as the page changes.\n *\n * You can treat an ElementArrayFinder as an array of WebElements for most\n * purposes, in particular, you may perform actions (i.e. click, getText) on\n * them as you would an array of WebElements. The action will apply to\n * every element identified by the ElementArrayFinder. ElementArrayFinder\n * extends Promise, and once an action is performed on an ElementArrayFinder,\n * the latest result can be accessed using then, and will be returned as an\n * array of the results; the array has length equal to the length of the\n * elements found by the ElementArrayFinder and each result represents the\n * result of performing the action on the element. Unlike a WebElement, an\n * ElementArrayFinder will wait for the angular app to settle before\n * performing finds or actions.\n *\n * @alias element.all(locator)\n * @view\n * <ul class=\"items\">\n *   <li>First</li>\n *   <li>Second</li>\n *   <li>Third</li>\n * </ul>\n *\n * @example\n * element.all(by.css('.items li')).then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * // Or using the shortcut $$() notation instead of element.all(by.css()):\n *\n * $$('.items li').then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * @constructor\n * @param {ProtractorBrowser} browser A browser instance.\n * @param {function(): Array.<webdriver.WebElement>} getWebElements A function\n *    that returns a list of the underlying Web Elements.\n * @param {webdriver.Locator} locator The most relevant locator. It is only\n *    used for error reporting and ElementArrayFinder.locator.\n * @param {Array.<webdriver.promise.Promise>} opt_actionResults An array\n *    of promises which will be retrieved with then. Resolves to the latest\n *    action result, or null if no action has been called.\n * @returns {ElementArrayFinder}\n */\n\nvar ElementArrayFinder = /*#__PURE__*/function (_WebdriverWebElement) {\n  _inherits(ElementArrayFinder, _WebdriverWebElement);\n\n  var _super = _createSuper(ElementArrayFinder);\n\n  function ElementArrayFinder(browser_) {\n    var _this;\n\n    var getWebElements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var locator_ = arguments.length > 2 ? arguments[2] : undefined;\n    var actionResults_ = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, ElementArrayFinder);\n\n    _this = _super.call(this);\n    _this.browser_ = browser_;\n    _this.getWebElements = getWebElements;\n    _this.locator_ = locator_;\n    _this.actionResults_ = actionResults_; // TODO(juliemr): might it be easier to combine this with our docs and just\n    // wrap each one explicity with its own documentation?\n\n    WEB_ELEMENT_FUNCTIONS.forEach(function (fnName) {\n      _this[fnName] = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var actionFn = function actionFn(webElem) {\n          return webElem[fnName].apply(webElem, args);\n        };\n\n        return _this.applyAction_(actionFn);\n      };\n    });\n    return _this;\n  }\n  /**\n   * Create a shallow copy of ElementArrayFinder.\n   *\n   * @returns {!ElementArrayFinder} A shallow copy of this.\n   */\n\n\n  _createClass(ElementArrayFinder, [{\n    key: \"clone\",\n    value: function clone() {\n      // A shallow copy is all we need since the underlying fields can never be\n      // modified. (Locator can be modified by the user, but that should\n      // rarely/never happen and it doesn't affect functionalities).\n      return new ElementArrayFinder(this.browser_, this.getWebElements, this.locator_, this.actionResults_);\n    }\n    /**\n     * Calls to ElementArrayFinder may be chained to find an array of elements\n     * using the current elements in this ElementArrayFinder as the starting\n     * point. This function returns a new ElementArrayFinder which would contain\n     * the children elements found (and could also be empty).\n     *\n     * @alias element.all(locator).all(locator)\n     * @view\n     * <div id='id1' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">1a</li>\n     *     <li class=\"baz\">1b</li>\n     *   </ul>\n     * </div>\n     * <div id='id2' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">2a</li>\n     *     <li class=\"bar\">2b</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let foo = element.all(by.css('.parent')).all(by.css('.foo'));\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = element.all(by.css('.parent')).all(by.css('.baz'));\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = element.all(by.css('.parent'))\n     *   .all(by.css('.NONEXISTENT'));\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let foo = $$('.parent').$$('.foo');\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = $$('.parent').$$('.baz');\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = $$('.parent').$$('.NONEXISTENT');\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n\n  }, {\n    key: \"all\",\n    value: function all(locator) {\n      var _this2 = this;\n\n      var ptor = this.browser_;\n\n      var getWebElements = function getWebElements() {\n        if (_this2.getWebElements === null) {\n          // This is the first time we are looking for an element\n          return ptor.waitForAngular('Locator: ' + locator).then(function () {\n            if (locators_1.isProtractorLocator(locator)) {\n              return locator.findElementsOverride(ptor.driver, null, ptor.rootEl);\n            } else {\n              return ptor.driver.findElements(locator);\n            }\n          });\n        } else {\n          return _this2.getWebElements().then(function (parentWebElements) {\n            // For each parent web element, find their children and construct\n            // a list of Promise<List<child_web_element>>\n            var childrenPromiseList = parentWebElements.map(function (parentWebElement) {\n              return locators_1.isProtractorLocator(locator) ? locator.findElementsOverride(ptor.driver, parentWebElement, ptor.rootEl) : parentWebElement.findElements(locator);\n            }); // Resolve the list of Promise<List<child_web_elements>> and merge\n            // into a single list\n\n            return selenium_webdriver_1.promise.all(childrenPromiseList).then(function (resolved) {\n              return resolved.reduce(function (childrenList, resolvedE) {\n                return childrenList.concat(resolvedE);\n              }, []);\n            });\n          });\n        }\n      };\n\n      return new ElementArrayFinder(this.browser_, getWebElements, locator);\n    }\n    /**\n     * Apply a filter function to each element within the ElementArrayFinder.\n     * Returns a new ElementArrayFinder with all elements that pass the filter\n     * function. The filter function receives the ElementFinder as the first\n     * argument and the index as a second arg. This does not actually retrieve\n     * the underlying list of elements, so it can be used in page objects.\n     *\n     * @alias element.all(locator).filter(filterFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * @param {function(ElementFinder, number): webdriver.WebElement.Promise}\n     * filterFn\n     *     Filter function that will test if an element should be returned.\n     *     filterFn can either return a boolean or a promise that resolves to a\n     * boolean\n     * @returns {!ElementArrayFinder} A ElementArrayFinder that represents an\n     * array\n     *     of element that satisfy the filter function.\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(filterFn) {\n      var _this3 = this;\n\n      var getWebElements = function getWebElements() {\n        return _this3.getWebElements().then(function (parentWebElements) {\n          var list = parentWebElements.map(function (parentWebElement, index) {\n            var elementFinder = ElementFinder.fromWebElement_(_this3.browser_, parentWebElement, _this3.locator_);\n            return filterFn(elementFinder, index);\n          });\n          return selenium_webdriver_1.promise.all(list).then(function (resolvedList) {\n            return parentWebElements.filter(function (parentWebElement, index) {\n              return resolvedList[index];\n            });\n          });\n        });\n      };\n\n      return new ElementArrayFinder(this.browser_, getWebElements, this.locator_);\n    }\n    /**\n     * Get an element within the ElementArrayFinder by index. The index starts at 0.\n     * Negative indices are wrapped (i.e. -i means ith element from last)\n     * This does not actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).get(index)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {number|webdriver.promise.Promise} index Element index.\n     * @returns {ElementFinder} finder representing element at the given index.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      var _this4 = this;\n\n      var getWebElements = function getWebElements() {\n        return selenium_webdriver_1.promise.all([index, _this4.getWebElements()]).then(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              i = _ref2[0],\n              parentWebElements = _ref2[1];\n\n          if (i < 0) {\n            i += parentWebElements.length;\n          }\n\n          if (i < 0 || i >= parentWebElements.length) {\n            throw new selenium_webdriver_1.error.NoSuchElementError('Index out of bound. Trying to access element at index: ' + index + ', but there are only ' + parentWebElements.length + ' elements that match ' + 'locator ' + _this4.locator_.toString());\n          }\n\n          return [parentWebElements[i]];\n        });\n      };\n\n      return new ElementArrayFinder(this.browser_, getWebElements, this.locator_).toElementFinder_();\n    }\n    /**\n     * Get the first matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).first()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let first = element.all(by.css('.items li')).first();\n     * expect(first.getText()).toBe('First');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let first = $$('.items li').first();\n     * expect(first.getText()).toBe('First');\n     *\n     * @returns {ElementFinder} finder representing the first matching element\n     */\n\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.get(0);\n    }\n  }, {\n    key: \"last\",\n\n    /**\n     * Get the last matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).last()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let last = element.all(by.css('.items li')).last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let last = $$('.items li').last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * @returns {ElementFinder} finder representing the last matching element\n     */\n    value: function last() {\n      return this.get(-1);\n    }\n    /**\n     * Shorthand function for finding arrays of elements by css.\n     * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n     *\n     * @alias $$(cssSelector)\n     * @view\n     * <div class=\"count\">\n     *   <span class=\"one\">First</span>\n     *   <span class=\"two\">Second</span>\n     * </div>\n     *\n     * @example\n     * // The following two blocks of code are equivalent.\n     * let list = element.all(by.css('.count span'));\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.count span');\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder} which identifies the\n     *     array of the located {@link webdriver.WebElement}s.\n     */\n\n  }, {\n    key: \"$$\",\n    value: function $$(selector) {\n      return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Returns an ElementFinder representation of ElementArrayFinder. It ensures\n     * that the ElementArrayFinder resolves to one and only one underlying\n     * element.\n     *\n     * @returns {ElementFinder} An ElementFinder representation\n     * @private\n     */\n\n  }, {\n    key: \"toElementFinder_\",\n    value: function toElementFinder_() {\n      return new ElementFinder(this.browser_, this);\n    }\n    /**\n     * Count the number of elements represented by the ElementArrayFinder.\n     *\n     * @alias element.all(locator).count()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.count()).toBe(3);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.count()).toBe(3);\n     *\n     * @returns {!webdriver.promise.Promise} A promise which resolves to the\n     *     number of elements matching the locator.\n     */\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.getWebElements().then(function (arr) {\n        return arr.length;\n      }, function (err) {\n        if (err instanceof selenium_webdriver_1.error.NoSuchElementError) {\n          return 0;\n        } else {\n          throw err;\n        }\n      });\n    }\n    /**\n     * Returns true if there are any elements present that match the finder.\n     *\n     * @alias element.all(locator).isPresent()\n     *\n     * @example\n     * expect($('.item').isPresent()).toBeTruthy();\n     *\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"isPresent\",\n    value: function isPresent() {\n      return this.count().then(function (count) {\n        return count > 0;\n      });\n    }\n    /**\n     * Returns the most relevant locator.\n     *\n     * @example\n     * // returns by.css('#ID1')\n     * $('#ID1').locator();\n     *\n     * // returns by.css('#ID2')\n     * $('#ID1').$('#ID2').locator();\n     *\n     * // returns by.css('#ID1')\n     * $$('#ID1').filter(filterFn).get(0).click().locator();\n     *\n     * @returns {webdriver.Locator}\n     */\n\n  }, {\n    key: \"locator\",\n    value: function locator() {\n      return this.locator_;\n    }\n    /**\n     * Apply an action function to every element in the ElementArrayFinder,\n     * and return a new ElementArrayFinder that contains the results of the\n     * actions.\n     *\n     * @param {function(ElementFinder)} actionFn\n     *\n     * @returns {ElementArrayFinder}\n     * @private\n     */\n    // map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n\n  }, {\n    key: \"applyAction_\",\n    value: function applyAction_(actionFn) {\n      var _this5 = this;\n\n      var callerError = new Error();\n      var actionResults = this.getWebElements().then(function (arr) {\n        return selenium_webdriver_1.promise.all(arr.map(actionFn));\n      }).then(function (value) {\n        return {\n          passed: true,\n          value: value\n        };\n      }, function (error) {\n        return {\n          passed: false,\n          value: error\n        };\n      });\n\n      var getWebElements = function getWebElements() {\n        return actionResults.then(function () {\n          return _this5.getWebElements();\n        });\n      };\n\n      actionResults = actionResults.then(function (result) {\n        if (result.passed) {\n          return result.value;\n        } else {\n          var noSuchErr;\n\n          if (result.value instanceof Error) {\n            noSuchErr = result.value;\n            noSuchErr.stack = noSuchErr.stack + callerError.stack;\n          } else {\n            noSuchErr = new Error(result.value);\n            noSuchErr.stack = callerError.stack;\n          }\n\n          throw noSuchErr;\n        }\n      });\n      return new ElementArrayFinder(this.browser_, getWebElements, this.locator_, actionResults);\n    }\n    /**\n     * Represents the ElementArrayFinder as an array of ElementFinders.\n     *\n     * @returns {Array.<ElementFinder>} Return a promise, which resolves to a list\n     *     of ElementFinders specified by the locator.\n     */\n\n  }, {\n    key: \"asElementFinders_\",\n    value: function asElementFinders_() {\n      var _this6 = this;\n\n      return this.getWebElements().then(function (arr) {\n        return arr.map(function (webElem) {\n          return ElementFinder.fromWebElement_(_this6.browser_, webElem, _this6.locator_);\n        });\n      });\n    }\n    /**\n     * Retrieve the elements represented by the ElementArrayFinder. The input\n     * function is passed to the resulting promise, which resolves to an\n     * array of ElementFinders.\n     *\n     * @alias element.all(locator).then(thenFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * @param {function(Array.<ElementFinder>)} fn\n     * @param {function(Error)} errorFn\n     *\n     * @returns {!webdriver.promise.Promise} A promise which will resolve to\n     *     an array of ElementFinders represented by the ElementArrayFinder.\n     */\n\n  }, {\n    key: \"then\",\n    value: function then(fn, errorFn) {\n      if (this.actionResults_) {\n        return this.actionResults_.then(fn, errorFn);\n      } else {\n        return this.asElementFinders_().then(fn, errorFn);\n      }\n    }\n    /**\n     * Calls the input function on each ElementFinder represented by the\n     * ElementArrayFinder.\n     *\n     * @alias element.all(locator).each(eachFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * @param {function(ElementFinder)} fn Input function\n     *\n     * @returns {!webdriver.promise.Promise} A promise that will resolve when the\n     *     function has been called on all the ElementFinders. The promise will\n     *     resolve to null.\n     */\n\n  }, {\n    key: \"each\",\n    value: function each(fn) {\n      return this.map(fn).then(function () {\n        return null;\n      });\n    }\n    /**\n     * Apply a map function to each element within the ElementArrayFinder. The\n     * callback receives the ElementFinder as the first argument and the index as\n     * a second arg.\n     *\n     * @alias element.all(locator).map(mapFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let items = element.all(by.css('.items li')).map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let items = $$('.items li').map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * @param {function(ElementFinder, number)} mapFn Map function that\n     *     will be applied to each element.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to an array\n     *     of values returned by the map function.\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(mapFn) {\n      return this.asElementFinders_().then(function (arr) {\n        var list = arr.map(function (elementFinder, index) {\n          var mapResult = mapFn(elementFinder, index); // All nested arrays and objects will also be fully resolved.\n\n          return selenium_webdriver_1.promise.fullyResolved(mapResult);\n        });\n        return selenium_webdriver_1.promise.all(list);\n      });\n    }\n  }, {\n    key: \"reduce\",\n\n    /**\n     * Apply a reduce function against an accumulator and every element found\n     * using the locator (from left-to-right). The reduce function has to reduce\n     * every element into a single value (the accumulator). Returns promise of\n     * the accumulator. The reduce function receives the accumulator, current\n     * ElementFinder, the index, and the entire array of ElementFinders,\n     * respectively.\n     *\n     * @alias element.all(locator).reduce(reduceFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.items li').reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n     *     reduceFn Reduce function that reduces every element into a single\n     * value.\n     * @param {*} initialValue Initial value of the accumulator.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to the final\n     *     value of the accumulator.\n     */\n    value: function reduce(reduceFn, initialValue) {\n      var valuePromise = selenium_webdriver_1.promise.when(initialValue);\n      return this.asElementFinders_().then(function (arr) {\n        return arr.reduce(function (valuePromise, elementFinder, index) {\n          return valuePromise.then(function (value) {\n            return reduceFn(value, elementFinder, index, arr);\n          });\n        }, valuePromise);\n      });\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current underlying\n     * elements.\n     *\n     * @view\n     * <span class=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.foo').evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementArrayFinder} which resolves to the\n     *     evaluated expression for each underlying element.\n     *     The result will be resolved as in\n     *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n     *     be resolved as is, functions will be converted to string, and elements\n     *     will be returned as a WebElement.\n     */\n\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(expression) {\n      var evaluationFn = function evaluationFn(webElem) {\n        return webElem.getDriver().executeScript(clientSideScripts.evaluate, webElem, expression);\n      };\n\n      return this.applyAction_(evaluationFn);\n    }\n    /**\n     * Determine if animation is allowed on the current underlying elements.\n     * @param {string} value\n     *\n     * @example\n     * // Turns off ng-animate animations for all elements in the <body>\n     * element(by.css('body')).allowAnimations(false);\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * $('body').allowAnimations(false);\n     *\n     * @returns {ElementArrayFinder} which resolves to whether animation is\n     * allowed.\n     */\n\n  }, {\n    key: \"allowAnimations\",\n    value: function allowAnimations(value) {\n      var allowAnimationsTestFn = function allowAnimationsTestFn(webElem) {\n        return webElem.getDriver().executeScript(clientSideScripts.allowAnimations, webElem, value);\n      };\n\n      return this.applyAction_(allowAnimationsTestFn);\n    }\n  }]);\n\n  return ElementArrayFinder;\n}(WebdriverWebElement);\n\nexports.ElementArrayFinder = ElementArrayFinder;\n/**\n * The ElementFinder simply represents a single element of an\n * ElementArrayFinder (and is more like a convenience object). As a result,\n * anything that can be done with an ElementFinder, can also be done using\n * an ElementArrayFinder.\n *\n * The ElementFinder can be treated as a WebElement for most purposes, in\n * particular, you may perform actions (i.e. click, getText) on them as you\n * would a WebElement. Once an action is performed on an ElementFinder, the\n * latest result from the chain can be accessed using the then method.\n * Unlike a WebElement, an ElementFinder will wait for angular to settle before\n * performing finds or actions.\n *\n * ElementFinder can be used to build a chain of locators that is used to find\n * an element. An ElementFinder does not actually attempt to find the element\n * until an action is called, which means they can be set up in helper files\n * before the page is available.\n *\n * @alias element(locator)\n * @view\n * <span>{{person.name}}</span>\n * <span ng-bind=\"person.email\"></span>\n * <input type=\"text\" ng-model=\"person.name\"/>\n *\n * @example\n * // Find element with {{scopelet}} syntax.\n * element(by.binding('person.name')).getText().then(function(name) {\n *   expect(name).toBe('Foo');\n * });\n *\n * // Find element with ng-bind=\"scopelet\" syntax.\n * expect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n *\n * // Find by model.\n * let input = element(by.model('person.name'));\n * input.sendKeys('123');\n * expect(input.getAttribute('value')).toBe('Foo123');\n *\n * @constructor\n * @extends {webdriver.WebElement}\n * @param {ProtractorBrowser} browser_ A browser instance.\n * @param {ElementArrayFinder} elementArrayFinder The ElementArrayFinder\n *     that this is branched from.\n * @returns {ElementFinder}\n */\n\nvar ElementFinder = /*#__PURE__*/function (_WebdriverWebElement2) {\n  _inherits(ElementFinder, _WebdriverWebElement2);\n\n  var _super2 = _createSuper(ElementFinder);\n\n  function ElementFinder(browser_, elementArrayFinder) {\n    var _this7;\n\n    _classCallCheck(this, ElementFinder);\n\n    _this7 = _super2.call(this);\n    _this7.browser_ = browser_;\n    _this7.then = null;\n\n    if (!elementArrayFinder) {\n      throw new Error('BUG: elementArrayFinder cannot be empty');\n    }\n\n    _this7.parentElementArrayFinder = elementArrayFinder; // Only have a `then` method if the parent element array finder\n    // has action results.\n\n    if (_this7.parentElementArrayFinder.actionResults_) {\n      // Access the underlying actionResult of ElementFinder.\n      _this7.then = function (fn, errorFn) {\n        return _this7.elementArrayFinder_.then(function (actionResults) {\n          if (!fn) {\n            return actionResults[0];\n          }\n\n          return fn(actionResults[0]);\n        }, errorFn);\n      };\n    } // This filter verifies that there is only 1 element returned by the\n    // elementArrayFinder. It will warn if there are more than 1 element and\n    // throw an error if there are no elements.\n\n\n    var getWebElements = function getWebElements() {\n      return elementArrayFinder.getWebElements().then(function (webElements) {\n        if (webElements.length === 0) {\n          throw new selenium_webdriver_1.error.NoSuchElementError('No element found using locator: ' + elementArrayFinder.locator().toString());\n        } else {\n          if (webElements.length > 1) {\n            logger.warn('more than one element found for locator ' + elementArrayFinder.locator().toString() + ' - the first result will be used');\n          }\n\n          return [webElements[0]];\n        }\n      });\n    }; // Store a copy of the underlying elementArrayFinder, but with the more\n    // restrictive getWebElements (which checks that there is only 1 element).\n\n\n    _this7.elementArrayFinder_ = new ElementArrayFinder(_this7.browser_, getWebElements, elementArrayFinder.locator(), elementArrayFinder.actionResults_);\n    WEB_ELEMENT_FUNCTIONS.forEach(function (fnName) {\n      _this7[fnName] = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return _this7.elementArrayFinder_[fnName].apply(_this7.elementArrayFinder_, args).toElementFinder_();\n      };\n    });\n    return _this7;\n  }\n\n  _createClass(ElementFinder, [{\n    key: \"clone\",\n\n    /**\n     * Create a shallow copy of ElementFinder.\n     *\n     * @returns {!ElementFinder} A shallow copy of this.\n     */\n    value: function clone() {\n      // A shallow copy is all we need since the underlying fields can never be\n      // modified\n      return new ElementFinder(this.browser_, this.parentElementArrayFinder);\n    }\n    /**\n     * @see ElementArrayFinder.prototype.locator\n     *\n     * @returns {webdriver.Locator}\n     */\n\n  }, {\n    key: \"locator\",\n    value: function locator() {\n      return this.elementArrayFinder_.locator();\n    }\n    /**\n     * Returns the WebElement represented by this ElementFinder.\n     * Throws the WebDriver error if the element doesn't exist.\n     *\n     * @alias element(locator).getWebElement()\n     * @view\n     * <div class=\"parent\">\n     *   some text\n     * </div>\n     *\n     * @example\n     * // The following four expressions are equivalent.\n     * $('.parent').getWebElement();\n     * element(by.css('.parent')).getWebElement();\n     * browser.driver.findElement(by.css('.parent'));\n     * browser.findElement(by.css('.parent'));\n     *\n     * @returns {webdriver.WebElementPromise}\n     */\n\n  }, {\n    key: \"getWebElement\",\n    value: function getWebElement() {\n      var id = this.elementArrayFinder_.getWebElements().then(function (parentWebElements) {\n        return parentWebElements[0];\n      });\n      return new selenium_webdriver_1.WebElementPromise(this.browser_.driver, id);\n    }\n    /**\n     * Calls to {@code all} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).all(by.tagName('li'));\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').all(by.tagName('li'));\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n\n  }, {\n    key: \"all\",\n    value: function all(subLocator) {\n      return this.elementArrayFinder_.all(subLocator);\n    }\n    /**\n     * Calls to {@code element} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).element(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     element(by.css('.child'));\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     element(by.css('.child')).\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementFinder}\n     */\n\n  }, {\n    key: \"element\",\n    value: function element(subLocator) {\n      return this.all(subLocator).toElementFinder_();\n    }\n    /**\n     * Calls to {@code $$} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).$$('li');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').$$('li');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder}\n     */\n\n  }, {\n    key: \"$$\",\n    value: function $$(selector) {\n      return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Calls to {@code $} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).$(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     $('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     $('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {string} selector A css selector\n     * @returns {ElementFinder}\n     */\n\n  }, {\n    key: \"$\",\n    value: function $(selector) {\n      return this.element(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Determine whether the element is present on the page.\n     *\n     * @view\n     * <span>{{person.name}}</span>\n     *\n     * @example\n     * // Element exists.\n     * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n     *\n     * // Element not present.\n     * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n     *\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the element is present on the page.\n     */\n\n  }, {\n    key: \"isPresent\",\n    value: function isPresent() {\n      return this.parentElementArrayFinder.getWebElements().then(function (arr) {\n        if (arr.length === 0) {\n          return false;\n        }\n\n        return arr[0].isEnabled().then(function () {\n          return true; // is present, whether it is enabled or not\n        }, util_1.falseIfMissing);\n      }, util_1.falseIfMissing);\n    }\n    /**\n     * Same as ElementFinder.isPresent(), except this checks whether the element\n     * identified by the subLocator is present, rather than the current element\n     * finder, i.e.: `element(by.css('#abc')).element(by.css('#def')).isPresent()`\n     * is identical to `element(by.css('#abc')).isElementPresent(by.css('#def'))`.\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * `$('#abc').$('#def').isPresent()` is identical to\n     * `$('#abc').isElementPresent($('#def'))`.\n     *\n     * @see ElementFinder.isPresent\n     *\n     * @param {webdriver.Locator} subLocator Locator for element to look for.\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the subelement is present on the page.\n     */\n\n  }, {\n    key: \"isElementPresent\",\n    value: function isElementPresent(subLocator) {\n      if (!subLocator) {\n        throw new Error('SubLocator is not supplied as a parameter to ' + '`isElementPresent(subLocator)`. You are probably looking for the ' + 'function `isPresent()`.');\n      }\n\n      return this.element(subLocator).isPresent();\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current element.\n     * @see ElementArrayFinder.prototype.evaluate\n     *\n     * @view\n     * <span id=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element(by.id('foo')).evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementFinder} which resolves to the evaluated expression.\n     */\n\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(expression) {\n      return this.elementArrayFinder_.evaluate(expression).toElementFinder_();\n    }\n    /**\n     * @see ElementArrayFinder.prototype.allowAnimations.\n     * @param {string} value\n     *\n     * @returns {ElementFinder} which resolves to whether animation is allowed.\n     */\n\n  }, {\n    key: \"allowAnimations\",\n    value: function allowAnimations(value) {\n      return this.elementArrayFinder_.allowAnimations(value).toElementFinder_();\n    }\n    /**\n     * Compares an element to this one for equality.\n     *\n     * @param {!ElementFinder|!webdriver.WebElement} The element to compare to.\n     *\n     * @returns {!webdriver.promise.Promise.<boolean>} A promise that will be\n     *     resolved to whether the two WebElements are equal.\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(element) {\n      return selenium_webdriver_1.WebElement.equals(this.getWebElement(), element.getWebElement ? element.getWebElement() : element);\n    }\n  }], [{\n    key: \"fromWebElement_\",\n    value: function fromWebElement_(browser, webElem, locator) {\n      var getWebElements = function getWebElements() {\n        return selenium_webdriver_1.promise.when([webElem]);\n      };\n\n      return new ElementArrayFinder(browser, getWebElements, locator).toElementFinder_();\n    }\n  }]);\n\n  return ElementFinder;\n}(WebdriverWebElement);\n\nexports.ElementFinder = ElementFinder;\n/**\n * Shortcut for querying the document directly with css.\n * `element(by.css('.abc'))` is equivalent to `$('.abc')`\n *\n * @alias $(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * let item = $('.count .two');\n * expect(item.getText()).toBe('Second');\n *\n * @param {string} selector A css selector\n * @returns {ElementFinder} which identifies the located\n *     {@link webdriver.WebElement}\n */\n\nexports.build$ = function (element, by) {\n  return function (selector) {\n    return element(by.css(selector));\n  };\n};\n/**\n * Shortcut for querying the document directly with css.\n * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n *\n * @alias $$(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * // The following protractor expressions are equivalent.\n * let list = element.all(by.css('.count span'));\n * expect(list.count()).toBe(2);\n *\n * list = $$('.count span');\n * expect(list.count()).toBe(2);\n * expect(list.get(0).getText()).toBe('First');\n * expect(list.get(1).getText()).toBe('Second');\n *\n * @param {string} selector a css selector\n * @returns {ElementArrayFinder} which identifies the\n *     array of the located {@link webdriver.WebElement}s.\n */\n\n\nexports.build$$ = function (element, by) {\n  return function (selector) {\n    return element.all(by.css(selector));\n  };\n};","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/protractor/built/element.js"],"names":["Object","defineProperty","exports","value","selenium_webdriver_1","require","locators_1","logger_1","util_1","clientSideScripts","logger","Logger","WebdriverWebElement","WEB_ELEMENT_FUNCTIONS","ElementArrayFinder","browser_","getWebElements","locator_","actionResults_","forEach","fnName","args","actionFn","webElem","apply","applyAction_","locator","ptor","waitForAngular","then","isProtractorLocator","findElementsOverride","driver","rootEl","findElements","parentWebElements","childrenPromiseList","map","parentWebElement","promise","all","resolved","reduce","childrenList","resolvedE","concat","filterFn","list","index","elementFinder","ElementFinder","fromWebElement_","resolvedList","filter","i","length","error","NoSuchElementError","toString","toElementFinder_","get","selector","By","css","arr","err","count","callerError","Error","actionResults","passed","result","noSuchErr","stack","fn","errorFn","asElementFinders_","mapFn","mapResult","fullyResolved","reduceFn","initialValue","valuePromise","when","expression","evaluationFn","getDriver","executeScript","evaluate","allowAnimationsTestFn","allowAnimations","elementArrayFinder","parentElementArrayFinder","elementArrayFinder_","webElements","warn","id","WebElementPromise","subLocator","element","isEnabled","falseIfMissing","isPresent","WebElement","equals","getWebElement","browser","build$","by","build$$"],"mappings":"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uB,KAAKC,QAA5B,EAAsCC,cAAtC,EAAsD,KAAKC,QAA3D,EAAqE0C,gBAArE,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;4BACY;AACJ,aAAO,KAAKC,GAAL,CAAS,CAAT,CAAP;AACH;;;;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;2BACW;AACH,aAAO,KAAKA,GAAL,CAAS,CAAC,CAAV,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;uBACOC,Q,EAAU;AACT,aAAO,KAAKrB,GAAL,CAASpC,oBAAoB,CAAC0D,EAArB,CAAwBC,GAAxB,CAA4BF,QAA5B,CAAT,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;uCACuB;AACf,aAAO,IAAIX,aAAJ,CAAkB,KAAKnC,QAAvB,EAAiC,IAAjC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;4BACY;AACJ,aAAO,KAAKC,cAAL,GAAsBa,IAAtB,CAA2B,UAACmC,GAAD,EAAS;AACvC,eAAOA,GAAG,CAACT,MAAX;AACH,OAFM,EAEJ,UAACU,GAAD,EAAS;AACR,YAAIA,GAAG,YAAY7D,oBAAoB,CAACoD,KAArB,CAA2BC,kBAA9C,EAAkE;AAC9D,iBAAO,CAAP;AACH,SAFD,MAGK;AACD,gBAAMQ,GAAN;AACH;AACJ,OATM,CAAP;AAUH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;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2BzE,MAA3B,EACFI,KADE,CACI,OAAKqE,mBADT,EAC8BxE,IAD9B,EAEFsC,gBAFE,EAAP;AAGH,OAJD;AAKH,KAND;AA1CsC;AAiDzC;;;;;AAOD;AACJ;AACA;AACA;AACA;4BACY;AACJ;AACA;AACA,aAAO,IAAIT,aAAJ,CAAkB,KAAKnC,QAAvB,EAAiC,KAAK6E,wBAAtC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;;8BACc;AACN,aAAO,KAAKC,mBAAL,CAAyBnE,OAAzB,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;oCACoB;AACZ,UAAIsE,EAAE,GAAG,KAAKH,mBAAL,CAAyB7E,cAAzB,GAA0Ca,IAA1C,CAA+C,UAACM,iBAAD,EAAuB;AAC3E,eAAOA,iBAAiB,CAAC,CAAD,CAAxB;AACH,OAFQ,CAAT;AAGA,aAAO,IAAI/B,oBAAoB,CAAC6F,iBAAzB,CAA2C,KAAKlF,QAAL,CAAciB,MAAzD,EAAiEgE,EAAjE,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;wBACQE,U,EAAY;AACZ,aAAO,KAAKL,mBAAL,CAAyBrD,GAAzB,CAA6B0D,UAA7B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;4BACYA,U,EAAY;AAChB,aAAO,KAAK1D,GAAL,CAAS0D,UAAT,EAAqBvC,gBAArB,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\nconst locators_1 = require(\"./locators\");\nconst logger_1 = require(\"./logger\");\nconst util_1 = require(\"./util\");\nlet clientSideScripts = require('./clientsidescripts');\nlet logger = new logger_1.Logger('element');\nclass WebdriverWebElement {\n}\nexports.WebdriverWebElement = WebdriverWebElement;\nlet WEB_ELEMENT_FUNCTIONS = [\n    'click', 'sendKeys', 'getTagName', 'getCssValue', 'getAttribute', 'getText', 'getSize',\n    'getLocation', 'isEnabled', 'isSelected', 'submit', 'clear', 'isDisplayed', 'getId',\n    'takeScreenshot'\n];\n/**\n * ElementArrayFinder is used for operations on an array of elements (as opposed\n * to a single element).\n *\n * The ElementArrayFinder is used to set up a chain of conditions that identify\n * an array of elements. In particular, you can call all(locator) and\n * filter(filterFn) to return a new ElementArrayFinder modified by the\n * conditions, and you can call get(index) to return a single ElementFinder at\n * position 'index'.\n *\n * Similar to jquery, ElementArrayFinder will search all branches of the DOM\n * to find the elements that satisfy the conditions (i.e. all, filter, get).\n * However, an ElementArrayFinder will not actually retrieve the elements until\n * an action is called, which means it can be set up in helper files (i.e.\n * page objects) before the page is available, and reused as the page changes.\n *\n * You can treat an ElementArrayFinder as an array of WebElements for most\n * purposes, in particular, you may perform actions (i.e. click, getText) on\n * them as you would an array of WebElements. The action will apply to\n * every element identified by the ElementArrayFinder. ElementArrayFinder\n * extends Promise, and once an action is performed on an ElementArrayFinder,\n * the latest result can be accessed using then, and will be returned as an\n * array of the results; the array has length equal to the length of the\n * elements found by the ElementArrayFinder and each result represents the\n * result of performing the action on the element. Unlike a WebElement, an\n * ElementArrayFinder will wait for the angular app to settle before\n * performing finds or actions.\n *\n * @alias element.all(locator)\n * @view\n * <ul class=\"items\">\n *   <li>First</li>\n *   <li>Second</li>\n *   <li>Third</li>\n * </ul>\n *\n * @example\n * element.all(by.css('.items li')).then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * // Or using the shortcut $$() notation instead of element.all(by.css()):\n *\n * $$('.items li').then(function(items) {\n *   expect(items.length).toBe(3);\n *   expect(items[0].getText()).toBe('First');\n * });\n *\n * @constructor\n * @param {ProtractorBrowser} browser A browser instance.\n * @param {function(): Array.<webdriver.WebElement>} getWebElements A function\n *    that returns a list of the underlying Web Elements.\n * @param {webdriver.Locator} locator The most relevant locator. It is only\n *    used for error reporting and ElementArrayFinder.locator.\n * @param {Array.<webdriver.promise.Promise>} opt_actionResults An array\n *    of promises which will be retrieved with then. Resolves to the latest\n *    action result, or null if no action has been called.\n * @returns {ElementArrayFinder}\n */\nclass ElementArrayFinder extends WebdriverWebElement {\n    constructor(browser_, getWebElements = null, locator_, actionResults_ = null) {\n        super();\n        this.browser_ = browser_;\n        this.getWebElements = getWebElements;\n        this.locator_ = locator_;\n        this.actionResults_ = actionResults_;\n        // TODO(juliemr): might it be easier to combine this with our docs and just\n        // wrap each one explicity with its own documentation?\n        WEB_ELEMENT_FUNCTIONS.forEach((fnName) => {\n            this[fnName] = (...args) => {\n                let actionFn = (webElem) => {\n                    return webElem[fnName].apply(webElem, args);\n                };\n                return this.applyAction_(actionFn);\n            };\n        });\n    }\n    /**\n     * Create a shallow copy of ElementArrayFinder.\n     *\n     * @returns {!ElementArrayFinder} A shallow copy of this.\n     */\n    clone() {\n        // A shallow copy is all we need since the underlying fields can never be\n        // modified. (Locator can be modified by the user, but that should\n        // rarely/never happen and it doesn't affect functionalities).\n        return new ElementArrayFinder(this.browser_, this.getWebElements, this.locator_, this.actionResults_);\n    }\n    /**\n     * Calls to ElementArrayFinder may be chained to find an array of elements\n     * using the current elements in this ElementArrayFinder as the starting\n     * point. This function returns a new ElementArrayFinder which would contain\n     * the children elements found (and could also be empty).\n     *\n     * @alias element.all(locator).all(locator)\n     * @view\n     * <div id='id1' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">1a</li>\n     *     <li class=\"baz\">1b</li>\n     *   </ul>\n     * </div>\n     * <div id='id2' class=\"parent\">\n     *   <ul>\n     *     <li class=\"foo\">2a</li>\n     *     <li class=\"bar\">2b</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let foo = element.all(by.css('.parent')).all(by.css('.foo'));\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = element.all(by.css('.parent')).all(by.css('.baz'));\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = element.all(by.css('.parent'))\n     *   .all(by.css('.NONEXISTENT'));\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let foo = $$('.parent').$$('.foo');\n     * expect(foo.getText()).toEqual(['1a', '2a']);\n     * let baz = $$('.parent').$$('.baz');\n     * expect(baz.getText()).toEqual(['1b']);\n     * let nonexistent = $$('.parent').$$('.NONEXISTENT');\n     * expect(nonexistent.getText()).toEqual(['']);\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n    all(locator) {\n        let ptor = this.browser_;\n        let getWebElements = () => {\n            if (this.getWebElements === null) {\n                // This is the first time we are looking for an element\n                return ptor.waitForAngular('Locator: ' + locator)\n                    .then(() => {\n                    if (locators_1.isProtractorLocator(locator)) {\n                        return locator.findElementsOverride(ptor.driver, null, ptor.rootEl);\n                    }\n                    else {\n                        return ptor.driver.findElements(locator);\n                    }\n                });\n            }\n            else {\n                return this.getWebElements().then((parentWebElements) => {\n                    // For each parent web element, find their children and construct\n                    // a list of Promise<List<child_web_element>>\n                    let childrenPromiseList = parentWebElements.map((parentWebElement) => {\n                        return locators_1.isProtractorLocator(locator) ?\n                            locator.findElementsOverride(ptor.driver, parentWebElement, ptor.rootEl) :\n                            parentWebElement.findElements(locator);\n                    });\n                    // Resolve the list of Promise<List<child_web_elements>> and merge\n                    // into a single list\n                    return selenium_webdriver_1.promise.all(childrenPromiseList)\n                        .then((resolved) => {\n                        return resolved.reduce((childrenList, resolvedE) => {\n                            return childrenList.concat(resolvedE);\n                        }, []);\n                    });\n                });\n            }\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, locator);\n    }\n    /**\n     * Apply a filter function to each element within the ElementArrayFinder.\n     * Returns a new ElementArrayFinder with all elements that pass the filter\n     * function. The filter function receives the ElementFinder as the first\n     * argument and the index as a second arg. This does not actually retrieve\n     * the underlying list of elements, so it can be used in page objects.\n     *\n     * @alias element.all(locator).filter(filterFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').filter(function(elem, index) {\n     *   return elem.getText().then(function(text) {\n     *     return text === 'Third';\n     *   });\n     * }).first().click();\n     *\n     * @param {function(ElementFinder, number): webdriver.WebElement.Promise}\n     * filterFn\n     *     Filter function that will test if an element should be returned.\n     *     filterFn can either return a boolean or a promise that resolves to a\n     * boolean\n     * @returns {!ElementArrayFinder} A ElementArrayFinder that represents an\n     * array\n     *     of element that satisfy the filter function.\n     */\n    filter(filterFn) {\n        let getWebElements = () => {\n            return this.getWebElements().then((parentWebElements) => {\n                let list = parentWebElements.map((parentWebElement, index) => {\n                    let elementFinder = ElementFinder.fromWebElement_(this.browser_, parentWebElement, this.locator_);\n                    return filterFn(elementFinder, index);\n                });\n                return selenium_webdriver_1.promise.all(list).then((resolvedList) => {\n                    return parentWebElements.filter((parentWebElement, index) => {\n                        return resolvedList[index];\n                    });\n                });\n            });\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_);\n    }\n    /**\n     * Get an element within the ElementArrayFinder by index. The index starts at 0.\n     * Negative indices are wrapped (i.e. -i means ith element from last)\n     * This does not actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).get(index)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {number|webdriver.promise.Promise} index Element index.\n     * @returns {ElementFinder} finder representing element at the given index.\n     */\n    get(index) {\n        let getWebElements = () => {\n            return selenium_webdriver_1.promise.all([index, this.getWebElements()]).then(([i, parentWebElements]) => {\n                if (i < 0) {\n                    i += parentWebElements.length;\n                }\n                if (i < 0 || i >= parentWebElements.length) {\n                    throw new selenium_webdriver_1.error.NoSuchElementError('Index out of bound. Trying to access element at index: ' + index +\n                        ', but there are only ' + parentWebElements.length + ' elements that match ' +\n                        'locator ' + this.locator_.toString());\n                }\n                return [parentWebElements[i]];\n            });\n        };\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_).toElementFinder_();\n    }\n    /**\n     * Get the first matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).first()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let first = element.all(by.css('.items li')).first();\n     * expect(first.getText()).toBe('First');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let first = $$('.items li').first();\n     * expect(first.getText()).toBe('First');\n     *\n     * @returns {ElementFinder} finder representing the first matching element\n     */\n    first() {\n        return this.get(0);\n    }\n    ;\n    /**\n     * Get the last matching element for the ElementArrayFinder. This does not\n     * actually retrieve the underlying element.\n     *\n     * @alias element.all(locator).last()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let last = element.all(by.css('.items li')).last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let last = $$('.items li').last();\n     * expect(last.getText()).toBe('Third');\n     *\n     * @returns {ElementFinder} finder representing the last matching element\n     */\n    last() {\n        return this.get(-1);\n    }\n    /**\n     * Shorthand function for finding arrays of elements by css.\n     * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n     *\n     * @alias $$(cssSelector)\n     * @view\n     * <div class=\"count\">\n     *   <span class=\"one\">First</span>\n     *   <span class=\"two\">Second</span>\n     * </div>\n     *\n     * @example\n     * // The following two blocks of code are equivalent.\n     * let list = element.all(by.css('.count span'));\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.count span');\n     * expect(list.count()).toBe(2);\n     * expect(list.get(0).getText()).toBe('First');\n     * expect(list.get(1).getText()).toBe('Second');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder} which identifies the\n     *     array of the located {@link webdriver.WebElement}s.\n     */\n    $$(selector) {\n        return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Returns an ElementFinder representation of ElementArrayFinder. It ensures\n     * that the ElementArrayFinder resolves to one and only one underlying\n     * element.\n     *\n     * @returns {ElementFinder} An ElementFinder representation\n     * @private\n     */\n    toElementFinder_() {\n        return new ElementFinder(this.browser_, this);\n    }\n    /**\n     * Count the number of elements represented by the ElementArrayFinder.\n     *\n     * @alias element.all(locator).count()\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * let list = element.all(by.css('.items li'));\n     * expect(list.count()).toBe(3);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let list = $$('.items li');\n     * expect(list.count()).toBe(3);\n     *\n     * @returns {!webdriver.promise.Promise} A promise which resolves to the\n     *     number of elements matching the locator.\n     */\n    count() {\n        return this.getWebElements().then((arr) => {\n            return arr.length;\n        }, (err) => {\n            if (err instanceof selenium_webdriver_1.error.NoSuchElementError) {\n                return 0;\n            }\n            else {\n                throw err;\n            }\n        });\n    }\n    /**\n     * Returns true if there are any elements present that match the finder.\n     *\n     * @alias element.all(locator).isPresent()\n     *\n     * @example\n     * expect($('.item').isPresent()).toBeTruthy();\n     *\n     * @returns {Promise<boolean>}\n     */\n    isPresent() {\n        return this.count().then((count) => {\n            return count > 0;\n        });\n    }\n    /**\n     * Returns the most relevant locator.\n     *\n     * @example\n     * // returns by.css('#ID1')\n     * $('#ID1').locator();\n     *\n     * // returns by.css('#ID2')\n     * $('#ID1').$('#ID2').locator();\n     *\n     * // returns by.css('#ID1')\n     * $$('#ID1').filter(filterFn).get(0).click().locator();\n     *\n     * @returns {webdriver.Locator}\n     */\n    locator() {\n        return this.locator_;\n    }\n    /**\n     * Apply an action function to every element in the ElementArrayFinder,\n     * and return a new ElementArrayFinder that contains the results of the\n     * actions.\n     *\n     * @param {function(ElementFinder)} actionFn\n     *\n     * @returns {ElementArrayFinder}\n     * @private\n     */\n    // map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    applyAction_(actionFn) {\n        let callerError = new Error();\n        let actionResults = this.getWebElements()\n            .then((arr) => selenium_webdriver_1.promise.all(arr.map(actionFn)))\n            .then((value) => {\n            return { passed: true, value: value };\n        }, (error) => {\n            return { passed: false, value: error };\n        });\n        let getWebElements = () => actionResults.then(() => this.getWebElements());\n        actionResults = actionResults.then((result) => {\n            if (result.passed) {\n                return result.value;\n            }\n            else {\n                let noSuchErr;\n                if (result.value instanceof Error) {\n                    noSuchErr = result.value;\n                    noSuchErr.stack = noSuchErr.stack + callerError.stack;\n                }\n                else {\n                    noSuchErr = new Error(result.value);\n                    noSuchErr.stack = callerError.stack;\n                }\n                throw noSuchErr;\n            }\n        });\n        return new ElementArrayFinder(this.browser_, getWebElements, this.locator_, actionResults);\n    }\n    /**\n     * Represents the ElementArrayFinder as an array of ElementFinders.\n     *\n     * @returns {Array.<ElementFinder>} Return a promise, which resolves to a list\n     *     of ElementFinders specified by the locator.\n     */\n    asElementFinders_() {\n        return this.getWebElements().then((arr) => {\n            return arr.map((webElem) => {\n                return ElementFinder.fromWebElement_(this.browser_, webElem, this.locator_);\n            });\n        });\n    }\n    /**\n     * Retrieve the elements represented by the ElementArrayFinder. The input\n     * function is passed to the resulting promise, which resolves to an\n     * array of ElementFinders.\n     *\n     * @alias element.all(locator).then(thenFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').then(function(arr) {\n     *   expect(arr.length).toEqual(3);\n     * });\n     *\n     * @param {function(Array.<ElementFinder>)} fn\n     * @param {function(Error)} errorFn\n     *\n     * @returns {!webdriver.promise.Promise} A promise which will resolve to\n     *     an array of ElementFinders represented by the ElementArrayFinder.\n     */\n    then(fn, errorFn) {\n        if (this.actionResults_) {\n            return this.actionResults_.then(fn, errorFn);\n        }\n        else {\n            return this.asElementFinders_().then(fn, errorFn);\n        }\n    }\n    /**\n     * Calls the input function on each ElementFinder represented by the\n     * ElementArrayFinder.\n     *\n     * @alias element.all(locator).each(eachFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li>First</li>\n     *   <li>Second</li>\n     *   <li>Third</li>\n     * </ul>\n     *\n     * @example\n     * element.all(by.css('.items li')).each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * $$('.items li').each(function(element, index) {\n     *   // Will print 0 First, 1 Second, 2 Third.\n     *   element.getText().then(function (text) {\n     *     console.log(index, text);\n     *   });\n     * });\n     *\n     * @param {function(ElementFinder)} fn Input function\n     *\n     * @returns {!webdriver.promise.Promise} A promise that will resolve when the\n     *     function has been called on all the ElementFinders. The promise will\n     *     resolve to null.\n     */\n    each(fn) {\n        return this.map(fn).then(() => {\n            return null;\n        });\n    }\n    /**\n     * Apply a map function to each element within the ElementArrayFinder. The\n     * callback receives the ElementFinder as the first argument and the index as\n     * a second arg.\n     *\n     * @alias element.all(locator).map(mapFunction)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let items = element.all(by.css('.items li')).map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let items = $$('.items li').map(function(elm, index) {\n     *   return {\n     *     index: index,\n     *     text: elm.getText(),\n     *     class: elm.getAttribute('class')\n     *   };\n     * });\n     * expect(items).toEqual([\n     *   {index: 0, text: 'First', class: 'one'},\n     *   {index: 1, text: 'Second', class: 'two'},\n     *   {index: 2, text: 'Third', class: 'three'}\n     * ]);\n     *\n     * @param {function(ElementFinder, number)} mapFn Map function that\n     *     will be applied to each element.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to an array\n     *     of values returned by the map function.\n     */\n    map(mapFn) {\n        return this.asElementFinders_().then((arr) => {\n            let list = arr.map((elementFinder, index) => {\n                let mapResult = mapFn(elementFinder, index);\n                // All nested arrays and objects will also be fully resolved.\n                return selenium_webdriver_1.promise.fullyResolved(mapResult);\n            });\n            return selenium_webdriver_1.promise.all(list);\n        });\n    }\n    ;\n    /**\n     * Apply a reduce function against an accumulator and every element found\n     * using the locator (from left-to-right). The reduce function has to reduce\n     * every element into a single value (the accumulator). Returns promise of\n     * the accumulator. The reduce function receives the accumulator, current\n     * ElementFinder, the index, and the entire array of ElementFinders,\n     * respectively.\n     *\n     * @alias element.all(locator).reduce(reduceFn)\n     * @view\n     * <ul class=\"items\">\n     *   <li class=\"one\">First</li>\n     *   <li class=\"two\">Second</li>\n     *   <li class=\"three\">Third</li>\n     * </ul>\n     *\n     * @example\n     * let value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.items li').reduce(function(acc, elem) {\n     *   return elem.getText().then(function(text) {\n     *     return acc + text + ' ';\n     *   });\n     * }, '');\n     *\n     * expect(value).toEqual('First Second Third ');\n     *\n     * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n     *     reduceFn Reduce function that reduces every element into a single\n     * value.\n     * @param {*} initialValue Initial value of the accumulator.\n     * @returns {!webdriver.promise.Promise} A promise that resolves to the final\n     *     value of the accumulator.\n     */\n    reduce(reduceFn, initialValue) {\n        let valuePromise = selenium_webdriver_1.promise.when(initialValue);\n        return this.asElementFinders_().then((arr) => {\n            return arr.reduce((valuePromise, elementFinder, index) => {\n                return valuePromise.then((value) => {\n                    return reduceFn(value, elementFinder, index, arr);\n                });\n            }, valuePromise);\n        });\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current underlying\n     * elements.\n     *\n     * @view\n     * <span class=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element.all(by.css('.foo')).evaluate('letiableInScope');\n     *\n     * // Or using the shortcut $$() notation instead of element.all(by.css()):\n     *\n     * let value = $$('.foo').evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementArrayFinder} which resolves to the\n     *     evaluated expression for each underlying element.\n     *     The result will be resolved as in\n     *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n     *     be resolved as is, functions will be converted to string, and elements\n     *     will be returned as a WebElement.\n     */\n    evaluate(expression) {\n        let evaluationFn = (webElem) => {\n            return webElem.getDriver().executeScript(clientSideScripts.evaluate, webElem, expression);\n        };\n        return this.applyAction_(evaluationFn);\n    }\n    /**\n     * Determine if animation is allowed on the current underlying elements.\n     * @param {string} value\n     *\n     * @example\n     * // Turns off ng-animate animations for all elements in the <body>\n     * element(by.css('body')).allowAnimations(false);\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * $('body').allowAnimations(false);\n     *\n     * @returns {ElementArrayFinder} which resolves to whether animation is\n     * allowed.\n     */\n    allowAnimations(value) {\n        let allowAnimationsTestFn = (webElem) => {\n            return webElem.getDriver().executeScript(clientSideScripts.allowAnimations, webElem, value);\n        };\n        return this.applyAction_(allowAnimationsTestFn);\n    }\n}\nexports.ElementArrayFinder = ElementArrayFinder;\n/**\n * The ElementFinder simply represents a single element of an\n * ElementArrayFinder (and is more like a convenience object). As a result,\n * anything that can be done with an ElementFinder, can also be done using\n * an ElementArrayFinder.\n *\n * The ElementFinder can be treated as a WebElement for most purposes, in\n * particular, you may perform actions (i.e. click, getText) on them as you\n * would a WebElement. Once an action is performed on an ElementFinder, the\n * latest result from the chain can be accessed using the then method.\n * Unlike a WebElement, an ElementFinder will wait for angular to settle before\n * performing finds or actions.\n *\n * ElementFinder can be used to build a chain of locators that is used to find\n * an element. An ElementFinder does not actually attempt to find the element\n * until an action is called, which means they can be set up in helper files\n * before the page is available.\n *\n * @alias element(locator)\n * @view\n * <span>{{person.name}}</span>\n * <span ng-bind=\"person.email\"></span>\n * <input type=\"text\" ng-model=\"person.name\"/>\n *\n * @example\n * // Find element with {{scopelet}} syntax.\n * element(by.binding('person.name')).getText().then(function(name) {\n *   expect(name).toBe('Foo');\n * });\n *\n * // Find element with ng-bind=\"scopelet\" syntax.\n * expect(element(by.binding('person.email')).getText()).toBe('foo@bar.com');\n *\n * // Find by model.\n * let input = element(by.model('person.name'));\n * input.sendKeys('123');\n * expect(input.getAttribute('value')).toBe('Foo123');\n *\n * @constructor\n * @extends {webdriver.WebElement}\n * @param {ProtractorBrowser} browser_ A browser instance.\n * @param {ElementArrayFinder} elementArrayFinder The ElementArrayFinder\n *     that this is branched from.\n * @returns {ElementFinder}\n */\nclass ElementFinder extends WebdriverWebElement {\n    constructor(browser_, elementArrayFinder) {\n        super();\n        this.browser_ = browser_;\n        this.then = null;\n        if (!elementArrayFinder) {\n            throw new Error('BUG: elementArrayFinder cannot be empty');\n        }\n        this.parentElementArrayFinder = elementArrayFinder;\n        // Only have a `then` method if the parent element array finder\n        // has action results.\n        if (this.parentElementArrayFinder.actionResults_) {\n            // Access the underlying actionResult of ElementFinder.\n            this.then =\n                (fn, errorFn) => {\n                    return this.elementArrayFinder_.then((actionResults) => {\n                        if (!fn) {\n                            return actionResults[0];\n                        }\n                        return fn(actionResults[0]);\n                    }, errorFn);\n                };\n        }\n        // This filter verifies that there is only 1 element returned by the\n        // elementArrayFinder. It will warn if there are more than 1 element and\n        // throw an error if there are no elements.\n        let getWebElements = () => {\n            return elementArrayFinder.getWebElements().then((webElements) => {\n                if (webElements.length === 0) {\n                    throw new selenium_webdriver_1.error.NoSuchElementError('No element found using locator: ' + elementArrayFinder.locator().toString());\n                }\n                else {\n                    if (webElements.length > 1) {\n                        logger.warn('more than one element found for locator ' +\n                            elementArrayFinder.locator().toString() + ' - the first result will be used');\n                    }\n                    return [webElements[0]];\n                }\n            });\n        };\n        // Store a copy of the underlying elementArrayFinder, but with the more\n        // restrictive getWebElements (which checks that there is only 1 element).\n        this.elementArrayFinder_ = new ElementArrayFinder(this.browser_, getWebElements, elementArrayFinder.locator(), elementArrayFinder.actionResults_);\n        WEB_ELEMENT_FUNCTIONS.forEach((fnName) => {\n            (this)[fnName] = (...args) => {\n                return (this.elementArrayFinder_)[fnName]\n                    .apply(this.elementArrayFinder_, args)\n                    .toElementFinder_();\n            };\n        });\n    }\n    static fromWebElement_(browser, webElem, locator) {\n        let getWebElements = () => {\n            return selenium_webdriver_1.promise.when([webElem]);\n        };\n        return new ElementArrayFinder(browser, getWebElements, locator).toElementFinder_();\n    }\n    /**\n     * Create a shallow copy of ElementFinder.\n     *\n     * @returns {!ElementFinder} A shallow copy of this.\n     */\n    clone() {\n        // A shallow copy is all we need since the underlying fields can never be\n        // modified\n        return new ElementFinder(this.browser_, this.parentElementArrayFinder);\n    }\n    /**\n     * @see ElementArrayFinder.prototype.locator\n     *\n     * @returns {webdriver.Locator}\n     */\n    locator() {\n        return this.elementArrayFinder_.locator();\n    }\n    /**\n     * Returns the WebElement represented by this ElementFinder.\n     * Throws the WebDriver error if the element doesn't exist.\n     *\n     * @alias element(locator).getWebElement()\n     * @view\n     * <div class=\"parent\">\n     *   some text\n     * </div>\n     *\n     * @example\n     * // The following four expressions are equivalent.\n     * $('.parent').getWebElement();\n     * element(by.css('.parent')).getWebElement();\n     * browser.driver.findElement(by.css('.parent'));\n     * browser.findElement(by.css('.parent'));\n     *\n     * @returns {webdriver.WebElementPromise}\n     */\n    getWebElement() {\n        let id = this.elementArrayFinder_.getWebElements().then((parentWebElements) => {\n            return parentWebElements[0];\n        });\n        return new selenium_webdriver_1.WebElementPromise(this.browser_.driver, id);\n    }\n    /**\n     * Calls to {@code all} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).all(by.tagName('li'));\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').all(by.tagName('li'));\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementArrayFinder}\n     */\n    all(subLocator) {\n        return this.elementArrayFinder_.all(subLocator);\n    }\n    /**\n     * Calls to {@code element} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).element(locator)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     element(by.css('.child'));\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     element(by.css('.child')).\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {webdriver.Locator} subLocator\n     * @returns {ElementFinder}\n     */\n    element(subLocator) {\n        return this.all(subLocator).toElementFinder_();\n    }\n    /**\n     * Calls to {@code $$} may be chained to find an array of elements within a\n     * parent.\n     *\n     * @alias element(locator).all(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <ul>\n     *     <li class=\"one\">First</li>\n     *     <li class=\"two\">Second</li>\n     *     <li class=\"three\">Third</li>\n     *   </ul>\n     * </div>\n     *\n     * @example\n     * let items = element(by.css('.parent')).$$('li');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * let items = $('.parent').$$('li');\n     *\n     * @param {string} selector a css selector\n     * @returns {ElementArrayFinder}\n     */\n    $$(selector) {\n        return this.all(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Calls to {@code $} may be chained to find elements within a parent.\n     *\n     * @alias element(locator).$(selector)\n     * @view\n     * <div class=\"parent\">\n     *   <div class=\"child\">\n     *     Child text\n     *     <div>{{person.phone}}</div>\n     *   </div>\n     * </div>\n     *\n     * @example\n     * // Chain 2 element calls.\n     * let child = element(by.css('.parent')).\n     *     $('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = element(by.css('.parent')).\n     *     $('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * // Chain 2 element calls.\n     * let child = $('.parent').$('.child');\n     * expect(child.getText()).toBe('Child text\\n555-123-4567');\n     *\n     * // Chain 3 element calls.\n     * let triple = $('.parent').$('.child').\n     *     element(by.binding('person.phone'));\n     * expect(triple.getText()).toBe('555-123-4567');\n     *\n     * @param {string} selector A css selector\n     * @returns {ElementFinder}\n     */\n    $(selector) {\n        return this.element(selenium_webdriver_1.By.css(selector));\n    }\n    /**\n     * Determine whether the element is present on the page.\n     *\n     * @view\n     * <span>{{person.name}}</span>\n     *\n     * @example\n     * // Element exists.\n     * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n     *\n     * // Element not present.\n     * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n     *\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the element is present on the page.\n     */\n    isPresent() {\n        return this.parentElementArrayFinder.getWebElements().then((arr) => {\n            if (arr.length === 0) {\n                return false;\n            }\n            return arr[0].isEnabled().then(() => {\n                return true; // is present, whether it is enabled or not\n            }, util_1.falseIfMissing);\n        }, util_1.falseIfMissing);\n    }\n    /**\n     * Same as ElementFinder.isPresent(), except this checks whether the element\n     * identified by the subLocator is present, rather than the current element\n     * finder, i.e.: `element(by.css('#abc')).element(by.css('#def')).isPresent()`\n     * is identical to `element(by.css('#abc')).isElementPresent(by.css('#def'))`.\n     *\n     * // Or using the shortcut $() notation instead of element(by.css()):\n     *\n     * `$('#abc').$('#def').isPresent()` is identical to\n     * `$('#abc').isElementPresent($('#def'))`.\n     *\n     * @see ElementFinder.isPresent\n     *\n     * @param {webdriver.Locator} subLocator Locator for element to look for.\n     * @returns {webdriver.promise.Promise<boolean>} which resolves to whether\n     *     the subelement is present on the page.\n     */\n    isElementPresent(subLocator) {\n        if (!subLocator) {\n            throw new Error('SubLocator is not supplied as a parameter to ' +\n                '`isElementPresent(subLocator)`. You are probably looking for the ' +\n                'function `isPresent()`.');\n        }\n        return this.element(subLocator).isPresent();\n    }\n    /**\n     * Evaluates the input as if it were on the scope of the current element.\n     * @see ElementArrayFinder.prototype.evaluate\n     *\n     * @view\n     * <span id=\"foo\">{{letiableInScope}}</span>\n     *\n     * @example\n     * let value = element(by.id('foo')).evaluate('letiableInScope');\n     *\n     * @param {string} expression\n     *\n     * @returns {ElementFinder} which resolves to the evaluated expression.\n     */\n    evaluate(expression) {\n        return this.elementArrayFinder_.evaluate(expression).toElementFinder_();\n    }\n    /**\n     * @see ElementArrayFinder.prototype.allowAnimations.\n     * @param {string} value\n     *\n     * @returns {ElementFinder} which resolves to whether animation is allowed.\n     */\n    allowAnimations(value) {\n        return this.elementArrayFinder_.allowAnimations(value).toElementFinder_();\n    }\n    /**\n     * Compares an element to this one for equality.\n     *\n     * @param {!ElementFinder|!webdriver.WebElement} The element to compare to.\n     *\n     * @returns {!webdriver.promise.Promise.<boolean>} A promise that will be\n     *     resolved to whether the two WebElements are equal.\n     */\n    equals(element) {\n        return selenium_webdriver_1.WebElement.equals(this.getWebElement(), element.getWebElement ? element.getWebElement() :\n            element);\n    }\n}\nexports.ElementFinder = ElementFinder;\n/**\n * Shortcut for querying the document directly with css.\n * `element(by.css('.abc'))` is equivalent to `$('.abc')`\n *\n * @alias $(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * let item = $('.count .two');\n * expect(item.getText()).toBe('Second');\n *\n * @param {string} selector A css selector\n * @returns {ElementFinder} which identifies the located\n *     {@link webdriver.WebElement}\n */\nexports.build$ = (element, by) => {\n    return (selector) => {\n        return element(by.css(selector));\n    };\n};\n/**\n * Shortcut for querying the document directly with css.\n * `element.all(by.css('.abc'))` is equivalent to `$$('.abc')`\n *\n * @alias $$(cssSelector)\n * @view\n * <div class=\"count\">\n *   <span class=\"one\">First</span>\n *   <span class=\"two\">Second</span>\n * </div>\n *\n * @example\n * // The following protractor expressions are equivalent.\n * let list = element.all(by.css('.count span'));\n * expect(list.count()).toBe(2);\n *\n * list = $$('.count span');\n * expect(list.count()).toBe(2);\n * expect(list.get(0).getText()).toBe('First');\n * expect(list.get(1).getText()).toBe('Second');\n *\n * @param {string} selector a css selector\n * @returns {ElementArrayFinder} which identifies the\n *     array of the located {@link webdriver.WebElement}s.\n */\nexports.build$$ = (element, by) => {\n    return (selector) => {\n        return element.all(by.css(selector));\n    };\n};\n//# sourceMappingURL=element.js.map"]},"metadata":{},"sourceType":"script"}