{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n *  This is a base driver provider class.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\n\nvar q = require(\"q\");\n\nvar selenium_webdriver_1 = require(\"selenium-webdriver\");\n\nvar bpRunner_1 = require(\"../bpRunner\");\n\nvar DriverProvider = /*#__PURE__*/function () {\n  function DriverProvider(config) {\n    _classCallCheck(this, DriverProvider);\n\n    this.config_ = config;\n    this.drivers_ = [];\n    this.bpRunner = new bpRunner_1.BlockingProxyRunner(config);\n  }\n  /**\n   * Get all existing drivers.\n   *\n   * @public\n   * @return array of webdriver instances\n   */\n\n\n  _createClass(DriverProvider, [{\n    key: \"getExistingDrivers\",\n    value: function getExistingDrivers() {\n      return this.drivers_.slice(); // Create a shallow copy\n    }\n  }, {\n    key: \"getBPUrl\",\n    value: function getBPUrl() {\n      if (this.config_.blockingProxyUrl) {\n        return this.config_.blockingProxyUrl;\n      }\n\n      return \"http://localhost:\".concat(this.bpRunner.port);\n    }\n    /**\n     * Create a new driver.\n     *\n     * @public\n     * @return webdriver instance\n     */\n\n  }, {\n    key: \"getNewDriver\",\n    value: function getNewDriver() {\n      var builder;\n\n      if (this.config_.useBlockingProxy) {\n        builder = new selenium_webdriver_1.Builder().usingServer(this.getBPUrl()).withCapabilities(this.config_.capabilities);\n      } else {\n        builder = new selenium_webdriver_1.Builder().usingServer(this.config_.seleniumAddress).usingWebDriverProxy(this.config_.webDriverProxy).withCapabilities(this.config_.capabilities);\n      }\n\n      if (this.config_.disableEnvironmentOverrides === true) {\n        builder.disableEnvironmentOverrides();\n      }\n\n      var newDriver = builder.build();\n      this.drivers_.push(newDriver);\n      return newDriver;\n    }\n    /**\n     * Quit a driver.\n     *\n     * @public\n     * @param webdriver instance\n     */\n\n  }, {\n    key: \"quitDriver\",\n    value: function quitDriver(driver) {\n      var driverIndex = this.drivers_.indexOf(driver);\n\n      if (driverIndex >= 0) {\n        this.drivers_.splice(driverIndex, 1);\n      }\n\n      if (driver.getSession() === undefined) {\n        return selenium_webdriver_1.promise.when(undefined);\n      } else {\n        return driver.getSession().then(function (session_) {\n          if (session_) {\n            return driver.quit();\n          }\n        }).catch(function (err) {});\n      }\n    }\n    /**\n     * Quits an array of drivers and returns a q promise instead of a webdriver one\n     *\n     * @param drivers {webdriver.WebDriver[]} The webdriver instances\n     */\n\n  }, {\n    key: \"updateJob\",\n\n    /**\n     * Default update job method.\n     * @return a promise\n     */\n    value: function updateJob(update) {\n      return q.fcall(function () {});\n    }\n  }, {\n    key: \"setupEnv\",\n\n    /**\n     * Default setup environment method, common to all driver providers.\n     */\n    value: function setupEnv() {\n      var _this = this;\n\n      var driverPromise = this.setupDriverEnv();\n\n      if (this.config_.useBlockingProxy && !this.config_.blockingProxyUrl) {\n        // TODO(heathkit): If set, pass the webDriverProxy to BP.\n        return driverPromise.then(function () {\n          return _this.bpRunner.start();\n        });\n      }\n\n      return driverPromise;\n    }\n  }, {\n    key: \"teardownEnv\",\n\n    /**\n     * Teardown and destroy the environment and do any associated cleanup.\n     * Shuts down the drivers.\n     *\n     * @public\n     * @return {q.Promise<any>} A promise which will resolve when the environment is down.\n     */\n    value: function teardownEnv() {\n      return DriverProvider.quitDrivers(this, this.drivers_);\n    }\n  }], [{\n    key: \"quitDrivers\",\n    value: function quitDrivers(provider, drivers) {\n      var deferred = q.defer();\n      selenium_webdriver_1.promise.all(drivers.map(function (driver) {\n        return provider.quitDriver(driver);\n      })).then(function () {\n        deferred.resolve();\n      }, function () {\n        deferred.resolve();\n      });\n      return deferred.promise;\n    }\n  }]);\n\n  return DriverProvider;\n}();\n\nexports.DriverProvider = DriverProvider;","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/protractor/built/driverProviders/driverProvider.js"],"names":["Object","defineProperty","exports","value","q","require","selenium_webdriver_1","bpRunner_1","DriverProvider","config","config_","drivers_","bpRunner","BlockingProxyRunner","slice","blockingProxyUrl","port","builder","useBlockingProxy","Builder","usingServer","getBPUrl","withCapabilities","capabilities","seleniumAddress","usingWebDriverProxy","webDriverProxy","disableEnvironmentOverrides","newDriver","build","push","driver","driverIndex","indexOf","splice","getSession","undefined","promise","when","then","session_","quit","catch","err","update","fcall","driverPromise","setupDriverEnv","start","quitDrivers","provider","drivers","deferred","defer","all","map","quitDriver","resolve"],"mappings":"AAAA;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,CAAC,GAAGC,OAAO,CAAC,GAAD,CAAjB;;AACA,IAAMC,oBAAoB,GAAGD,OAAO,CAAC,oBAAD,CAApC;;AACA,IAAME,UAAU,GAAGF,OAAO,CAAC,aAAD,CAA1B;;IACMG,c;AACF,0BAAYC,MAAZ,EAAoB;AAAA;;AAChB,SAAKC,OAAL,GAAeD,MAAf;AACA,SAAKE,QAAL,GAAgB,EAAhB;AACA,SAAKC,QAAL,GAAgB,IAAIL,UAAU,CAACM,mBAAf,CAAmCJ,MAAnC,CAAhB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;;yCACyB;AACjB,aAAO,KAAKE,QAAL,CAAcG,KAAd,EAAP,CADiB,CACa;AACjC;;;+BACU;AACP,UAAI,KAAKJ,OAAL,CAAaK,gBAAjB,EAAmC;AAC/B,eAAO,KAAKL,OAAL,CAAaK,gBAApB;AACH;;AACD,wCAA2B,KAAKH,QAAL,CAAcI,IAAzC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;mCACmB;AACX,UAAIC,OAAJ;;AACA,UAAI,KAAKP,OAAL,CAAaQ,gBAAjB,EAAmC;AAC/BD,QAAAA,OAAO,GACH,IAAIX,oBAAoB,CAACa,OAAzB,GAAmCC,WAAnC,CAA+C,KAAKC,QAAL,EAA/C,EAAgEC,gBAAhE,CAAiF,KAAKZ,OAAL,CAAaa,YAA9F,CADJ;AAEH,OAHD,MAIK;AACDN,QAAAA,OAAO,GAAG,IAAIX,oBAAoB,CAACa,OAAzB,GACLC,WADK,CACO,KAAKV,OAAL,CAAac,eADpB,EAELC,mBAFK,CAEe,KAAKf,OAAL,CAAagB,cAF5B,EAGLJ,gBAHK,CAGY,KAAKZ,OAAL,CAAaa,YAHzB,CAAV;AAIH;;AACD,UAAI,KAAKb,OAAL,CAAaiB,2BAAb,KAA6C,IAAjD,EAAuD;AACnDV,QAAAA,OAAO,CAACU,2BAAR;AACH;;AACD,UAAIC,SAAS,GAAGX,OAAO,CAACY,KAAR,EAAhB;AACA,WAAKlB,QAAL,CAAcmB,IAAd,CAAmBF,SAAnB;AACA,aAAOA,SAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;+BACeG,M,EAAQ;AACf,UAAIC,WAAW,GAAG,KAAKrB,QAAL,CAAcsB,OAAd,CAAsBF,MAAtB,CAAlB;;AACA,UAAIC,WAAW,IAAI,CAAnB,EAAsB;AAClB,aAAKrB,QAAL,CAAcuB,MAAd,CAAqBF,WAArB,EAAkC,CAAlC;AACH;;AACD,UAAID,MAAM,CAACI,UAAP,OAAwBC,SAA5B,EAAuC;AACnC,eAAO9B,oBAAoB,CAAC+B,OAArB,CAA6BC,IAA7B,CAAkCF,SAAlC,CAAP;AACH,OAFD,MAGK;AACD,eAAOL,MAAM,CAACI,UAAP,GACFI,IADE,CACG,UAACC,QAAD,EAAc;AACpB,cAAIA,QAAJ,EAAc;AACV,mBAAOT,MAAM,CAACU,IAAP,EAAP;AACH;AACJ,SALM,EAMFC,KANE,CAMI,UAAUC,GAAV,EAAe,CAAG,CANtB,CAAP;AAOH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;;;AAcI;AACJ;AACA;AACA;8BACcC,M,EAAQ;AACd,aAAOxC,CAAC,CAACyC,KAAF,CAAQ,YAAY,CAAG,CAAvB,CAAP;AACH;;;;AAED;AACJ;AACA;+BACe;AAAA;;AACP,UAAIC,aAAa,GAAG,KAAKC,cAAL,EAApB;;AACA,UAAI,KAAKrC,OAAL,CAAaQ,gBAAb,IAAiC,CAAC,KAAKR,OAAL,CAAaK,gBAAnD,EAAqE;AACjE;AACA,eAAO+B,aAAa,CAACP,IAAd,CAAmB;AAAA,iBAAM,KAAI,CAAC3B,QAAL,CAAcoC,KAAd,EAAN;AAAA,SAAnB,CAAP;AACH;;AACD,aAAOF,aAAP;AACH;;;;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;kCACkB;AACV,aAAOtC,cAAc,CAACyC,WAAf,CAA2B,IAA3B,EAAiC,KAAKtC,QAAtC,CAAP;AACH;;;gCA1CkBuC,Q,EAAUC,O,EAAS;AAClC,UAAIC,QAAQ,GAAGhD,CAAC,CAACiD,KAAF,EAAf;AACA/C,MAAAA,oBAAoB,CAAC+B,OAArB,CACKiB,GADL,CACSH,OAAO,CAACI,GAAR,CAAY,UAACxB,MAAD,EAAY;AAC7B,eAAOmB,QAAQ,CAACM,UAAT,CAAoBzB,MAApB,CAAP;AACH,OAFQ,CADT,EAIKQ,IAJL,CAIU,YAAM;AACZa,QAAAA,QAAQ,CAACK,OAAT;AACH,OAND,EAMG,YAAM;AACLL,QAAAA,QAAQ,CAACK,OAAT;AACH,OARD;AASA,aAAOL,QAAQ,CAACf,OAAhB;AACH;;;;;;AAgCLnC,OAAO,CAACM,cAAR,GAAyBA,cAAzB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n *  This is a base driver provider class.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\nconst q = require(\"q\");\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\nconst bpRunner_1 = require(\"../bpRunner\");\nclass DriverProvider {\n    constructor(config) {\n        this.config_ = config;\n        this.drivers_ = [];\n        this.bpRunner = new bpRunner_1.BlockingProxyRunner(config);\n    }\n    /**\n     * Get all existing drivers.\n     *\n     * @public\n     * @return array of webdriver instances\n     */\n    getExistingDrivers() {\n        return this.drivers_.slice(); // Create a shallow copy\n    }\n    getBPUrl() {\n        if (this.config_.blockingProxyUrl) {\n            return this.config_.blockingProxyUrl;\n        }\n        return `http://localhost:${this.bpRunner.port}`;\n    }\n    /**\n     * Create a new driver.\n     *\n     * @public\n     * @return webdriver instance\n     */\n    getNewDriver() {\n        let builder;\n        if (this.config_.useBlockingProxy) {\n            builder =\n                new selenium_webdriver_1.Builder().usingServer(this.getBPUrl()).withCapabilities(this.config_.capabilities);\n        }\n        else {\n            builder = new selenium_webdriver_1.Builder()\n                .usingServer(this.config_.seleniumAddress)\n                .usingWebDriverProxy(this.config_.webDriverProxy)\n                .withCapabilities(this.config_.capabilities);\n        }\n        if (this.config_.disableEnvironmentOverrides === true) {\n            builder.disableEnvironmentOverrides();\n        }\n        let newDriver = builder.build();\n        this.drivers_.push(newDriver);\n        return newDriver;\n    }\n    /**\n     * Quit a driver.\n     *\n     * @public\n     * @param webdriver instance\n     */\n    quitDriver(driver) {\n        let driverIndex = this.drivers_.indexOf(driver);\n        if (driverIndex >= 0) {\n            this.drivers_.splice(driverIndex, 1);\n        }\n        if (driver.getSession() === undefined) {\n            return selenium_webdriver_1.promise.when(undefined);\n        }\n        else {\n            return driver.getSession()\n                .then((session_) => {\n                if (session_) {\n                    return driver.quit();\n                }\n            })\n                .catch(function (err) { });\n        }\n    }\n    /**\n     * Quits an array of drivers and returns a q promise instead of a webdriver one\n     *\n     * @param drivers {webdriver.WebDriver[]} The webdriver instances\n     */\n    static quitDrivers(provider, drivers) {\n        let deferred = q.defer();\n        selenium_webdriver_1.promise\n            .all(drivers.map((driver) => {\n            return provider.quitDriver(driver);\n        }))\n            .then(() => {\n            deferred.resolve();\n        }, () => {\n            deferred.resolve();\n        });\n        return deferred.promise;\n    }\n    /**\n     * Default update job method.\n     * @return a promise\n     */\n    updateJob(update) {\n        return q.fcall(function () { });\n    }\n    ;\n    /**\n     * Default setup environment method, common to all driver providers.\n     */\n    setupEnv() {\n        let driverPromise = this.setupDriverEnv();\n        if (this.config_.useBlockingProxy && !this.config_.blockingProxyUrl) {\n            // TODO(heathkit): If set, pass the webDriverProxy to BP.\n            return driverPromise.then(() => this.bpRunner.start());\n        }\n        return driverPromise;\n    }\n    ;\n    /**\n     * Teardown and destroy the environment and do any associated cleanup.\n     * Shuts down the drivers.\n     *\n     * @public\n     * @return {q.Promise<any>} A promise which will resolve when the environment is down.\n     */\n    teardownEnv() {\n        return DriverProvider.quitDrivers(this, this.drivers_);\n    }\n}\nexports.DriverProvider = DriverProvider;\n//# sourceMappingURL=driverProvider.js.map"]},"metadata":{},"sourceType":"script"}