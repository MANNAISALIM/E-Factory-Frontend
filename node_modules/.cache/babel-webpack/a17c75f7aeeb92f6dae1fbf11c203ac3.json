{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * This is an implementation of the Local Driver Provider.\n * It is responsible for setting up the account object, tearing\n * it down, and setting up the driver correctly.\n *\n * TODO - it would be nice to do this in the launcher phase,\n * so that we only start the local selenium once per entire launch.\n */\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar q = require(\"q\");\n\nvar exitCodes_1 = require(\"../exitCodes\");\n\nvar logger_1 = require(\"../logger\");\n\nvar driverProvider_1 = require(\"./driverProvider\");\n\nvar SeleniumConfig = require('webdriver-manager/built/lib/config').Config;\n\nvar remote = require('selenium-webdriver/remote');\n\nvar logger = new logger_1.Logger('local');\n\nvar Local = /*#__PURE__*/function (_driverProvider_1$Dri) {\n  _inherits(Local, _driverProvider_1$Dri);\n\n  var _super = _createSuper(Local);\n\n  function Local(config) {\n    var _this;\n\n    _classCallCheck(this, Local);\n\n    _this = _super.call(this, config);\n    _this.server_ = null;\n    return _this;\n  }\n  /**\n   * Helper to locate the default jar path if none is provided by the user.\n   * @private\n   */\n\n\n  _createClass(Local, [{\n    key: \"addDefaultBinaryLocs_\",\n    value: function addDefaultBinaryLocs_() {\n      if (!this.config_.seleniumServerJar) {\n        logger.debug('Attempting to find the SeleniumServerJar in the default ' + 'location used by webdriver-manager');\n\n        try {\n          var updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n          var updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n          this.config_.seleniumServerJar = updateConfig.standalone.last;\n        } catch (err) {\n          throw new exitCodes_1.BrowserError(logger, 'No update-config.json found.' + ' Run \\'webdriver-manager update\\' to download binaries.');\n        }\n      }\n\n      if (!fs.existsSync(this.config_.seleniumServerJar)) {\n        throw new exitCodes_1.BrowserError(logger, 'No selenium server jar found at ' + this.config_.seleniumServerJar + '. Run \\'webdriver-manager update\\' to download binaries.');\n      }\n\n      if (this.config_.capabilities.browserName === 'chrome') {\n        if (!this.config_.chromeDriver) {\n          logger.debug('Attempting to find the chromedriver binary in the default ' + 'location used by webdriver-manager');\n\n          try {\n            var _updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n\n            var _updateConfig = JSON.parse(fs.readFileSync(_updateJson).toString());\n\n            this.config_.chromeDriver = _updateConfig.chrome.last;\n          } catch (err) {\n            throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        } // Check if file exists, if not try .exe or fail accordingly\n\n\n        if (!fs.existsSync(this.config_.chromeDriver)) {\n          if (fs.existsSync(this.config_.chromeDriver + '.exe')) {\n            this.config_.chromeDriver += '.exe';\n          } else {\n            throw new exitCodes_1.BrowserError(logger, 'Could not find chromedriver at ' + this.config_.chromeDriver + '. Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        }\n      }\n\n      if (this.config_.capabilities.browserName === 'firefox') {\n        if (!this.config_.geckoDriver) {\n          logger.debug('Attempting to find the gecko driver binary in the default ' + 'location used by webdriver-manager');\n\n          try {\n            var _updateJson2 = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n\n            var _updateConfig2 = JSON.parse(fs.readFileSync(_updateJson2).toString());\n\n            this.config_.geckoDriver = _updateConfig2.gecko.last;\n          } catch (err) {\n            throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        } // Check if file exists, if not try .exe or fail accordingly\n\n\n        if (!fs.existsSync(this.config_.geckoDriver)) {\n          if (fs.existsSync(this.config_.geckoDriver + '.exe')) {\n            this.config_.geckoDriver += '.exe';\n          } else {\n            throw new exitCodes_1.BrowserError(logger, 'Could not find gecko driver at ' + this.config_.geckoDriver + '. Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        }\n      }\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @public\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n\n  }, {\n    key: \"setupDriverEnv\",\n    value: function setupDriverEnv() {\n      var _this2 = this;\n\n      this.addDefaultBinaryLocs_();\n      logger.info('Starting selenium standalone server...');\n      var serverConf = this.config_.localSeleniumStandaloneOpts || {}; // If args or port is not set use seleniumArgs and seleniumPort\n      // for backward compatibility\n\n      if (serverConf.args === undefined) {\n        serverConf.args = this.config_.seleniumArgs || [];\n      }\n\n      if (serverConf.jvmArgs === undefined) {\n        serverConf.jvmArgs = this.config_.jvmArgs || [];\n      } else {\n        if (!Array.isArray(serverConf.jvmArgs)) {\n          throw new exitCodes_1.ConfigError(logger, 'jvmArgs should be an array.');\n        }\n      }\n\n      if (serverConf.port === undefined) {\n        serverConf.port = this.config_.seleniumPort;\n      } // configure server\n\n\n      if (this.config_.chromeDriver) {\n        serverConf.jvmArgs.push('-Dwebdriver.chrome.driver=' + this.config_.chromeDriver);\n      }\n\n      if (this.config_.geckoDriver) {\n        serverConf.jvmArgs.push('-Dwebdriver.gecko.driver=' + this.config_.geckoDriver);\n      }\n\n      this.server_ = new remote.SeleniumServer(this.config_.seleniumServerJar, serverConf);\n      var deferred = q.defer(); // start local server, grab hosted address, and resolve promise\n\n      this.server_.start(this.config_.seleniumServerStartTimeout).then(function (url) {\n        logger.info('Selenium standalone server started at ' + url);\n        return _this2.server_.address();\n      }).then(function (address) {\n        _this2.config_.seleniumAddress = address;\n        deferred.resolve();\n      }).catch(function (err) {\n        deferred.reject(err);\n      });\n      return deferred.promise;\n    }\n    /**\n     * Teardown and destroy the environment and do any associated cleanup.\n     * Shuts down the drivers and server.\n     *\n     * @public\n     * @override\n     * @return {q.promise} A promise which will resolve when the environment\n     *     is down.\n     */\n\n  }, {\n    key: \"teardownEnv\",\n    value: function teardownEnv() {\n      var _this3 = this;\n\n      return _get(_getPrototypeOf(Local.prototype), \"teardownEnv\", this).call(this).then(function () {\n        logger.info('Shutting down selenium standalone server.');\n        return _this3.server_.stop();\n      });\n    }\n  }]);\n\n  return Local;\n}(driverProvider_1.DriverProvider);\n\nexports.Local = Local;","map":{"version":3,"sources":["C:/Users/NeverMind/IntelliJIDEAProjects/argon-dashboard-angular-master/node_modules/protractor/built/driverProviders/local.js"],"names":["Object","defineProperty","exports","value","fs","require","path","q","exitCodes_1","logger_1","driverProvider_1","SeleniumConfig","Config","remote","logger","Logger","Local","config","server_","config_","seleniumServerJar","debug","updateJson","resolve","getSeleniumDir","updateConfig","JSON","parse","readFileSync","toString","standalone","last","err","BrowserError","existsSync","capabilities","browserName","chromeDriver","chrome","geckoDriver","gecko","addDefaultBinaryLocs_","info","serverConf","localSeleniumStandaloneOpts","args","undefined","seleniumArgs","jvmArgs","Array","isArray","ConfigError","port","seleniumPort","push","SeleniumServer","deferred","defer","start","seleniumServerStartTimeout","then","url","address","seleniumAddress","catch","reject","promise","stop","DriverProvider"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is an implementation of the Local Driver Provider.\n * It is responsible for setting up the account object, tearing\n * it down, and setting up the driver correctly.\n *\n * TODO - it would be nice to do this in the launcher phase,\n * so that we only start the local selenium once per entire launch.\n */\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst q = require(\"q\");\nconst exitCodes_1 = require(\"../exitCodes\");\nconst logger_1 = require(\"../logger\");\nconst driverProvider_1 = require(\"./driverProvider\");\nconst SeleniumConfig = require('webdriver-manager/built/lib/config').Config;\nconst remote = require('selenium-webdriver/remote');\nlet logger = new logger_1.Logger('local');\nclass Local extends driverProvider_1.DriverProvider {\n    constructor(config) {\n        super(config);\n        this.server_ = null;\n    }\n    /**\n     * Helper to locate the default jar path if none is provided by the user.\n     * @private\n     */\n    addDefaultBinaryLocs_() {\n        if (!this.config_.seleniumServerJar) {\n            logger.debug('Attempting to find the SeleniumServerJar in the default ' +\n                'location used by webdriver-manager');\n            try {\n                let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n                let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n                this.config_.seleniumServerJar = updateConfig.standalone.last;\n            }\n            catch (err) {\n                throw new exitCodes_1.BrowserError(logger, 'No update-config.json found.' +\n                    ' Run \\'webdriver-manager update\\' to download binaries.');\n            }\n        }\n        if (!fs.existsSync(this.config_.seleniumServerJar)) {\n            throw new exitCodes_1.BrowserError(logger, 'No selenium server jar found at ' + this.config_.seleniumServerJar +\n                '. Run \\'webdriver-manager update\\' to download binaries.');\n        }\n        if (this.config_.capabilities.browserName === 'chrome') {\n            if (!this.config_.chromeDriver) {\n                logger.debug('Attempting to find the chromedriver binary in the default ' +\n                    'location used by webdriver-manager');\n                try {\n                    let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n                    let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n                    this.config_.chromeDriver = updateConfig.chrome.last;\n                }\n                catch (err) {\n                    throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' +\n                        'Run \\'webdriver-manager update\\' to download binaries.');\n                }\n            }\n            // Check if file exists, if not try .exe or fail accordingly\n            if (!fs.existsSync(this.config_.chromeDriver)) {\n                if (fs.existsSync(this.config_.chromeDriver + '.exe')) {\n                    this.config_.chromeDriver += '.exe';\n                }\n                else {\n                    throw new exitCodes_1.BrowserError(logger, 'Could not find chromedriver at ' + this.config_.chromeDriver +\n                        '. Run \\'webdriver-manager update\\' to download binaries.');\n                }\n            }\n        }\n        if (this.config_.capabilities.browserName === 'firefox') {\n            if (!this.config_.geckoDriver) {\n                logger.debug('Attempting to find the gecko driver binary in the default ' +\n                    'location used by webdriver-manager');\n                try {\n                    let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n                    let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n                    this.config_.geckoDriver = updateConfig.gecko.last;\n                }\n                catch (err) {\n                    throw new exitCodes_1.BrowserError(logger, 'No update-config.json found. ' +\n                        'Run \\'webdriver-manager update\\' to download binaries.');\n                }\n            }\n            // Check if file exists, if not try .exe or fail accordingly\n            if (!fs.existsSync(this.config_.geckoDriver)) {\n                if (fs.existsSync(this.config_.geckoDriver + '.exe')) {\n                    this.config_.geckoDriver += '.exe';\n                }\n                else {\n                    throw new exitCodes_1.BrowserError(logger, 'Could not find gecko driver at ' + this.config_.geckoDriver +\n                        '. Run \\'webdriver-manager update\\' to download binaries.');\n                }\n            }\n        }\n    }\n    /**\n     * Configure and launch (if applicable) the object's environment.\n     * @public\n     * @return {q.promise} A promise which will resolve when the environment is\n     *     ready to test.\n     */\n    setupDriverEnv() {\n        this.addDefaultBinaryLocs_();\n        logger.info('Starting selenium standalone server...');\n        let serverConf = this.config_.localSeleniumStandaloneOpts || {};\n        // If args or port is not set use seleniumArgs and seleniumPort\n        // for backward compatibility\n        if (serverConf.args === undefined) {\n            serverConf.args = this.config_.seleniumArgs || [];\n        }\n        if (serverConf.jvmArgs === undefined) {\n            serverConf.jvmArgs = this.config_.jvmArgs || [];\n        }\n        else {\n            if (!Array.isArray(serverConf.jvmArgs)) {\n                throw new exitCodes_1.ConfigError(logger, 'jvmArgs should be an array.');\n            }\n        }\n        if (serverConf.port === undefined) {\n            serverConf.port = this.config_.seleniumPort;\n        }\n        // configure server\n        if (this.config_.chromeDriver) {\n            serverConf.jvmArgs.push('-Dwebdriver.chrome.driver=' + this.config_.chromeDriver);\n        }\n        if (this.config_.geckoDriver) {\n            serverConf.jvmArgs.push('-Dwebdriver.gecko.driver=' + this.config_.geckoDriver);\n        }\n        this.server_ = new remote.SeleniumServer(this.config_.seleniumServerJar, serverConf);\n        let deferred = q.defer();\n        // start local server, grab hosted address, and resolve promise\n        this.server_.start(this.config_.seleniumServerStartTimeout)\n            .then((url) => {\n            logger.info('Selenium standalone server started at ' + url);\n            return this.server_.address();\n        })\n            .then((address) => {\n            this.config_.seleniumAddress = address;\n            deferred.resolve();\n        })\n            .catch((err) => {\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    }\n    /**\n     * Teardown and destroy the environment and do any associated cleanup.\n     * Shuts down the drivers and server.\n     *\n     * @public\n     * @override\n     * @return {q.promise} A promise which will resolve when the environment\n     *     is down.\n     */\n    teardownEnv() {\n        return super.teardownEnv().then(() => {\n            logger.info('Shutting down selenium standalone server.');\n            return this.server_.stop();\n        });\n    }\n}\nexports.Local = Local;\n//# sourceMappingURL=local.js.map"]},"metadata":{},"sourceType":"script"}